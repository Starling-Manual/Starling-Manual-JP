== アニメーション

アニメーションはゲームの重要な要素であるというだけでなく、最近ではビジネス系のアプリであってもスムーズな動きを期待されています。
うまく配置されたアニメーションは、直感的でレスポンシブなインターフェースを提供するために大いに役立ちます。
//原文：Some well placed animations go a long way towards providing a responsive and intuitive interface.
そのような目的を満たせるように、Starling は柔軟なアニメーションエンジンを提供します。

アニメーションには２つのタイプがあります。
//原文：If you think about it, there are two types of animations.

* 一方では、アニメーションはとても動的なので、前もって何が起こるかを知る事は出来ない事がわかります。
//原文：On the one hand, you've got animations that are so dynamic that you don't know beforehand what exactly will happen.
自キャラに向かってやって来る敵キャラの事を考えてみてください。移動の方向とスピードを毎フレーム状況に合わせて更新しなくてはいけません。
物理演算もそうです。力の設定やあたり判定の存在が全てを変えてしまいます。
//原文：Or physics: each additional force or collision changes everything.

* そして詳細な計画通りに動作するアニメーションもあります。
最初の時点で何がどう起こるのかを知る事ができるのです。
消えていくメッセージボックスや、シーンの遷移アニメーションなど考えてみて下さい。

以下で、その２つのアニメーションを詳しく見ていきます。

=== EnterFrame イベント

いくつかのゲームエンジンでは、_run-loop_ というものが実装されています。
//原文：In some game engines, you have what is called a _run-loop_.
これは終わりのない無限ループ処理で、定期的にシーン上の全ての物体に更新処理を行います。

Starling では、ディスプレイリストの構造による理由から、そのような run loop 処理が適していません。
ゲームをたくさんのディスプレイオブジェクトで構成しているかと思いますが、それぞれのディスプレイオブジェクトは時間の経過ごとに何をすればいいのか把握しているべきです。
//原文：You separated your game into numerous different custom display objects,and each should know for itself what to do when some time has passed.

それこそが、_EnterFrameEvent_ がポイントとする所です。時間がたつとともにディスプレイオブジェクトが自分自身を更新する事が出来るようになります。
毎フレームでディスプレイリストを構成する全てのディスプレイオブジェクトに EnterFrame イベントが発信されます。
下記はそのイベントの利用例です。

[source, as3]
----
public function CustomObject()
{
    addEventListener(Event.ENTER_FRAME, onEnterFrame); // <1>
}

private function onEnterFrame(event:Event, passedTime:Number):void // <2>
{
    trace("Time passed since last frame: " + passedTime);
    bird.advanceTime(passedTime);
}
----
<1> どこでも EnterFrame に対してりすな登録を行うことできます。コンストラクタに書くのも良い選択です。
<2> イベントリスナーでは、このようにイベントを受け取ります。

`onEnterFrame` メソッドは１フレームに１度だけ呼び出されます。
その際に前のフレームから経過した時間を引数として受け取る事ができます。
その情報を元に、敵キャラや太陽の位置や、その他必要な処理を行う事ができるのです。

このイベントに隠された強力な機能は、完全に異なる処理をその時々で行えるという事です。
//原文：The power behind this event is that you can do completely different things each time it occurs.
現在のゲームの状況に合わせて柔軟に対応する事ができます。
例えば、シンプルな敵AIとして、敵キャラをプレイヤーの方向に移動させたりする事ができるのです。

=== トゥイーン

アニメーションについて
//原文：Now to predefined animations.

They are very common and have names such as _movement_, _scale_, _fade_, etc.
Starling のこれらに対するアニメーションの取り組み方はシンプルです。そして同時にとても柔軟でもあります。
基本的にどのオブジェクトのどのプロパティであっても、それが数値 (`Number`、`int`、`uint`) で表されるものであればアニメーションさせる事ができます。
それらのアニメーションは _Tween_ と呼ばれるオブジェクトにより表されます。
//原文：Those animations are described in an object called _Tween_.

NOTE: "Tween" の語源は手書きのアニメーションから来ています。 チーフイラストレーターが動画の大事なコマだけを描き、残りのつなぎ部分 (be**tween**) はチームの別の担当者が描くのです。

.tween 中のそれぞれのフレーム。
image::soccer-tween.png[Soccer Tween]

理屈はこのくらいにして、実際の例を見てみましょう。

[source, as3]
----
var tween:Tween = new Tween(ball, 0.5);

tween.animate("x", 20);
tween.animate("scale", 2.0);
tween.animate("alpha", 0.0);
----

この tween では　'ボール' の位置が　X＝20 、サイズは倍、透明度は 0 になるように設定されています。
これらの変化は 0.5 秒をかけて、一斉に進行します。
それぞれのパラメータのトゥイーン開始時の値は、単純に現在のプロパティ値となります。

この例では以下のような事がわかります。

* オブジェクトの任意の値をアニメーションさせる事が可能です。
* いくつかのアニメーションを１つのオブジェクトにまとめて実行させる事ができます。

ところで、拡大とフェードと移動のアニメーションは、しばしば実行されるので、_Tween_ クラスはそれらに専用のメソッドを用意しています。
同じ処理は下記のようにも書けます。

[source, as3]
----
tween.moveTo(20, 0); // "x" and "y" のアニメーション
tween.scaleTo(2);    // "scale" のアニメーション
tween.fadeTo(0);     // "alpha" のアニメーション
----

tween 処理の面白いところは、アニメーションの実行の方法を変更できると言う事です。例えば、初めはゆっくり動き、だんだん早くなる、と言うような事ができます。
トランジションのタイプを指定する事で、それが可能です。

.指定可能なトランジションタイプ。 デフォルトの `linear` のグラフは省略されています。
image::transitions.png[Transitions]

下記の例は、トランジションの指定をどのように行うかと、tween が提供するその他いくつかの機能についてです。

[source, as3]
----
var tween:Tween = new Tween(ball, 0.5, Transitions.EASE_IN); // <1>
tween.onStart    = function():void { /* ... */ };
tween.onUpdate   = function():void { /* ... */ }; // <2>
tween.onComplete = function():void { /* ... */ };
tween.delay = 2; // <3>
tween.repeatCount = 3; // <4>
tween.reverse = true;
tween.nextTween = explode; // <5>
----
<1> 3番目の引数でトランジションのタイプを指定します。
<2> これらのコールバックはそれぞれ、トゥイーンが始まった時、トゥイーン中の毎フレーム、トゥイーン終了後に呼び出されます。
<3> アニメーションの開始前に2秒間待ちます。
<4> トゥイーンを 3回繰り返します。オプション指定で行ったり来たりするヨーヨースタイルに設定しています。
もしも `repeatCount` をゼロに設定した場合は、トゥイーンが永久に繰り返されます。
<5> 最初のトゥイーンが終了した後に、別のトゥイーン処理を開始します。

さて、これでトゥイーンの設定を終えたのですが、まだ何も起きません。
tween オブジェクトはアニメーションを設定しますが、実行はしないのです。

tween の `advanceTime` メソッドを手動で実行する事で、アニメーションを進める事ができます。

[source, as3]
----
ball.x = 0;
tween = new Tween(ball, 1.0);
tween.animate("x", 100);

tween.advanceTime(0.25); // -> ball.x =  25
tween.advanceTime(0.25); // -> ball.x =  50
tween.advanceTime(0.25); // -> ball.x =  75
tween.advanceTime(0.25); // -> ball.x = 100
----

上記のやり方で確かに動きますが、しかし、これではちょっと面倒ですよね。
`ENTER_FRAME` イベントハンドラ内で `advanceTime` を呼ぶこともできますが、それでもやはり、アニメーションの数が増えてくると面倒になってしまうでしょう。

心配しないでください。それをなんとかしてくれる"ヤツ"を知っています。
//原文：Don't worry: I know just the guy for you.
そのような事の取り扱いに慣れているヤツです。
//原文：He's really good at handling such things.

=== Juggler

ジャグラー (Juggler）というクラスは、アニメーションするオブジェクトをいくつでも受け取り、アニメーションを再生してくれます。
実際の曲芸師(ジャグラー)のように、粘り強く情熱を遂行します。つまり、登録されたオブジェクトの `advanceTime` メソッドを呼び出し続けてくれます。
//原文：Like any true artist, it will tenaciously pursue its true passion, which is: continuously calling `advanceTime` on everything you throw at it.
Starling インスタンスには、デフォルトで利用できるジャグラーが１つ用意されています。
アニメーションを実行する最も簡単な方法は、下記の１行です。ただ、アニメーション（トゥイーン) をデフォルトのジャグラーに登録して終わりです。

[source, as3]
----
Starling.juggler.add(tween);
----

トゥイーンが終了すると、自動ですぐに登録されたアニメーションは破棄されます。
たいていの場合、このシンプルな方法で十分であるかと思います。

しかし別のケースでは、もっと細かくコントロールしたい事もあります。
例えば、ステージ上にメイン処理を行うゲームエリアがあるとします。
ユーザーがポーズボタンを押した時には、ゲームを停止させて、メッセージボックスをアニメーションとともに表示させ、ゲームに戻るメニューも提供するかもしれません。
//原文：maybe providing an option to return to the menu.

この時、ゲーム部分は完全に停止するべきです。内部のアニメーションは進行しません。
しかし問題は、メッセージボックスもアニメーションを持っているので、デフォルトのジャグラーを停止する事は出来ないという事です。

そのようなケースでは、ゲームエリアに固有のジャグラーを提供するのが良いでしょう。
ゲーム停止ボタンを押されるとすぐに、このジャグラーのアニメーション全てを停止しましょう。
ゲームは現在の状態のまま停止しますが、メッセージボックスのアニメーション（デフォルトのジャグラーか、また別のジャグラーを使っている）は普通に動きます。

カスタムジャグラーを使う場合、その `advanceTime` メソッドを毎フレーム呼んでやります。
下記のようにジャグラーを制御するのが良いでしょう。

[source, as3]
----
public class Game // <1>
{
    private var _gameArea:GameArea;

    private function onEnterFrame(event:Event, passedTime:Number):void
    {
        if (activeMsgBox)
            trace("waiting for user input");
        else
            _gameArea.advanceTime(passedTime); // <2>
    }
}

public class GameArea
{
    private var _juggler:Juggler; // <3>

    public function advanceTime(passedTime:Number):void
    {
        _juggler.advanceTime(passedTime); // <4>
    }
}
----
<1> ゲームのルートクラスで、`Event.ENTER_FRAME` イベントをリッスンします。
<2> メッセージボックスが存在する際は、`gameArea` のみ進行するようにします。
<3> _GameArea_ は自身に専用のジャグラーを持っています。ゲーム中のアニメーション全てをそれがまかないます。
<4> ジャグラーは _Game_ により呼ばれた `advanceTime` メソッド内で、実際に進行されます。

このやり方で、ゲームとメッセージボックスのアニメーションを適切に分けることができます。

しかし、ジャグラーが扱うことができるのは、トゥイーンだけではありません。
`IAnimatable` インターフェースを実装したクラスであれば、なんでもジャグラーに登録できるのです。
このインターフェースには１つのメソッドしか定義されていません。

[source, as3]
----
function advanceTime(time:Number):void;
----

このメソッドを実装する事で、例えば簡単なムビークリップのようなクラスを自身で作る事もできます。
`advanceTime` メソッド内で、定期的に表示されているテクスチャーを切り替えればいいのです。
ムービークリップを再生するには、ただジャグラーに登録するでけで良いです。

さて、ここで疑問が残るかもしれません。いつどのようにしてジャグラーから登録されたオブジェクトが取り除かれるのだろうか、と。

==== Stopping Animations

When a tween finishes, it is removed from the juggler automatically.
If you want to abort the animation before it is finished, you simply remove it from the juggler.

Let's say you just created a tween that animates a ball and added it to the default juggler:

[source, as3]
----
tween:Tween = new Tween(ball, 1.5);
tween.moveTo(x, y);
Starling.juggler.add(tween);
----

There are several ways you can abort that animation.
Depending on the circumstances, simply pick the one that suits your game logic best.

[source, as3]
----
var animID:uint = juggler.add(tween);

Starling.juggler.remove(tween); // <1>
Starling.juggler.removeTweens(ball); // <2>
Starling.juggler.removeByID(animID); // <3>
Starling.juggler.purge(); // <4>
----
<1> Remove the tween directly. This works with any `IAnimatable` object.
<2> Remove all tweens that affect the ball. Only works for tweens!
<3> Remove the tween by its ID. Useful when you don't have access to the _Tween_ instance.
<4> If you want to abort everything, purge the juggler.

Be a little careful with the `purge` method, though: if you call it on the default juggler, another part of your code might suddenly be faced with an aborted animation, bringing the game to a halt.
I recommend you use `purge` only on your custom jugglers.

==== アニメーション登録の自動削除

アニメーションが終了した際に、どのようにして _Tween_ クラスが、ジャグラーからトゥイーンを削除するのか、疑問に思ったかもしれません。
//原文:You might have asked yourself how the _Tween_ class manages to have tweens removed from the juggler automatically once they are completed.
これは、`REMOVE_FROM_JUGGLER` イベントを利用して行われています。

`IAnimatable` を実装したオブジェクトは、そのイベントを投げる事ができます。ジャグラーはそのイベントを受け取り、それに応じてそのオブジェクトを登録から削除します。

[source, as3]
----
public class MyAnimation extends EventDispatcher implements IAnimatable
{
    public function stop():void
    {
        dispatchEventWith(Event.REMOVE_FROM_JUGGLER);
    }
}
----

==== 複数 Tween を１コマンドで実行する

ジャグラーとトゥイーンが分離されている事はとてもパワフルですが、簡単なアニメーションの登録にたくさんのコードを記述しなくてはいけない状況になる事があるでしょう。
これが、ジャグラー側に１コマンドでトゥイーンを実行する便利なメソッドが用意されている理由です。
下記がサンプルです。

[source, as3]
----
juggler.tween(msgBox, 0.5, {
   transition: Transitions.EASE_IN,
   onComplete: function():void { button.enabled = true; },
   x: 300,
   rotation: deg2rad(90)
});
----

このコードでは、`msgBox` オブジェクトにトゥイーンを設定しています。0.5秒間で `x` 及び `rotation` を変更するものです。
トゥイーン自体のプロパティと同じように、`{}` パラメータでオブジェクトにアニメーションさせたい項目が並んでいる事がわかるかと思います。
時間を節約する事ができますね。

=== Delayed Calls

Technically, we have now covered all the animation types Starling supports.
However, there's actually another concept that's deeply connected to this topic.

Remember _Einstein_, our dog-hero who introduced us to the event system?
The last time we saw him, he had just lost all his health points and was about to call `gameOver`.
But wait: don't call that method immediately -- that would end the game too abruptly.
Instead, call it with a delay of, say, two seconds (time enough for the player to realize the drama that is unfolding).

To implement that delay, you could use a native _Timer_ or the `setTimeout`-method.
However, you can also use the juggler, and that has a huge advantage: you remain in full control.

It becomes obvious when you imagine that the player hits the "Pause" button right now, before those two seconds have passed.
In that case, you not only want to stop the game area from animating; you want this delayed `gameOver` call to be delayed even more.

To do that, make a call like the following:

[source, as3]
----
juggler.delayCall(gameOver, 2);
----

The `gameOver` function will be called two seconds from now (or longer if the juggler is disrupted).
It's also possible to pass some arguments to that method.
Want to dispatch an event instead?

[source, as3]
----
juggler.delayCall(dispatchEventWith, 2, "gameOver");
----

Another handy way to use delayed calls is to perform periodic actions.
Imagine you want to spawn a new enemy once every three seconds.

[source, as3]
----
juggler.repeatCall(spawnEnemy, 3);
----

[NOTE]
====
Behind the scenes, both `delayCall` and `repeatCall` create an object of type _DelayedCall_.
Just like the `juggler.tween` method is a shortcut for using tweens, those methods are shortcuts for creating delayed calls.
====

To abort a delayed call, use one of the following methods:

[source, as3]
----
var animID:uint = juggler.delayCall(gameOver, 2);

juggler.removeByID(animID);
juggler.removeDelayedCalls(gameOver);
----

=== ムービークリップ

すでに _Mesh_ 周辺のクラス図を見た際に、_MovieClip_ クラスの存在に気づいたかもしれません。
//原文：You might have noticed the _MovieClip_ class already when we looked at the class diagram surrounding _Mesh_.
実際、_MovieClip_ は _Image_ のサブクラスで、そのテクスチャーを時間経過毎に変更するだけの物です。
//原文：That's right: a _MovieClip_ is actually just a subclass of _Image_ that changes its texture over time.
Starling 上でのアニメーションGIFだと理解しましょう。

==== テクスチャーの獲得
//原文：Acquiring Textures

ムービークリップのすべての画像は１枚のアトラスから読み込まれる事が推奨されます。そしてそれらはすべて同じ大きさである必要があります。
（もし同じサイズでない場合、１コマ目のサイズに変形されます。）
_Adobe Animate_ のようなツールを使って、そのようなアニメーションを用意する事ができます。Animate からは直接 Starling 用のテクスチャーアトラスデータを書き出す事ができます。

下記は、ムービークリップ用のフレームを持つテクスチャーアトラスデータのサンプルです。
まずはXML内のフレーム座標設定を確認しましょう。
どのフレームも `flight_` の名前で始まる事に注目してください。

[source, xml]
----
<TextureAtlas imagePath="atlas.png">
    <SubTexture name="flight_00" x="0"   y="0" width="50" height="50" />
    <SubTexture name="flight_01" x="50"  y="0" width="50" height="50" />
    <SubTexture name="flight_02" x="100" y="0" width="50" height="50" />
    <SubTexture name="flight_03" x="150" y="0" width="50" height="50" />
    <!-- ... -->
</TextureAtlas>
----

下記が対応するテクスチャです。

.ムービークリップの各フレーム。
image::flight-animation.png[Flight Animation]

==== ムービークリップの作成

さあ、ムービークリップを作成しましょう。
下記の atlas 変数がすべてのフレームを含む _TextureAtlas_ の参照であるならば、話はとても簡単です。
//原文：Supposing that the `atlas` variable points to a _TextureAtlas_ containing all our frames, that's really easy.

[source, as3]
----
var frames:Vector.<Texture> = atlas.getTextures("flight_"); // <1>
var movie:MovieClip = new MovieClip(frames, 10); // <2>
addChild(movie);

movie.play();
movie.pause(); // <3>
movie.stop();

Starling.juggler.add(movie); // <4>
----
<1> `getTextures` メソッドは与えられた接頭語で始まるすべてのテクスチャーをABC順で返します。
<2> これだけでOKです。上記のテクスチャー一覧をコンストラクタに渡します。
//原文：That's ideal for our _MovieClip_, because we can pass those textures right to its constructor. 
２番目のパラメータは１秒間に何回描画更新がかかるかを示します。
<3> ムービークリップの再生状態をコントロールするメソッドがいくつか存在します。デフォルトでは再生している状態から始まります。
<4> Important: 他の Starling 上のアニメーションと同じように、ムービークリップもジャグラーに登録される必要があります！

接頭語の `flight_` を使ってどのようにテクスチャアトラスからテクスチャーの一覧を参照したか、わかったでしょうか？
このやり方では、アトラスにムービークリップ以外の画像を含ませる事も可能になります。
一つのムービークリップのフレームをグループ化する為に、それぞれで同じ接頭語を持たせるわけです。

ムービークリップには、サウンドや任意の処理を実行するため、あるフレームが再生された際に実行されるコールバックを仕込む事ができます。
APIリファレンスを確認して、何ができるのか把握しましょう！

==== さらに複雑なアニメーション

このアニメーションの仕組みの悪い面も伝えなくてはいけません。
//原文：A downside of this animation technique has to be mentioned, though:
もしもアニメーションの尺が長かったり、各フレームの画像が大きい場合、テクスチャーメモリーが足りなくなってしまう場合があるという事です。
アニメーションが複数の大きなテクスチャアトラスにまたがっている場合、メモリに収まらないでしょう。
//原文：If your animations take up several big texture atlases, they might not fit into memory.

そのようなタイプのアニメーションには、もっと手の込んだ作りの仕組みに切り替えましょう。それが、スケルタル（ボーン）アニメーションです。
そこでは、キャラクターはいくつかのパーツ（ボーン）に分解され、それぞれが別々にアニメーション制御されます。（そのキャラクターの骨格によります。）
これはとても柔軟な方法です。

そのようなアニメーション機能は Starling に含まれていません。しかし、いくつかの外部ツール・ライブラリが役立ちます。
下記のリストにあるソリューションはそれぞれ Starling とともに、とてもうまく動きます。

* http://esotericsoftware.com/[Spine]
* https://github.com/threerings/flump[Flump]
* http://dragonbones.github.io/[Dragon Bones]
* http://gafmedia.com[Generic Animation Format]
