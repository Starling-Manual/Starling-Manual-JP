== アセット管理

どのアプリケーションでもテクスチャがリソースの大きな範囲をしめる事はここまでで明らかとなりました。
//原文：One thing should be clear by now: textures make up a big part of every application's resources.
特にゲームではたくさんのギラフィックを必要とします。具体的には、ユーザインタフェース、キャラクター、アイテム、背景画像などです。
しかし、それで全てではありません。サウンドファイルや設定ファイルもおそらく必要となるでしょう。

これらのアセットにアクセスするには、いくつかの方法があります。

* アプリケーションに `[Embed]` メタデータ指定で埋め込んでしまう。
* ストレージからそれらを読み込む。 (AIR アプリケーションにでのみ可能です。)
* 例えば Webサーバなどの URL からロードする。

それぞれのやり方で異なったコーディングが必要なため（アセットのタイプとロードの仕組みによります。）、統一した方法でアセットにアクセスするのは難しいのです。
幸運にも、Starling にはそれをうまく扱ってくれる _AssetManager_ というクラスを含まれています。

_AssetManager_ は以下のタイプのアセット読み込みをサポートします。

* テクスチャ (ビットマップでも ATF 形式でも)
* テクスチャアトラス
* ビットマップフォント
* サウンド
* XML データ
* JSON データ
* その他バイナリファイル

アセットの読み込みを完了するまで、 AssetManager は３ステップのアプローチを取ります。

1. 読み込みたいアセットの "ポインタ" をキューに積みます。"ポインタ" とは、`File` オブジェクトや URL などです。
2. キューの処理実行を AssetManager に伝えます。
3. キューの読み込みが完了次第、いくつかの `get` で始まるメソッドでアセットにアクセスが可能になります。

[TIP]
====
AssetManager には `verbose` プロパティが存在します。
これが 有効（true）に設定されると、キューイングとローディングの全てのステップがコンソールにログ出力されるようになります。
あるアセットがロードされない理由がわからない場合など、デバッグ作業にとても有効です。
この理由から、最新の Starling ではこのプロパティが有効とされています。
====

=== アセット読み込みのキュー管理

最初のステップは扱いたいファイルを全てキューに入れる事です。
//原文：The first step is to enqueue all the assets you want to use.
どのように処理されるかは、アセットのタイプとそれぞれの出どころによります。

==== ディスクまたはネットワークからのアセット読み込み

ファイルをキューに入れる祭、読み込み元がディスクもしくはリモートのサーバーである場合はわかりやすいです。

[source, as3]
----
// リモートURLからキューに積む
assets.enqueue("http://gamua.com/img/starling.jpg");

// ディスクからキューに積む (AIR のみ)
var appDir:File = File.applicationDirectory;
assets.enqueue(appDir.resolvePath("sounds/music.mp3"));

// 全てのファイルを再帰的にディレクトリから読み込む (AIR のみ).
assets.enqueue(appDir.resolvePath("textures"));
----

テクスチャアトラスを読み込む場合、XMLと対応したテクスチャをそのままキューに積めば良いです。
ただし、XML の `imagePath` 属性値に正しいファイル名が設定されている状態として下さい。
AssetManager が実際にアトラスを実体化する際にその属性値を参照するからです。

[source, as3]
----
assets.enqueue(appDir.resolvePath("textures/atlas.xml"));
assets.enqueue(appDir.resolvePath("textures/atlas.png"));
----

**ビットマップフォント** も同じように動きます。
その場合、XML の `file` 属性値がらdしい設定であるようにして下さい。

[source, as3]
----
assets.enqueue(appDir.resolvePath("fonts/desyrel.fnt"));
assets.enqueue(appDir.resolvePath("fonts/desyrel.png"));
----

==== 埋め込みアセットの読み込み

埋め込みアセットに対しては、全ての埋め込み処理を１つのクラスにまとめる事をおすすめします。
`public static const` としてそれらを宣言して、下記の命名規則に従って下さい。

* 埋め込まれた画像ファイルは、そのファイル名と完全に同じ名前を持つようにして下さい。その際、拡張子は含まなくて良いです。
これは、XML(アトラスまたはフォント設定)からのファイル参照が壊れないために必要です。

* アトラスとビットマップフォントの XML ファイルは任意の名前を取ることができます。何故ならばファイルネームで参照されることはないからです。

サンプルのクラスのコードは下記のようになります。

[source, as3]
----
public class EmbeddedAssets
{
    /* PNG texture */
    [Embed(source = "/textures/bird.png")]
    public static const bird:Class;

    /* ATF texture */
    [Embed(source   = "textures/1x/atlas.atf",
           mimeType = "application/octet-stream")]
    public static const atlas:Class;

    /* XML file */
    [Embed(source   = "textures/1x/atlas.xml",
           mimeType = "application/octet-stream")]
    public static const atlas_xml:Class;

    /* MP3 sound */
    [Embed(source = "/audio/explosion.mp3")]
    public static const explosion:Class;
}
----

このクラスをキューに積んだ場合、asset manager は全ての埋め込まれたアセットをインスタンス化します。

[source, as3]
----
var assets:AssetManager = new AssetManager();
assets.enqueue(EmbeddedAssets); // <1>
----
<1> `bird` テクスチャーと、 `explosion` サウンドと、テクスチャアトラスがキューに積まれている。

==== Per-Asset Configuration

When you create a texture manually (via the `Texture.from...()` factory methods), you've got a chance to fine-tune how it is created.
For example, you can decide on a texture format or scale factor.

The problem with those settings: once the texture is created, you cannot change them any more.
So you need to make sure the correct settings are applied right when the texture is created.
The asset manager supports this kind of configuration, too:

[source, as3]
----
var assets:AssetManager = new AssetManager();
assets.textureFormat = Context3DTextureFormat.BGRA_PACKED;
assets.scaleFactor = 2;
assets.enqueue(EmbeddedAssets);
----

The asset manager will adhere to these settings for all the textures it creates.
However, it seems that this would only allow one set of properties for _all_ the loaded textures, right?
Actually, no: you just need to enqueue them in several steps, assigning the right settings prior to each call to `enqueue`.

[source, as3]
----
assets.scaleFactor = 1;
assets.enqueue(appDir.resolvePath("textures/1x"));

assets.scaleFactor = 2;
assets.enqueue(appDir.resolvePath("textures/2x"));
----

This will make the textures from the `1x` and `2x` folders use scale factors of one and two, respectively.

=== Loading the Assets

Now that the assets are enqueued, you can load all of them at once.
Depending on the number and size of assets your are loading, this can take a while.
For that reason, it probably makes sense to show some kind of progress bar or loading indicator to your users.

[source, as3]
----
assets.loadQueue(function(ratio:Number):void
{
    trace("Loading assets, progress:", ratio);

    // when the ratio equals '1', we are finished.
    if (ratio == 1.0)
        startGame();
});
----

Note that the `startGame` method is something you have to implement yourself; that's where you could hide the loading screen and start the actual game.

With an enabled `verbose` property, you'll see the names with which the assets can be accessed:

----
[AssetManager] Adding sound 'explosion'
[AssetManager] Adding texture 'bird'
[AssetManager] Adding texture 'atlas'
[AssetManager] Adding texture atlas 'atlas'
[AssetManager] Removing texture 'atlas'
----

[NOTE]
====
Did you notice?
In the last line, right after creating the texture atlas, the `atlas` texture is actually removed.
Why is that?

Once the atlas is created, you are no longer interested in the atlas-texture, only in the subtextures it contains.
Thus, the actual atlas-texture is removed, freeing up the slot for another texture.
The same happens for bitmap fonts.
====

=== Accessing the Assets

Finally: now that the queue finished processing, you can access your assets with the various `get...` methods of the AssetManager.
Each asset is referenced by a name, which is the file name of the asset (without extension) or the class name of embedded objects.

[source, as3]
----
var texture:Texture = assets.getTexture("bird"); // <1>
var textures:Vector.<Texture> = assets.getTextures("animation"); // <2>
var explosion:SoundChannel = assets.playSound("explosion"); // <3>
----
<1> This will first search named textures, then atlases.
<2> Same as above, but returns all (sub) textures starting with the given String.
<3> Plays a sound and returns the _SoundChannel_ that controls it.

If you enqueued a bitmap font along the way, it will already be registered and ready to use.

[TIP]
====
In my games, I typically store a reference to the asset manager at my root class, accessible through a `static` property.
That makes it super easy to access my assets from anywhere in the game, simply by calling `Game.assets.get...()` (assuming the root class is called `Game`).
====

// TODO: Restoring the Assets

