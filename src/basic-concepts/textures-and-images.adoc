== テクスチャとイメージ

すでにイメージとテクスチャのクラスについては何回か目にしています。そしてそれらは Starling の中で最も便利なクラスのうちの２つです。
しかしそのように使われるのでしょうか。そして両者の違いはなんでしょう？

=== テクスチャ

テクスチャは画像を表すデータでしかありません。デジタルカメラに保存されたファイルのようなものです。
他の人にファイルとして見せる事はないでしょう。0と1のデータの集まりでしかないのですから。
//原文：it's all zeros and ones, after all.
イメージビューアで閲覧するか、プリンターへファイルを送る必要があります。

テクスチャは直接 GPUのメモリに格納されます。これは、レンダリング時にとても効率的にアクセスされる事を意味します。
テクスチャは埋め込みクラスからでも動的にロードされたファイルからでも作製する事ができます。ファイルフォーマットは以下の中から選択可能です。

PNG:: もっとも色々な目的で使われるフォーマットです。劣化しない圧縮方法は、単色で広い領域の塗りがある画像に最適です。デフォルトのフォーマットとして推奨します。

JPG:: 非可逆圧縮であるため、写真、または写真のような画像では PNG よりも小さなファイルサイズとなります。しかし、 アルファチャンネルの情報を持たないため、使いにくい面もあります。大きな背景や写真を扱う場合におすすめです。

ATF:: 特に Stage3D 用に開発されたフォーマットです。メモリをあまり必要とせず、またロードも速く行われます。しかし、見た目が劣化するため、全ての画像に向いているとは言えません。
この後のチャプターで ATF テクスチャについては取り扱います。( <<ATF Textures>> を参照。)

`starling.textures.Texture` クラスには、テクスチャをインスタンス化するためのたくさんのファクトリーメソッドが存在します。
いくつかを羅列します。（引数は、わかりやすくするために省いています。）

[source, as3]
----
public class Texture
{
    static function fromColor():Texture;
    static function fromBitmap():Texture;
    static function fromBitmapData():Texture;
    static function fromEmbeddedAsset():Texture;
    static function fromCamera():Texture;
    static function fromNetStream():Texture;
    static function fromTexture():Texture;
}
----

おそらく最も一般的な処理はビットマップからテクスチャを作成する事でしょう。
とても簡単です。

[source, as3]
----
var bitmap:Bitmap = getBitmap();
var texture:Texture = Texture.fromBitmap(bitmap);
----

埋め込みビットマップからテクスチャを生成する事も同じように一般的です。
同じように対応できます。

[source, as3]
----
[Embed(source="mushroom.png")] // <1>
public static const Mushroom:Class;

var bitmap:Bitmap = new Mushroom(); // <2>
var texture:Texture = Texture.fromBitmap(bitmap); // <3>
----
<1> ビットマップの埋め込み。
<2> ビットマップをインスタンス化する。
<3> ビットマップからテクスチャを生成する。

しかし、もっと簡潔に処理を行う方法があります。

[source, as3]
----
[Embed(source="mushroom.png")] // <1>
public static const Mushroom:Class;

var texture:Texture = Texture.fromEmbeddedAsset(Mushroom); // <2>
----
<1> ビットマップの埋め込み。
<2> 埋め込まれた画像のクラス定義からテクスチャを生成します。

[IMPORTANT]
.プロのテクニック
====
このように処理するとコード量が少ないだけでなく、メモリ消費量も少ないのです！

`fromEmbeddedAsset` メソッドは裏側でうまく働き、コンテキストロスを防ぎます。また、`fromBitmap` メソッドが行うよりも、もっと効率的に働きます。
後ほどこのトピックについて触れますが、今のところは埋め込まれたビットマップからテクスチャを生成するにはこの方法が推奨される事を覚えておきましょう。
====

_Texture_ クラスのまた別の機能に、目立ちませんが `fromTexture` というメソッドがあります。
//原文：Another feature of the _Texture_ class is hidden in the inconspicuous `fromTexture` method.
これは、テクスチャ内の一部の領域からまた別のテクスチャを生成する物です。

この方法の素晴らしい部分は、ピクセルのコピーが行われないという事実です。
代わりに、作成された _SubTexture_ は、元々のテクスチャへの参照を持ちます。
これは、とても効果的なのです。

[source, as3]
----
var texture:Texture = getTexture();
var subTexture:Texture = Texture.fromTexture(
        texture, new Rectangle(10, 10, 41, 47));
----

この後すぐ _TextureAtlas_ クラスについて知る事になります。基本的に、この機能のために上記の仕組みはあるのです。

=== Image

いくつかテクスチャについて触れましたが、それを画面上に配置する方法をまだ知りません。
最も簡単な方法は Image クラスか、その仲間を利用する事です。

その仲間について詳しく見てみましょう。

[plantuml, mesh-classes]
....
include::../defaults.plantuml[]

Mesh <|-- Quad
Quad <|-- Image
Image <|-- MovieClip
....

* _Mesh_ は、三角ポリゴンの集合です。（GPU が三角形しか描画できない事に留意しましょう。）
* _Quad_ は、矩形を構成する少なくとも２つの三角ポリゴンの集合です。
* _Image_ は、Quad に便利なコンストラクタといくつかのメソッドを追加したものです。
* _MovieClip_ は、時間の経過に連れて内容を切り替える Image です。

これら全てのクラスはテクスチャを扱いますが、おそらく _Image_ クラスを最も頻繁に使う事になるでしょう。
なぜならば、矩形のテクスチャは最も一般的で、それを扱うのに最も便利なのが Image クラスだからです。

_Quad_ と _Image_ を比較してみましょう。
//原文：To demonstrate, let me show you how to display a texture with a _Quad_ vs. an _Image_.

[source, as3]
----
var texture:Texture = Texture.fromBitmap(...);

var quad:Quad = new Quad(texture.width, texture.height); // <1>
quad.texture = texture;
addChild(quad);

var image:Image = new Image(texture); // <2>
addChild(image);
----
<1> quad を適切なサイズで生成し、テクスチャを紐づけます。または、
<2> image を標準的なコンストラクタで生成します。

個人的には、キーを打つ回数が少ない方をいつも選択します。
内部で処理される内容は２つのクラスで全く同じです。

.テクスチャが quad に適用された様子。
image::texture-mapping.png[Texture-Mapping]

=== １つのテクスチャをたくさんの Image に適用する

重要な事ですが、テクスチャはいくつもの image  (mesh) に適用する事ができます。
実際、それは行うべき事です。テクスチャは１度だけロードして、アプリケーションが動いている間は再利用しましょう。

[source, as3]
----
// このようにしてはいけません！
var image1:Image = new Image(Texture.fromEmbeddedAsset(Mushroom));
var image2:Image = new Image(Texture.fromEmbeddedAsset(Mushroom));
var image3:Image = new Image(Texture.fromEmbeddedAsset(Mushroom));

// 代わりに一度だけテクスチャを生成して参照を保持しましょう。
var texture:Texture = Texture.fromEmbeddedAsset(Mushroom));
var image1:Image = new Image(texture);
var image2:Image = new Image(texture);
var image3:Image = new Image(texture);
----

メモリ使用量のほとんどはテクスチャが占める事でしょう。テクスチャメモリを浪費するとすぐに全体のメモリも足りなくなってしまうでしょう。

=== テクスチャアトラス

今までの全てのサンプルでは、それぞれテクスチャを個別にロードしました。
しかし、実際のアプリケーションでは、そのようにすべきではないでしょう。
以下が理由です。

* GPU のレンダリングを効率的に行うため、Staring は、メッシュをバッチ処理でまとめて処理します。しかし、バッチ処理はテクスチャが切り替わると分断します。
* いくつかのシチュエーションでは、_Stage3D_ はテクスチャの縦横の大きさが２の倍数のサイズである事（power-of-two）を要求します。Staring は、この制限をうまく隠蔽しますが、サイズのルールに則っていない場合、余計にメモリを消費します。

テクスチャアトラスを使えば、テクスチャの切り替えと、power-of-two の制限を回避する事ができます。
全てのテクスチャを１つの大きなメインテクスチャに収め、Starling がそこから正しい領域が描画されるように取り扱います。

.テクスチャアトラスの例。
image::penguflip-atlas.png[Texture Atlas]

このテクニックは、_Stage3D_ に小さなテクスチャでなく大きなテクスチャを扱わせ、それぞれの quad にその大きなテクスチャの一部分を割り当てて描画させる物です。
これにより、大きくメモリ消費量を抑える事ができ、できる限り無駄がない状態とします。
（他のフレームワークはこの機能を _Sprite Sheets_ と呼びます。）

ifdef::backend-html5[]
TIP: "Texture Packer" の開発チームが、スプライトシートについての良い紹介動画を作成しています。
ここで視聴する事ができます。 http://www.codeandweb.com/what-is-a-sprite-sheet[What is a Sprite Sheet?]
endif::[]

==== アトラスの作成

_SubTexture_ の位置は下記のような XML ファイルで定義されます。

[source, xml]
----
<TextureAtlas imagePath="atlas.png">
 <SubTexture name="moon" x="0" y="0" width="30" height="30"/>;
 <SubTexture name="jupiter" x="30" y="0" width="65" height="78"/>;
 ...
</TextureAtlas>;
----

このように、XML は一つの大きなテクスチャを参照し、複数の _SubTextures_ を設定します。それらはメインテクスチャの一部領域を指定します。
ランタイムでは、_SubTextures_ をその名前で参照する事が可能で、まるで１つの独立したテクスチャであるように扱う事ができます。

しかし、どのようにしてそれぞれのテクスチャをアトラスとしてまとめる事が可能なのでしょう？
幸い手作業で行う必要はありません。これを行うためのいくつものツールが存在します。
２つの候補を紹介しますが、Google で検索すればさらにたくさんの候補が見つかるでしょう。

* https://www.codeandweb.com/texturepacker/starling?source=gamua[TexturePacker] は、個人的に気に入っているツールです。これほどスプライトシートを調整する事ができるツールは他に見つからないでしょう。このツールは Starling のサポートもしており、とても素晴らしい物です。( ATF テクスチャを書き出せるツールが他にあるでしょうか？）
* http://renderhjs.net/shoebox/[Shoebox] _AIR_ で作られた無料のツールです。アトラスの生成について _TexturePacker_ ほどのたくさんの機能を持ってはいませんが、関連機能がたくさんあります。例えば、ビットマップフォントの作成機能や、スプライトの抽出機能があります。

==== アトラスの利用

さて、テクスチャアトラスファイルを手に入れる事はできました。
では、どのように使えばいいでしょう？
それでは、テクスチャと XMLデータを埋め込んでみましょう。

[source, as3]
----
[Embed(source="atlas.xml", mimeType="application/octet-stream")] // <1>
public static const AtlasXml:Class;

[Embed(source="atlas.png")] // <2>
public static const AtlasTexture:Class;
----
<1> アトラスの XML を埋め込みます。_mimeType_ の設定を忘れないようにしましょう。
<2> アトラスのテクスチャを埋め込みます。

NOTE: 代わりにそれぞれのファイルを URLまたは、AIR としてアプリケーションが動いているのであればディスクから、ロードする事もできます。この事については、_AssetManager_ についての説明の際に扱います。

この２つのオブジェクトが利用できれば、_TextureAtlas_ インスタンスを生成する事ができ、`getTexture()` メソッドを通して全ての _SubTextures_ にアクセスする事ができます。
ゲームの初期化時に一度アトラスを生成しておけば、その後はいつでも参照する事ができます。

[source, as3]
----
var texture:Texture = Texture.fromEmbeddedAsset(AtlasTexture); // <1>
var xml:XML = XML(new AtlasXml());
var atlas:TextureAtlas = new TextureAtlas(texture, xml);

var moonTexture:Texture = atlas.getTexture("moon"); // <2>
var moonImage:Image = new Image(moonTexture);
----
<1> アトラスを生成する。
<2> _SubTexture_　を表示する。

簡単ですよね。
//原文：It's as simple as that!

=== レンダーテクスチャー

_RenderTexture_ クラスを使うと、動的なテクスチャー生成が可能となります。
どんなディスプレイオブジェクトも描画できるキャンバスを思い浮かべてみてください。

After creating a render texture, 
レンダーテクスチャを作成した後は、`drawObject` メソッドを呼び出してテクスチャにオブジェクトを描画しましょう。
テクスチャ上にそのオブジェクトが現在の位置で描かれ、回転・拡大・アルファなどもそのまま適用されます。

[source, as3]
----
var renderTexture:RenderTexture = new RenderTexture(512, 512); // <1>

var brush:Sprite = getBrush(); // <2>
brush.x = 40;
brush.y = 120;
brush.rotation = 1.41;

renderTexture.draw(brush); // <3>
----
<1> 新規に _RenderTexture_ をサイズを指定（単位はポイント）して作成します。初期値は完全に透明な状態です。
<2> このサンプルでは、筆で描画したような素材を描画するオブジェクトとして使います。適切な位置と回転角度を設定します。
<3> オブジェクトがテクスチャ上にその位置と回転角度で描画されます。

描画はとても効率的に行われます。
テクスチャにオブジェクトを描画した後は、描画負荷的に通常のテクスチャと変わりません。どれだけのオブジェクトを描画したとしてもです。

[source, as3]
----
var image:Image = new Image(renderTexture);
addChild(image); // <1>
----
<1> テクスチャは通常のものと同じように扱えます。

If you draw lots of objects at once, it is recommended to bundle the drawing calls in a block via the `drawBundled` method, as shown below.
This allows Starling to skip a few rather costly operations, speeding up the process immensely.

[source, as3]
----
renderTexture.drawBundled(function():void // <1>
{
    for (var i:int=0; i<numDrawings; ++i)
    {
        image.rotation = (2 * Math.PI / numDrawings) * i;
        renderTexture.draw(image); // <2>
    }
});
----
<1> Activate bundled drawing by encapsulating all draw-calls in a function.
<2> Inside the function, call `draw` just like before.

To erase parts of a render texture, you can use any display object like a "rubber" by setting its blend mode to BlendMode.ERASE.

[source, as3]
----
brush.blendMode = BlendMode.ERASE;
renderTexture.draw(brush);
----

To wipe it completely clean, use the `clear` method.

[CAUTION]
.コンテキスト ロス
====
レンダーテクスチャには大きな欠点があります。それは、レンダーコンテキストが失われた際、レンダーテクスチャの内容が全てなくなってしまうという事です。
<<コンテキスト ロス>> は、この後のチャプターで詳しく取り扱います。一言で言えば、_Stage3D_ はいくつかのシチュエーションで全てにコンテンツを失う事があるという事です。
（聞こえての通り、とても嫌な感じです。）
//原文：(Yes, that is as nasty as it sounds.)

従って、テクスチャの内容をなくしてはならないほど重要であれば（例えば、単なる装飾目的でないのなら）、いくつかの調整を行う必要があります。
これの回避方法についても後のチャプターで取り扱います。
//原文：We will look into possible strategies in the mentioned chapter
急にこの事態に遭遇して驚かないようにお知らせしておきました。
//原文： -- I just wanted to mention this fact here so it doesn't hit you by surprise.
====

// TODO: Mipmaps
// TODO: Image color
