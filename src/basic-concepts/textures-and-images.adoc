== テクスチャとイメージ

すでにイメージとテクスチャのクラスについては何回か目にしています。そしてそれらは Starling の中で最も便利なクラスのうちの２つです。
しかしそのように使われるのでしょうか。そして両者の違いはなんでしょう？

=== テクスチャ

テクスチャは画像を表すデータでしかありません。デジタルカメラに保存されたファイルのようなものです。
他の人にファイルとして見せる事はないでしょう。0と1のデータの集まりでしかないのですから。
//原文：it's all zeros and ones, after all.
イメージビューアで閲覧するか、プリンターへファイルを送る必要があります。

テクスチャは直接 GPUのメモリに格納されます。これは、レンダリング時にとても効率的にアクセスされる事を意味します。
テクスチャは埋め込みクラスからでも動的にロードされたファイルからでも作製する事ができます。ファイルフォーマットは以下の中から選択可能です。

PNG:: もっとも色々な目的で使われるフォーマットです。劣化しない圧縮方法は、単色で広い領域の塗りがある画像に最適です。デフォルトのフォーマットとして推奨します。

JPG:: 非可逆圧縮であるため、写真、または写真のような画像では PNG よりも小さなファイルサイズとなります。しかし、 アルファチャンネルの情報を持たないため、使いにくい面もあります。大きな背景や写真を扱う場合におすすめです。

ATF:: 特に Stage3D 用に開発されたフォーマットです。メモリをあまり必要とせず、またロードも速く行われます。しかし、見た目が劣化するため、全ての画像に向いているとは言えません。
この後のチャプターで ATF テクスチャについては取り扱います。( <<ATF Textures>> を参照。)

`starling.textures.Texture` クラスには、テクスチャをインスタンス化するためのたくさんのファクトリーメソッドが存在します。
いくつかを羅列します。（引数は、わかりやすくするために省いています。）

[source, as3]
----
public class Texture
{
    static function fromColor():Texture;
    static function fromBitmap():Texture;
    static function fromBitmapData():Texture;
    static function fromEmbeddedAsset():Texture;
    static function fromCamera():Texture;
    static function fromNetStream():Texture;
    static function fromTexture():Texture;
}
----

おそらく最も一般的な処理はビットマップからテクスチャを作成する事でしょう。
とても簡単です。

[source, as3]
----
var bitmap:Bitmap = getBitmap();
var texture:Texture = Texture.fromBitmap(bitmap);
----

埋め込みビットマップからテクスチャを生成する事も同じように一般的です。
同じように対応できます。

[source, as3]
----
[Embed(source="mushroom.png")] // <1>
public static const Mushroom:Class;

var bitmap:Bitmap = new Mushroom(); // <2>
var texture:Texture = Texture.fromBitmap(bitmap); // <3>
----
<1> ビットマップの埋め込み。
<2> ビットマップをインスタンス化する。
<3> ビットマップからテクスチャを生成する。

しかし、もっと簡潔に処理を行う方法があります。

[source, as3]
----
[Embed(source="mushroom.png")] // <1>
public static const Mushroom:Class;

var texture:Texture = Texture.fromEmbeddedAsset(Mushroom); // <2>
----
<1> ビットマップの埋め込み。
<2> 埋め込まれた画像のクラス定義からテクスチャを生成します。

[IMPORTANT]
.プロのテクニック
====
このように処理するとコード量が少ないだけでなく、メモリ消費量も少ないのです！

`fromEmbeddedAsset` メソッドは裏側でうまく働き、コンテキストロスを防ぎます。また、`fromBitmap` メソッドが行うよりも、もっと効率的に働きます。
後ほどこのトピックについて触れますが、今のところは埋め込まれたビットマップからテクスチャを生成するにはこの方法が推奨される事を覚えておきましょう。
====

_Texture_ クラスのまた別の機能に、目立ちませんが `fromTexture` というメソッドがあります。
//原文：Another feature of the _Texture_ class is hidden in the inconspicuous `fromTexture` method.
これは、テクスチャ内の一部の領域からまた別のテクスチャを生成する物です。

この方法の素晴らしい部分は、ピクセルのコピーが行われないという事実です。
代わりに、作成された _SubTexture_ は、元々のテクスチャへの参照を持ちます。
これは、とても効果的なのです。

[source, as3]
----
var texture:Texture = getTexture();
var subTexture:Texture = Texture.fromTexture(
        texture, new Rectangle(10, 10, 41, 47));
----

この後すぐ _TextureAtlas_ クラスについて知る事になります。基本的に、この機能のために上記の仕組みはあるのです。

=== Image

いくつかテクスチャについて触れましたが、それを画面上に配置する方法をまだ知りません。
最も簡単な方法は Image クラスか、その仲間を利用する事です。

その仲間について詳しく見てみましょう。

[plantuml, mesh-classes]
....
include::../defaults.plantuml[]

Mesh <|-- Quad
Quad <|-- Image
Image <|-- MovieClip
....

* _Mesh_ は、三角ポリゴンの集合です。（GPU が三角形しか描画できない事に留意しましょう。）
* _Quad_ は、矩形を構成する少なくとも２つの三角ポリゴンの集合です。
* _Image_ は、Quad に便利なコンストラクタといくつかのメソッドを追加したものです。
* _MovieClip_ は、時間の経過に連れて内容を切り替える Image です。

これら全てのクラスはテクスチャを扱いますが、おそらく _Image_ クラスを最も頻繁に使う事になるでしょう。
なぜならば、矩形のテクスチャは最も一般的で、それを扱うのに最も便利なのが Image クラスだからです。

_Quad_ と _Image_ を比較してみましょう。
//原文：To demonstrate, let me show you how to display a texture with a _Quad_ vs. an _Image_.

[source, as3]
----
var texture:Texture = Texture.fromBitmap(...);

var quad:Quad = new Quad(texture.width, texture.height); // <1>
quad.texture = texture;
addChild(quad);

var image:Image = new Image(texture); // <2>
addChild(image);
----
<1> quad を適切なサイズで生成し、テクスチャを紐づけます。または、
<2> image を標準的なコンストラクタで生成します。

個人的には、キーを打つ回数が少ない方をいつも選択します。
内部で処理される内容は２つのクラスで全く同じです。

.テクスチャが quad に適用された様子。
image::texture-mapping.png[Texture-Mapping]

=== １つのテクスチャをたくさんの Image に適用する

重要な事ですが、テクスチャはいくつもの image  (mesh) に適用する事ができます。
実際、それは行うべき事です。テクスチャは１度だけロードして、アプリケーションが動いている間は再利用しましょう。

[source, as3]
----
// このようにしてはいけません！
var image1:Image = new Image(Texture.fromEmbeddedAsset(Mushroom));
var image2:Image = new Image(Texture.fromEmbeddedAsset(Mushroom));
var image3:Image = new Image(Texture.fromEmbeddedAsset(Mushroom));

// 代わりに一度だけテクスチャを生成して参照を保持しましょう。
var texture:Texture = Texture.fromEmbeddedAsset(Mushroom));
var image1:Image = new Image(texture);
var image2:Image = new Image(texture);
var image3:Image = new Image(texture);
----

メモリ使用量のほとんどはテクスチャが占める事でしょう。テクスチャメモリを浪費するとすぐに全体のメモリも足りなくなってしまうでしょう。

=== テクスチャアトラス

今までの全てのサンプルでは、それぞれテクスチャを個別にロードしました。
しかし、実際のアプリケーションでは、そのようにすべきではないでしょう。
以下が理由です。

* GPU のレンダリングを効率的に行うため、Staring は、メッシュをバッチ処理でまとめて処理します。しかし、バッチ処理はテクスチャが切り替わると分断します。
* いくつかのシチュエーションでは、_Stage3D_ はテクスチャの縦横の大きさが２の倍数のサイズである事（power-of-two）を要求します。Staring は、この制限をうまく隠蔽しますが、サイズのルールに則っていない場合、余計にメモリを消費します。

テクスチャアトラスを使えば、テクスチャの切り替えと、power-of-two の制限を回避する事ができます。
全てのテクスチャを１つの大きなメインテクスチャに収め、Starling がそこから正しい領域が描画されるように取り扱います。

.テクスチャアトラスの例。
image::penguflip-atlas.png[Texture Atlas]

このテクニックは、_Stage3D_ に小さなテクスチャでなく大きなテクスチャを扱わせ、それぞれの quad にその大きなテクスチャの一部分を割り当てて描画させる物です。
これにより、大きくメモリ消費量を抑える事ができ、できる限り無駄がない状態とします。
（他のフレームワークはこの機能を _Sprite Sheets_ と呼びます。）

ifdef::backend-html5[]
TIP: "Texture Packer" の開発チームが、スプライトシートについての良い紹介動画を作成しています。
ここで視聴する事ができます。 http://www.codeandweb.com/what-is-a-sprite-sheet[What is a Sprite Sheet?]
endif::[]

==== アトラスの作成

_SubTexture_ の位置は下記のような XML ファイルで定義されます。

[source, xml]
----
<TextureAtlas imagePath="atlas.png">
 <SubTexture name="moon" x="0" y="0" width="30" height="30"/>;
 <SubTexture name="jupiter" x="30" y="0" width="65" height="78"/>;
 ...
</TextureAtlas>;
----

このように、XML は一つの大きなテクスチャを参照し、複数の _SubTextures_ を設定します。それらはメインテクスチャの一部領域を指定します。
ランタイムでは、_SubTextures_ をその名前で参照する事が可能で、まるで１つの独立したテクスチャであるように扱う事ができます。

しかし、どのようにしてそれぞれのテクスチャをアトラスとしてまとめる事が可能なのでしょう？
幸い手作業で行う必要はありません。これを行うためのいくつものツールが存在します。
２つの候補を紹介しますが、Google で検索すればさらにたくさんの候補が見つかるでしょう。

* https://www.codeandweb.com/texturepacker/starling?source=gamua[TexturePacker] は、個人的に気に入っているツールです。これほどスプライトシートを調整する事ができるツールは他に見つからないでしょう。このツールは Starling のサポートもしており、とても素晴らしい物です。( ATF テクスチャを書き出せるツールが他にあるでしょうか？）
* http://renderhjs.net/shoebox/[Shoebox] _AIR_ で作られた無料のツールです。アトラスの生成について _TexturePacker_ ほどのたくさんの機能を持ってはいませんが、関連機能がたくさんあります。例えば、ビットマップフォントの作成機能や、スプライトの抽出機能があります。

==== Using the Atlas

Okay: you've got a texture atlas now.
But how do you use it?
Let's start with embedding the texture and XML data.

[source, as3]
----
[Embed(source="atlas.xml", mimeType="application/octet-stream")] // <1>
public static const AtlasXml:Class;

[Embed(source="atlas.png")] // <2>
public static const AtlasTexture:Class;
----
<1> Embed the atlas XML. Don't forget to specify the _mimeType_.
<2> Embed the atlas texture.

NOTE: Alternatively, you can also load these files from an URL or from the disk (if we are talking about _AIR_).
We will look at that in detail when we discuss Starling's _AssetManager_.

With those two objects available, we can create a new _TextureAtlas_ instance and access all _SubTextures_ through the method `getTexture()`.
Create the atlas object once when the game is initialized and reference it throughout its lifetime.

[source, as3]
----
var texture:Texture = Texture.fromEmbeddedAsset(AtlasTexture); // <1>
var xml:XML = XML(new AtlasXml());
var atlas:TextureAtlas = new TextureAtlas(texture, xml);

var moonTexture:Texture = atlas.getTexture("moon"); // <2>
var moonImage:Image = new Image(moonTexture);
----
<1> Create the atlas.
<2> Display a _SubTexture_.

It's as simple as that!

=== Render Textures

The _RenderTexture_ class allows creating textures dynamically.
Think of it as a canvas on which you can paint any display object.

After creating a render texture, just call the `drawObject` method to render an object directly onto the texture.
The object will be drawn onto the texture at its current position, adhering its current rotation, scale and alpha properties.

[source, as3]
----
var renderTexture:RenderTexture = new RenderTexture(512, 512); // <1>

var brush:Sprite = getBrush(); // <2>
brush.x = 40;
brush.y = 120;
brush.rotation = 1.41;

renderTexture.draw(brush); // <3>
----
<1> Create a new _RenderTexture_ with the given size (in points). It will be initialized with fully transparent pixels.
<2> In this sample, we're referencing a display object depicting a brush. We move it to a certain location.
<3> The brush object will be drawn to the texture with its current position and orientation settings.

Drawing is done very efficiently, as it is happening directly in graphics memory.
After you have drawn objects onto the texture, the performance will be just like that of a normal texture -- no matter how many objects you have drawn.

[source, as3]
----
var image:Image = new Image(renderTexture);
addChild(image); // <1>
----
<1> The texture can be used like any other texture.

If you draw lots of objects at once, it is recommended to bundle the drawing calls in a block via the `drawBundled` method, as shown below.
This allows Starling to skip a few rather costly operations, speeding up the process immensely.

[source, as3]
----
renderTexture.drawBundled(function():void // <1>
{
    for (var i:int=0; i<numDrawings; ++i)
    {
        image.rotation = (2 * Math.PI / numDrawings) * i;
        renderTexture.draw(image); // <2>
    }
});
----
<1> Activate bundled drawing by encapsulating all draw-calls in a function.
<2> Inside the function, call `draw` just like before.

To erase parts of a render texture, you can use any display object like a "rubber" by setting its blend mode to BlendMode.ERASE.

[source, as3]
----
brush.blendMode = BlendMode.ERASE;
renderTexture.draw(brush);
----

To wipe it completely clean, use the `clear` method.

[CAUTION]
.Context Loss
====
Unfortunately, render textures have one big disadvantage: they lose all their contents when the render context is lost.
<<Context Loss>> is discussed in detail in a later chapter; in a nutshell, it means that _Stage3D_ may lose the contents of all its buffers in certain situations.
(Yes, that is as nasty as it sounds.)

Thus, if it is really important that the texture's contents is persistent (i.e. it's not just eye candy), you will need to make some arrangements.
We will look into possible strategies in the mentioned chapter -- I just wanted to mention this fact here so it doesn't hit you by surprise.
====

// TODO: Mipmaps
// TODO: Image color
