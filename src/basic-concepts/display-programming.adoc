== 表示に関するプログラミング
//原文:Display Programming
ifndef::imagesdir[:imagesdir: ../../img]

すべての準備が整ったので、画面上に何か表示してみましょう。
//原文：we can start to actually put some content onto the screen!

どんなアプリケーションを作成する際でも、メインのタスクはアプリケーションをたくさんのユニットに分割する事になるでしょう。
//原文：In every application you create one of your main tasks will be to split it up into a number of logical units.
大抵の場合、それらのユニットは見た目を持ちます。
つまり、それぞれのユニットは _ディスプレイオブジェクト_ になる事が多い、と言えます。

=== ディスプレイオブジェクト

画面上に表示されている構成要素は全てがディスプレイオブジェクトです。
`starling.display` パッケージには _DisplayObject_ という抽象クラスが存在します。
このクラスはたくさんの種類のディスプレイオブジェクトに対して基本的な機能を提供します。
いくつか具体的にあげるとイメージ、ムービークリップ、テキストフィールドなどです。

_DisplayObject_ クラスはすべてのディスプレイオブジェクトが保持するメソッドとプロパティを提供します。
例えば、下記のプロパティは画面上のオブジェクトの位置を調整するものです。

* `x`, `y`: 現在の座標系での位置を表します。
* `width`, `height`: オブジェクトの大きさです。 (単位はポイント)
* `scaleX`, `scaleY`: オブジェクトの大きさを表す別の方法です。`1.0` は変化なし、`2.0` は倍の大きさである、など。
* `rotation`: 元々の位置からの回転角度です。(単位はラジアン).
* `skewX`, `skewY`: 水平及び垂直方向への skew(傾き) 値です。 (単位はラジアン).

その他のプロパティは、画面上のピクセル表示を変更します。

* `blendMode`: ピクセルが背面の描画内容とどのようにブレンドされるかを設定します。
* `filter`: 特別な GPU プログラム（シェーダー）でオブジェクトの見た目を装飾します。例えば、ぼけや影の効果を与えることなどが可能です。
* `mask`: ある設定されたエリア外の表示をカットします。
* `alpha`: オブジェクトの透明度です。`0` (非表示)から` 1`（完全に不透明) までの値をとります。
* `visible`: 値が false の場合、完全にオブジェクトの表示が隠れます。

これらはどのディスプレイオブジェクトもサポートしなくてはならない基本機能となります。
この周辺の Starling's API クラス継承図を見てみましょう。

[plantuml, class-hierarchy]
....
include::../defaults.plantuml[]

abstract class DisplayObject
abstract class DisplayObjectContainer

DisplayObject <|-- Mesh
DisplayObject <|-- DisplayObjectContainer
DisplayObjectContainer <|-- Stage
DisplayObjectContainer <|-- Sprite
DisplayObjectContainer <|-- Button
DisplayObjectContainer <|-- TextField
Mesh <|-- Quad
Quad <|-- Image
Image <|-- MovieClip
....

ツリーが主に大きく２つに枝分かれしている事に気づいたでしょうか。
片方のツリーでは、`Mesh` を継承した `Quad`、`Image`、`MovieClip` などが並びます。

Meshes は、Starling のレンダリングのアーキテクチャーの基本的な部分です。
実際、画面上に描画された全てはメッシュなのです！
_Stage3D_ は三角ポリゴン以外を画面に描画できないのです。そして、メッシュは三角ポリゴンを作り出すためのポイント(点)の集まり以外の何物でもありません。

一方で、_DisplayObjectContainer_ を継承したいくつかのクラスにも気づいたでしょうか。
文字通り、このクラスは他のディスプレイオブジェクトのコンテナーとして振舞います。
このクラスにより、ディスプレイオブジェクトをまとめて管理する事ができるようになる、"ディスプレイリスト" というシステムを作り出すのです。

=== ディスプレイリスト

描画されるディスプレイオブジェクトのヒエラルキー構造を _display list_ と呼びます。
_Stage_ はディスプレイリストのルートです。

文字通りそれを"ステージ"だと考えてみましょう。ユーザー（観客）はステージに登場したオブジェクト（俳優）だけを見る事ができます。
Starling を開始した時、自動的にステージが作成されます。
ステージに関連した全て（それが直接であれ間接であれ）が描画されます。

"関連した" と言いましたが、これは親子関係がある、という意味です。
画面上にオブジェクトを表示させるには、ステージの子とするとか、ステージに関連する _DisplayObjectContainer_ の子とする必要があります。

.ディスプレイオブジェクトがディスプレイリストに属しています。
image::display-list.png[Display List, 350]

最初の（そして通常唯一の）ステージの子は _application root_ です。
これは、Starling のコンストラクタに引数として渡したクラスです。
ステージと同じように、これもまた _DisplayObjectContainer_ となります。
大元の継承元であるわけです。
//原文：That's where you take over!

いくつかコンテナ要素を作ることになるでしょうが、またそれはコンテナ要素を子として持つ事ができます。そして image のようなメッシュも子として持つ事ができます。
ディスプレイリストでは、それらのメッシュ要素は葉要素となります。子を持てない要素です。

話が抽象的すぎたかもしれないので、ここで実際の例を見てみましょう。漫画の "ふきだし" を例とします。
ふきだしを作るには、背景となる画像と内容としてテキストが必要となるでしょう。

これら２つのオブジェクトは、一体となって働きます。移動する際は、画像とテキストが一緒に移動するべきです。
サイズの変更、拡大縮小、回転などの際も同じ事が言えます。
これは、とても軽量な _DisplayObjectContainer_ の実装である _Sprite_ に２つのオブジェクトをグルーピングさせる事で実現できます。

[NOTE]
.DisplayObjectContainer と Sprite
====
_DisplayObjectContainer_ と _Sprite_ はほとんど同じように利用されます。
２つのクラスのたった一つの違いは、片方 (_DisplayObjectContainer_) は抽象クラスで、(_Sprite_) がそうではない、という事です。
したがって、他のサブクラスなしで、_Sprite_ によってオブジェクトをグループにまとめる事ができます。
_Sprite_ の別の優位な点、それは、タイピングするのが早いという事です。
概して、私が _Sprite_ を好む主な理由もそれなのです。
他の大抵のプログラマと同じように、私も怠惰な人間なのですから！
====

テキストとイメージをグループ化するために、Sprite を作成して、画像とテキストを子として登録したと思います。

[source, as3]
----
var sprite:Sprite = new Sprite(); // <1>
var image:Image = new Image(texture);
var textField:TextField = new TextField(200, 50, "Ay caramba!");
sprite.addChild(image); // <2>
sprite.addChild(textField); // <3>
----
<1> sprite を作成します。
<2> _Image_ を  sprite に追加します。
<3> _TextField_ を sprite に追加します。

子を追加する順番は重要です。レイヤーのようにお互いの上に配置されていきます。
ここでは、`textField` が `image` の前に配置されます。

.ふきだしは、画像とテキストで構成されます。
image::speech-bubble.png[Speech Bubble, 600]

オブジェクトのグループ化はできたので、１つのオブジェクトとしてスプライトを扱う事ができます。

[source, as3]
----
var numChildren:int = sprite.numChildren; // <1>
var totalWidth:Number = sprite.width; // <2>
sprite.x += 50; // <3>
sprite.rotation = deg2rad(90); // <4>
----
<1> 子の数を取得するとここでは `2` が返ってきます。
<2> `width` と `height` は、子要素の大きさや位置を計算に入れて求められます。
<3> 全てを 50 ポイント右に移動します。
<4> グループを 90度回転します。 (Starling では単位に radian を使います。)

実際、_DisplayObjectContainer_ は子要素を操作するのに役立つたくさんのメソッドを持っています。

[source, as3]
----
function addChild(child:DisplayObject):void;
function addChildAt(child:DisplayObject, index:int):void;
function contains(child:DisplayObject):Boolean;
function getChildAt(index:int):DisplayObject;
function getChildIndex(child:DisplayObject):int;
function removeChild(child:DisplayObject, dispose:Boolean=false):void;
function removeChildAt(index:int, dispose:Boolean=false):void;
function swapChildren(child1:DisplayObject, child2:DisplayObject):void;
function swapChildrenAt(index1:int, index2:int):void;
----

=== 座標系

全てのディスプレイオブジェクトはそれぞれが固有の座標系を持っています。
例えば、`x` と `y` プロパティはスクリーン座標系での値ではありません。それらの値がいくつになるのかはいつでも現在の座標系によります。
そしてその座標系がどのようであるのかは、デイスプレイリストヒエラルキーのどこに現在のポジションがあるのかによります。

これを見た目として理解するには、コルクボードにペーパーシートをピン留する事を想像するといいでしょう。
どのシートも水平のX座標と垂直のY座標をもつ座標系を表します。
ピンが貫通して突き刺している場所が座標系の中心となります。

.座標系はコルクボード状のシートのように振る舞います。
image::coordinate-systems.png[Coordinage Systems]

シートを回転した際は、そのシート上に書かれた全ての内容（イメージやテキスト）も一緒に回転します。X座標とY座標も同様に回転します。
しかし、座標系の中心は元の場所をキープしたままです。

よって、ピンのポジションはシートのX座標及びY座標の原点が示す、親の座標系（＝コルクボード）での場所を表します。
//原文難しい。。:The position of the pin therefore represents the point the x- and y-coordinates of the sheet are pointing at, 
//relative to the parent coordinate system (= the pin-board).

ディスプレイオブジェクトの階層構造を作成するときは、頭の中にこのコルクボードの比喩を思い起こしましょう。
Starling を扱う際には理解しておかなくてはいけないとても大事なコンセプトです。

=== カスタムディスプレイオブジェクト

すでに述べましたが、アプリケーションを作る際に細かいロジック状のパーツに分ける事を行うかと思います。
簡単なチェスゲームを作る場合、盤とピースとポーズボタンとメッセージボックスが用意されるでしょう。
これらの構成要素は全てが画面上に表示されます。したがって、それぞれが _DisplayObject_ から派生するクラスで表されます。
シンプルなメッセージボックスのサンプルを見てみましょう。

.ゲームのメッセージボックス。
image::msgbox.png[Message Box]

実際メッセージボックスは、ふきだしの例とほとんど同じです。背景画像とテキストに加えて、２つのボタンも保持しています。
今回は、ただスプライトにオブジェクトをグループ化するだけでなく、実装を適切なクラスにカプセル化したく思います。

これをするためには、_DisplayObjectContainer_ を継承した新しいクラスを作成しましょう。
このコンスタラクタの中で、メッセージボックスを構成する全てのパーツを作成してしまいましょう。

[source, as3]
----
public class MessageBox extends DisplayObjectContainer
{
    [Embed(source = "background.png")]
    private static const BackgroundBmp:Class;

    [Embed(source = "button.png")]
    private static const ButtonBmp:Class;

    private var _background:Image;
    private var _textField:TextField;
    private var _yesButton:Button;
    private var _noButton:Button;

    public function MessageBox(text:String)
    {
        var bgTexture:Texture = Texture.fromEmbeddedAsset(BackgroundBmp);
        var buttonTexture:Texture = Texture.fromEmbeddedAsset(ButtonBmp);

        _background = new Image(bgTexture);
        _textField  = new TextField(100, 20, text);
        _yesButton  = new Button(buttonTexture, "yes");
        _noButton   = new Button(buttonTexture, "no");

        _yesButton.x = 10;
        _yesButton.y = 20;
        _noButton.x  = 60;
        _noButton.y  = 20;

        addChild(_background);
        addChild(_textField);
        addChild(_yesButton);
        addChild(_noButton);
    }
}
----

背景画像と２つのボタンとテキストを含むシンプルなクラスが出来上がりました。
これを利用するには、単に _MessageBox_ のインスタンスを作成して、ディスプレイツリーに追加しましょう。

[source, as3]
----
var msgBox:MessageBox = new MessageBox("Really exit?");
addChild(msgBox);
----

追加のメソッドをクラスに追加する事もできます。( 例えば、`fadeIn`、`fadeOut` など。)
そして、ユーザがボタンのうち一つをクリックした際に動作するコードを書く事もできます。
//原文：You can add additional methods to the class (like `fadeIn` and `fadeOut`), and code that is triggered when the user clicks one of those buttons.
これは、Starling のイベントメカニズムを用いて実装する事が可能です。（イベントについてはのちのチャプターで解説します。）

=== ディスプレイオブジェクトの廃棄

もうオブジェクトを表示する必要がなくなった場合、親からそのオブジェクトを取り除きましょう。例えば、`removeFromParent()` を呼び出せば良いです。
オブジェクト自体はまだ存在するので、もし必要なら別のディスプレイオブジェクトの子として追加する事もできます。
しかし、すでにそのオブジェクトが必要なくなっている事も多いでしょう。
//原文：Oftentimes, however, the object has outlived its usefulness.
そうであれば、それを廃棄するのが良い習慣です。

[source, as3]
----
msgBox.removeFromParent();
msgBox.dispose();
----

ディスプレイオブジェクトを廃棄 (dispose) した場合、そのオブジェクト、またはその子孫オブジェクトは、保持していた全てのリソースを廃棄します。
これはとても重要です。なぜなら、多くの _Stage3D_ に関連したデータは、ガベージコレクターの範疇にないものだからです。
もしもデータを破棄しない場合はそれがメモリに居座り続け、アプリケーションは遅かれ早かれリソース不足になりクラッシュしてしまうでしょう。

作業を楽にするため、`removeFromParent()` は任意の Boolean型のパラメータを受け付け、取り除こうとしているデイスプレイオブジェクトを自動で破棄する指定ができるようになっています。
よって、上記のコードは１行にシンプルにまとめる事ができます。

[source, as3]
----
msgBox.removeFromParent(true);
----

=== 中心点

Pivot Points are a feature you won't find in the traditional display list.
In Starling, display objects contain two additional properties: `pivotX` and `pivotY`.
The pivot point of an object (also known as _origin_, _root_ or _anchor_) defines the root of its coordinate system.

Per default, the pivot point is at `(0, 0)`; in an image, that is the top left position.
Most of the time, this is just fine.
Sometimes, however, you want to have it at a different position -- e.g. when you want to rotate an image around its center.

Without a pivot point, you'd have to wrap the object inside a container sprite in order to do that:

[source, as3]
----
var image:Image = new Image(texture);

var sprite:Sprite = new Sprite(); // <1>
image.x = -image.width / 2.0;
image.y = -image.height / 2.0;
sprite.addChild(image); // <2>

sprite.rotation = deg2rad(45); // <3>
----
<1> Create a sprite.
<2> Add an image so that its center is exactly on top of the sprite's origin.
<3> Rotating the sprite will rotate the image around its center.

Most long-time Flash developers will know this trick; it was needed quite regularly.
One might argue, however, that it's a lot of code for such a simple thing.
With the pivot point, the code is reduced to the following:

[source, as3]
----
var image:Image = new Image(texture);
image.pivotX = image.width  / 2.0; // <1>
image.pivotY = image.height / 2.0; // <2>
image.rotation = deg2rad(45); // <3>
----
<1> Move `pivotX` to the horizontal center of the image.
<2> Move `pivotY` to the vertical center of the image.
<3> Rotate around the center.

No more container sprite is needed!
To stick with the analogy used in previous chapters: the pivot point defines the position where you stab the pin through the object when you attach it to its parent.
The code above moves the pivot point to the center of the object.

.Note how moving the pivot point changes how the object rotates.
image::pivot-point.png[Pivot Point]

Now that you have learned how to control the pivot point coordinates individually, let's take a look at the method `alignPivot()`.
It allows us to move the pivot point to the center of the object with just one line of code:

[source, as3]
----
var image:Image = new Image(texture);
image.alignPivot();
image.rotation = deg2rad(45);
----

Handy huh?

Furthermore, if we want the pivot point somewhere else (say, at the bottom right), we can optionally pass alignment arguments to the method:

[source, as3]
----
var image:Image = new Image(texture);
image.alignPivot(Align.RIGHT, Align.BOTTOM);
image.rotation = deg2rad(45);
----

That code rotates the object around the bottom right corner of the image.

==== その他
//原文：==== Gotchas

Be careful: the pivot point is always given in the _local_ coordinate system of the object.
That's unlike the `width` and `height` properties, which are actually relative to the _parent_ coordinate system.
That leads to surprising results when the object is e.g. scaled or rotated.

For example, think of an image that's 100 pixels wide and scaled to 200% (`image.scaleX = 2.0`).
That image will now return a `width` of 200 pixels (twice its original width).
However, to center the pivot point horizontally, you'd still set `pivotX` to `50`, not `100`!
In the _local_ coordinate system, the image is still 100 pixels wide -- it just appears wider in the _parent_ coordinate system.

It might be easier to understand when you look back the code from the beginning of this section, where we centered the image within a parent sprite.
What would happen if you changed the `scale` of the sprite?
Would this mean that you have to update the position of the image to keep it centered?
Of course not.
The scale does not affect what's happening _inside_ the sprite, just how it looks from the _outside_.
And it's just the same with the pivot point property.

TIP: If you still get a headache picturing that (as it happens to me, actually), just remember to set the pivot point _before_ changing the scale or rotation of the object.
That will avoid any problems.
