== フラグメントフィルター

//原文：Up until now, everything we rendered were meshes with (or without) textures mapped onto them.
これまでのところ、描画してきたものは全てがメッシュであり、テクスチャが設定されているものといないものがありました。

このメッシュは位置を変更したり、回転拡大したり、着色することもできます。
//原文：All in all, however, the possibilities are rather limited --
しかし、大雑把にはできることはむしろ少なく、
//原文：the look of the game is solely defined by its textures.
ゲームの見た目はほとんどテクスチャによって決まってしまうのです。

そしてそのうちに、下記のような問題にぶつかるのではないでしょうか。
一つの画像の色々なパターン、ブラー、色違い、影をつける、などが必要となることがあるでしょう。
もし全てのエフェクトがついた全てのパターンをテクスチャアトラスに用意した場合は、
すぐにメモリ不足になってしまいます。

_フラグメント フィルター_ がこれを解決します。
フィルターはどんな種類のディスプレイリストにも設定できます。スプライトなどのコンテナでも問題ありません。
そして劇的に見た目を変えることができます。

例えば、ガウスぼかしをディスプレイオブジェクトに適用したいものとしましょう。

[source, as3]
----
var filter:BlurFilter = new BlurFilter(); // <1>
object.filter = filter; // <2>
----
<1> 適切なフィルターのクラスを作成して必要であれば設定もします。
<2> ディスプレイオブジェクトの `filter` プロパティにそのフィルターを設定します。

フィルタが設定されたディスプレイオブジェクトの描画は下記のように調整されます。

* 全てのフレームで、対象ディスプレイオブジェクトは一度内部処理でテクスチャーに描画されます。
* そのテクスチャは直接 GPU で、フラグメントシェーダーによって処理されます。
* 複数のフィルター設定は複数回の処理を必要とします。つまり１つのシェーダーの結果が次のシェーダーの入力として渡されます。
* 最終的に、最後のシェーダーの出力がバックバッファーに書き込まれます.

.フラグメントフィルターのレンダリングパイプライン。
image::filter-pipeline.png[Filter Pipeline, 700]

この方法はとても順庵で、
//原文：allowing to produce all kinds of different effects (as we will see shortly).
上で簡単に説明した通り、全ての異なる種類のエフェクトを同時に適用することができます。

//原文：Furthermore, it makes great use of the GPU's parallel processing abilities;
さらに、フィルターは、GPU の並列演算処理能力を積極的に利用します。
//原文：all the expensive per-pixel logic is executed right on the graphics chip.
ピクセル単位の演算処理は高くつきますが、その全てがグラフィックチップ上で行われます。

とは言っても、フィルターはバッチ処理を分割しますし、１つのフィルター処理が１ドローコールを必要とします。
//原文：They are not exactly cheap, both regarding memory usage and performance.
メモリ面でもパフォーマンス面でも厳密には低コストではないのです。

なので、うまく注意して使うようにしてください。

=== ショーケース

//原文：Out of the box, ：訳してない
Starling はとても便利なフィルターをいくつか提供します。

==== ブラーフィルタ

ガウスぼかしをオブジェクトに適用します。ぼかし強度はＸ軸Ｙ軸別々に設定できます。

* ブラーごとに少なくとも１ドローコールを必要とします。
* 強度が１つ増えるごとに１ドローコールが必要となります。強度１は１パス、強度２は２パス、が必要です。
* 強度を増加させるのではなくり、フィルター解像度を低くするのが良い方法でしょう。効果的には似た感じになりますが、ずっと低コストです。

.実際に _ブラーフィルター_ を動作させた例。
image::filter-blur.png[BlurFilter, 600]

==== カラーマトリックスフィルター

オブジェクトのカラーを動的に置き換えます。明度、彩度、色相を置き換えたり、完全に色味を反転したりします。

このフィルターは各ピクセルごとに、カラー値とアルファ値を 4x5 マトリックスで行列演算します。
これはとても柔軟なコンセプトですが、演算のための正しい行列値を得るのはとても複雑で難しい作業です。
この理由で、このフィルターのクラスにはいくつかの便利なメソッドが用意されました。
色相や彩度を変えたいなど、適用したいエフェクトを適用するための行列を計算して設定してくれます。

* いくつかのカラー変更効果を１つのフィルターにまとめて設定することができます。
例えば、フィルターのそれぞれに対応するメソッドを使う事で、明度と彩度を同時に変更する事ができます。
* このフィルター処理に必要なドローコール数は１パスです。

.実施に _カラーマトリックスフィルター_ を動作させた例。
image::filter-colormatrix.png[ColorMatrixFilter, 600]

==== DropShadow- and GlowFilter

These two filters draw the original object in the front and add a blurred and tinted variant behind it.

* That also makes them rather expensive, because they add an additional render pass to what's required by a pure _BlurFilter_.

._DropShadow-_ and _GlowFilter_ in action.
image::filter-dropshadow+glow.png[DropShadow and Glow filter, 300]

==== DisplacementMapFilter

Displaces the pixels of the target object depending on the colors in a _map texture_.

* Not exactly easy to use, but very powerful!
* Reflection on water, a magnifying glass, the shock wave of an explosion -- this filter can do it.
ifdef::target-handbook[]
* We will look at the details of this filter in a later chapter.
endif::[]

.The _DisplacementMapFilter_ using a few different maps.
image::filter-displacementmap.png[Other filters, 450]

==== FilterChain

To combine several filters on one display object, you can chain them together via the _FilterChain_ class.
The filters will be processed in the given order; the number of draw calls per filter are simply adding up.

._ColorMatrix-_ and _DropShadowFilter_ chained together.
image::filter-chain.png[FilterChain, 150]

=== Performance Tips

I mentioned it above: while the GPU processing part is very efficient, the additional draw calls make fragment filters rather expensive.
However, Starling does its best to optimize filters.

* When an object does not change its position relative to the stage (or other properties like scale and color) for two successive frames, Starling recognizes this and will automatically cache the filter output.
  This means that the filter won't need to be processed any more; instead, it behaves just like a single image.
* On the other hand, when the object is constantly moving, the last filter pass is always rendered directly to the back buffer instead of a texture.
  That spares one draw call.
* If you want to keep using the filter output even though the object is moving, call `filter.cache()`.
  Again, this will make the object act just like a static image.
  However, for any changes of the target object to show up, you must call `cache` again (or `uncache`).
* To save memory, experiment with the `resolution` and `textureFormat` properties.
  This will reduce image quality, though.

=== More Filters

Would you like to know how to create your own filters?
Don't worry, we will investigate that topic a <<Custom Filters, little later>>.

In the meantime, you can try out filters created by other Starling developers.
An excellent example is the https://github.com/devon-o/Starling-Filters[filter collection] by devon-o.
