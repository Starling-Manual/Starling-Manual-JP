== メッシュ

//原文：_Mesh_ is the basic building block of all tangible display objects.
_Mesh_ は全ての実態を持つディスプレイオブジェクトの基本構成要素です。

//原文：With "tangible", I mean a "leaf" object in the display list: an object that is not a container but is rendered directly to the back buffer.
実態を持つ、と言うのは、ディスプレイリスト内の葉要素であるディスプレイオブジェクトであることを言っています。
つまり、スプライトなどのコンテナではなく、実際に画面に表示される物です。

このクラスはとても重要なので、詳細まで確認してみましょう。

//原文：In a nutshell, a _Mesh_ represents a list of triangles to be rendered via _Stage3D_.
つまり、_Mesh_ は _Stage3D_ を通して描画される三角形の集合を表します。

//原文：It was mentioned a few times already, since it's the base class of _Quad_ and _Image_.
すでに何回か言ったことですが、 _Mesh_ は _Quad_ や _Image_ のベースクラスです。
再度、ここにその継承ツリーを図示します。

[plantuml, mesh-classes-from-display-object]
....
include::../defaults.plantuml[]

DisplayObject <|-- Mesh
Mesh <|-- Quad
Quad <|-- Image
....

_Mesh_ は抽象的なクラスではありません。実際にインスタンス化する事が可能です。このようにします。

[source, as3]
----
var vertexData:VertexData = new VertexData();
vertexData.setPoint(0, "position", 0, 0);
vertexData.setPoint(1, "position", 10, 0);
vertexData.setPoint(2, "position", 0, 10);

var indexData:IndexData = new IndexData();
indexData.addTriangle(0, 1, 2);

var mesh:Mesh = new Mesh(vertexData, indexData);
addChild(mesh);
----

このように、まず最初にさらに２つのクラスをインスタンス化する必要があります。
_VertexData_ と _IndexData_ です。
//原文：They represent collections of vertices and indices, respectively.
それぞれ、頂点情報とindex情報の集合です。

* _VertexData_ は効率的に頂点それぞれの位置や色などの属性情報を保持します。
* _IndexData_ はその頂点のndex番号を保持します。３つのindex情報で三角形が作られます。

このようにして、上記のコードは最も基本的な描画オブジェクトである三角形を作りあげます。
３つに頂点情報を時計回りで参照しながらそれを行います。
//原文：After all, that's what a GPU can do best: drawing triangles -- lots of them.
最終的には、GPUができる最善はたくさんの三角形を描画する事なのです。

.上記で作成された三角形。
image::triangle.png[Triangle, 180]

=== メッシュの継承

直接 _VertexData_ と _IndexData_ を扱い続けるのは、かなりの面倒となるでしょう。
//原文：It makes sense to encapsulate the code in a class that takes care of setting everything up.
これらの設定処理を何かクラスに隠蔽してしまうのが良い策です。

ここで、どのようにカスタムメッシュを作ればいいのかを説明するため、_NGon_ という簡単なクラスを作ることにします。
N角形のポリゴンを好きな色で描画する事がこのクラスの仕事です。

.下記がそのクラスに描画させたい形状の例です。
image::polygons.png[Polygons]

そのクラスには通常のディスプレイオブジェクトと同じように動いて欲しく思います。
インスタンス化し、好きな位置に移動し、ディスプレイリストに追加するのです。

[source, as3]
----
var ngon:NGon = new NGon(100, 5, Color.RED); // <1>
ngon.x = 60;
ngon.y = 60;
addChild(ngon);
----
<1> コンストラクタ引数は、半径、エッジの数、色、をそれぞれ示します。

この機能をどのように実現すればいいか見てみましょう。

=== 頂点の設定

Like all other shapes, our regular polygon can be built from just a few triangles.
他の全てのシェイプと同じように、ポリゴン形状もいくつかの三角形から構成する事ができます。
Here's how we could set up the triangles of a pentagon (an n-gon with `n=5`).
下記は五角形をどのように三角形で構成するかの例です。（N が 5 である NGon が五角形です。）

.五角形と頂点。
image::pentagon.png[Pentagon, 200]

この五角形は６つの頂点から作られた５つの三角形で構成されています。
それぞれの頂点には 0~5 の番号を与え、真ん中のものを 5 とします。

先に述べたように、頂点情報は _VertexData_ インスタンスに保持されます。
_VertexData_ は各頂点ごとに、いくつかの属性値を持ちます。
この例では、２つの標準的な属性値が必要です。

* `position` 属性が２次元座標の点、x, y を保持します。
* `color` 属性が RGBA 形式の色情報を保持します。

_VertexData_ クラスはそれらの属性値にアクセスするいくつかのメソッドを持っています。
そのメソッド経由でポリゴン形状の頂点を設定する事ができます。

_Mesh_ クラスを継承して、新たに _NGon_ クラスを作ります。
そして下記のようなメソッドを定義します。

[source, as3]
----
private function createVertexData(
    radius:Number, numEdges:int, color:uint):VertexData
{
    var vertexData:VertexData = new VertexData();

    vertexData.setPoint(numEdges, "position", 0.0, 0.0); // <1>
    vertexData.setColor(numEdges, "color", color);

    for (var i:int=0; i<numEdges; ++i) // <2>
    {
        var edge:Point = Point.polar(radius, i*2*Math.PI / numEdges);
        vertexData.setPoint(i, "position", edge.x, edge.y);
        vertexData.setColor(i, "color", color);
    }

    return vertexData;
}
----
<1> 真ん中の頂点を設定します。(最後の index 番号。)
<2> エッジ部分の頂点を設定します。

ここでのメッシュは単色で構成させるため、全ての頂点に同じ色を設定しています。
各エッジ（コーナー）の頂点座標はある半径の演習に沿って設定されます。

=== Index の設定

頂点についてはここまでです。
//原文：Now we need to define the triangles that make up the polygon.
次は、ポリゴン形状を構成する三角形を設定します。

//原文：_Stage3D_ wants a simple list if indices, with each three successive indices referencing one triangle.
３つの連続した頂点 index 番号で１つの三角形を表す事ができますが、_Stage3D_ は、その頂点セットが羅列して並んたデータを必要とします。
頂点は時計回りで順番に参照するのが良いでしょう。
//原文：that convention indicates that we are looking at the front side of the triangle.
その流儀で並んだ頂点で作られる三角形はこちら側におもて面を向けます。
よって、五角形の indices データは下記のような内容となります。

    5, 0, 1,   5, 1, 2,   5, 2, 3,   5, 3, 4,   5, 4, 0

Starling では、そのリストを設定するために _IndexData_ クラスを使います。
下記のメソッドで、適切な index 番号を用いて _IndexData_ インスタンスを設定します。

[source, as3]
----
private function createIndexData(numEdges:int):IndexData
{
    var indexData:IndexData = new IndexData();

    for (var i:int=0; i<numEdges; ++i)
        indexData.addTriangle(numEdges, i, (i+1) % numEdges);

    return indexData;
}
----

=== NGon constructor

This is actually all we need for our _NGon_ class!
Now we just need to make use of the above methods in the constructor.
All the other responsibilities of a display object (hit testing, rendering, bounds calculations, etc.) are handled by the superclass.

[source, as3]
----
public class NGon extends Mesh
{
    public function NGon(
        radius:Number, numEdges:int, color:uint=0xffffff)
    {
        var vertexData:VertexData = createVertexData(radius, numEdges, color);
        var indexData:IndexData = createIndexData(numEdges);

        super(vertexData, indexData);
    }

    // ...
}
----

That's rather straight-forward, isn't it?
This approach works for any shape you can think of.

[TIP]
====
When working with custom meshes, also look at the _Polygon_ class (in the `starling.geom` package).
It helps with converting an arbitrary, closed shape (defined by a number of vertices) into triangles.
We look at it in more detail in the <<Masks>> section.
====

=== Adding a Texture

Wouldn't it be nice if we were able to map a texture onto this polygon, as well?
The base class, _Mesh_, already defines a `texture` property; we're only lacking the required _texture coordinates_.

Through texture coordinates, you define which part of a texture gets mapped to a vertex.
They are often called _UV-coordinates_, which is a reference to the names that are typically used for their coordinate axes (_u_ and _v_).
Note that the UV range is defined to be within _0_ and _1_, regardless of the actual texture dimensions.

.The texture coordinates of the polygon are in the range 0-1.
image::pentagon-texcoords.png[Pentagon Texture Coordinates, 250]

With this information, we can update the `createVertexData` method accordingly.

[source, as3]
----
function createVertexData(
    radius:Number, numEdges:int, color:uint):VertexData
{
    var vertexData:VertexData = new VertexData(null, numEdges + 1);
    vertexData.setPoint(numEdges, "position", 0.0, 0.0);
    vertexData.setColor(numEdges, "color", color);
    vertexData.setPoint(numEdges, "texCoords", 0.5, 0.5); // <1>

    for (var i:int=0; i<numEdges; ++i)
    {
        var edge:Point = Point.polar(radius, i*2*Math.PI / numEdges);
        vertexData.setPoint(i, "position", edge.x, edge.y);
        vertexData.setColor(i, "color", color);

        var u:Number = (edge.x + radius) / (2 * radius); // <2>
        var v:Number = (edge.y + radius) / (2 * radius);
        vertexData.setPoint(i, "texCoords", u, v);
    }

    return vertexData;
}
----
<1> The texture coordinates of the center vertex: `0.5, 0.5`.
<2> The origin of the n-gon is in the center, but the texture coordinates must be all positive.
    So we move the vertex coordinates to the right (by `radius`) and divide them by `2 * radius` to end up in the range `0-1`.

When a texture is assigned, the rendering code will automatically pick up those values.

[source, as3]
----
var ngon:NGon = new NGon(100, 5);
ngon.texture = assets.getTexture("brick-wall");
addChild(ngon);
----

.Our textured pentagon.
image::pentagon-textured.png[Textured Pentagon, 230]

=== Anti-Aliasing

If you look closely at the edges of our n-gon, you will see that the edges are quite jagged.
That's because the GPU treats a pixel either within the n-gon, or outside -- there are no in-betweens.
To fix that, you can enabled anti-aliasing: there's a property with that name on the _Starling_ class.

[source, as3]
----
starling.antiAliasing = 4;
----

The value correlates to the number of subsamples _Stage3D_ uses on rendering.
Using more subsamples requires more calculations to be performed, making anti-aliasing a potentially very expensive option.
Furthermore, _Stage3D_ doesn't support anti-aliasing on all platforms.

NOTE: On mobile, anti-aliasing currently only works within _RenderTextures_.

Thus, it's not an ideal solution.
The only consolation I can offer: the typical pixel-density of screens is constantly on the rise.
On modern, high end mobile phones, the pixels are now so small that aliasing is rarely an issue any longer.

.Anti-Aliasing can smooth pixelated edges.
image::anti-aliasing.png[Anti-Aliasing, 380]

// TODO: describe RenderTexture-workaround in "Pro-Tips" chapter and link to it here.

=== Mesh Styles

You now know how to create textured meshes with arbitrary shapes.
For this, you are using the standard rendering mechanics built into Starling.

However, what if you want to customize the rendering process itself?
The properties and methods of the _Mesh_ class provide a solid foundation -- but sooner or later, you will want more than that.

Coming to the rescue: Starling's _mesh styles_.

Styles are a brand new addition to Starling (introduced in version 2.0) and are the recommended way to create custom, high performance rendering code.
In fact, all rendering in Starling is now done via mesh styles.

* A style can be assigned to any mesh (instances of the _Mesh_ class or its subclasses).
* Per default, the style of each mesh is an instance of the base _MeshStyle_ class.
* The latter provides the standard rendering capabilities of Starling: drawing colored and textured triangles.

To teach your meshes new tricks, you can extend _MeshStyle_.
This allows you to create custom shader programs for all kinds of interesting effects.
For example, you could implement fast color transformations or multi-texturing.

[TIP]
====
One of the most impressive samples of a style is the http://wiki.starling-framework.org/extensions/dynamic_lighting[Dynamic Lighting extension].
With the help of a normal map (a texture encoding surface normals), it can provide realistic real-time lighting effects.
Be sure to check out this extension in the Starling Wiki to see it in action!
====

To use a style, instantiate it and assign it to the `style` property of the mesh:

[source, as3]
----
var image:Image = new Image(texture);
var lightStyle:LightStyle = new LightStyle(normalTexture);
image.style = lightStyle;
----

.The Dynamic Lighting extension in action.
image::dynamic-lighting.png[Dynamic Lighting]

Styles are extremely versatile; their possible applications are almost without limit.
And since meshes with the same style can be batched together, you do not sacrifice performance in any way.
In this respect, they are much more efficient than _fragment filters_ (which serve a similar purpose).

The main downsides of styles are simply that they can only be assigned to a mesh (not, say, a sprite), and that they can only act within the actual mesh area (making things like a blur impossible).
Furthermore, it's not possible to combine several styles on one mesh.

Still: styles are a powerful tool that any Starling developer should be familiar with.
Stay tuned: in a <<Custom Styles, later section>>, I'll show you how to create your own mesh style from scratch, shaders and all!

[NOTE]
====
If you're still a little confused about the differences between a _Mesh_ and a _MeshStyle_, think of it like this:
the _Mesh_ is nothing more than a list of vertices, and how those vertices spawn up triangles.

A style may add additional data to each vertex and use it on rendering.
The standard _MeshStyle_ provides color and texture coordinates; a _MultiTextureStyle_ might add an additional set of texture coordinates, etc.
But a style should never modify the original shape of the object; it won't add or remove vertices or change their positions.
====
