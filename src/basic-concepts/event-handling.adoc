== イベントハンドリング

"イベント" というのは、プログラマなら関心があるであろう出来事の事である、と考える事ができます。

* 例えば、モバイルアプリはデバイスが回転した時やユーザが画面をタッチした際に通知してくれるでしょう。
* もっと下層の話で言えば、ボタンが押された時や、ゲーム中ナイトの体力が尽きた時などの通知もあるでしょう。

そのような目的で、Starling のイベントシステムはあるのです。

=== 詳細
//原文：意味がわからない。。=== Motivation

イベントのシステムは Starling の構成機能のうち、キーとなる物です。
簡単に言うと、イベントによりオブジェクトは相互にコミュニケーションを取る事ができるようになります。

こう思うかもしれません。同じ目的で使える "メソッド" と言うものがあるじゃないか、と。
それも確かに正しいです。ですが、メソッドは１方向で動作するものです。
例えば、_ボタン_ を持つ _メッセージボックス_ を見てみましょう。

[ditaa, messagebox-calls-button]
....
/------------\
| MessageBox |
\-----+------/
      |
      | メソッド
      v
  /---+----\
  | Button |
  \--------/
....

メッセージボックスはボタンを保持しているので、そのメソッドとプロパティを利用する事ができます。

[source, as3]
----
public class MessageBox extends DisplayObjectContainer
{
    private var _yesButton:Button;

    private function disableButton():void
    {
        _yesButton.enabled = false; // <1>
    }
}
----
<1> プロパティを通してボタンとやりとりをする。

ところで _ボタン_ インスタンスは、メッセージボックスの参照を持っていません。
ボタンはどんなコンポーネントからでも使う事ができ、メッセージボックスには全く依存していません。
これは良い事です。なぜならそうでない場合メッセージボックスの中でしかボタンを使う事ができなくなってしまいます。（うーむ。）

それでも、ボタンはある理由で存在しています。押されたならば、それを誰かに伝えなくてはなりません。
//原文：Still: the button is there for a reason -- 
つまり、ボタンはオーナーが誰であれ、そこに対してメッセージを送信する事が必要なのです。

[ditaa, button-dispatches-to-messagebox]
....
/------------\
| MessageBox |
\------------/
      ^
      | イベント
      |
  /---+----\
  | Button |
  \--------/
....

=== イベントとイベントディスパッチャー

一つ白状しなくてはいけません。Starling のディスプレイオブジェクトのクラスの継承図を見せた時、実際のベースクラスを省略していたのです。_EventDispatcher_ と言うクラスです。

[plantuml, class-hierarchy-with-eventdispatcher]
....
include::../defaults.plantuml[]

abstract class DisplayObject
abstract class DisplayObjectContainer

EventDispatcher <|-- DisplayObject
DisplayObject <|-- Mesh
DisplayObject <|-- DisplayObjectContainer
....

このクラスは全てのディスプレイオブジェクトにイベントの発行とイベントの取り扱いをする術を与えます。
_EventDispatcher_ を全てのディスプレイオブジェクトが継承しているのは、偶然ではありません。
Starling では、イベントのシステムはディスプレイリストと強く統合しています。
後ほど取り扱いますが、これによっていくつか有利な点があります。

実際の例を見ながら解説します。

犬を手に入れた場合の事を考えて見ましょう。その犬をアインシュタインと呼びます。
毎日何回か、_アインシュタイン_ は、吠えることによって外へ散歩に行きたいと表現をします。

[source, as3]
----
class Dog extends Sprite
{
    function advanceTime():void
    {
        if (timeToPee)
        {
            var event:Event = new Event("bark"); // <1>
            dispatchEvent(event); // <2>
        }
    }
}

var einstein:Dog = new Dog();
einstein.addEventListener("bark", onBark); // <3>

function onBark(event:Event):void // <4>
{
    einstein.walk();
}
----
<1> `bark` と言う文字列がイベントを定義します。_Event_ のインスタンス内にカプセル化されます。
<2> 全ての `bark` イベントの購読者に `event` を発行します。
<3> ここで、`addEventListener` メソッドを使って、購読を設定しています。最初の引数はイベントのタイプで、２つ目はリスナ関数です。
<4> 犬が吠えた際このメソッドがイベントパラメータとともに呼ばれます。

今、イベントシステムの３つの構成要素を確認しました。

* イベントは*イベント*クラス（またはそのサブクラス）のインスタンス内にカプセル化されます。
* イベントを発行するには、発行元が _イベント_ インスタンスとともに *dispatchEvent* メソッドを実行します。
* イベントを購読するには、購読者は *addEventListener* を呼び出します。その際、どのイベントのタイプに興味があるかと、イベント発行時に呼び出すメソッドを指定します。

時には、あなたのおばさんも犬の世話をするでしょう。
その際は、犬が吠えても気にしなくて良いのです。おばさんも何のために購読をしたのか知っています。
なので、イベントのリスナ登録を解除してしまいましょう。これは犬の飼い主だけでなく、Starling の開発者にも有効な習慣です。

[source, as3]
----
einstein.removeEventListener("bark", onBark); // <1>
einstein.removeEventListeners("bark"); // <2>
----
<1> これにより `onBark` リスナーが解除されます。
<2> こちらの方法では、このタイプのイベントの全てのリスなを解除します。
`bark` イベントについてはこのような感じとなります。
もちろん、 _アインシュタイン_ は他にもいくつかのタイプのイベントを発行する事ができます。例えば、遠吠え(`howl`) や 唸り(`growl`) などです。

このような文字列は静的な定数に定義しておくのが良いでしょう。Dog クラス内の定数としてなどです。

[source, as3]
----
class Dog extends Sprite
{
    public static const BARK:String = "bark";
    public static const HOWL:String = "howl";
    public static const GROWL:String = "growl";
}

einstein.addEventListener(Dog.GROWL, burglar.escape);
einstein.addEventListener(Dog.HOWL, neighbor.complain);
----

Starling はあらかじめ、便利なイベントのタイプを _Event_ クラスに定義しています。
以下は、メジャーな物の一部です。

* *Event.TRIGGERED:* ボタンが押された
* *Event.ADDED:* コンテナにディスプレイオブジェクトが追加された
* *Event.ADDED_TO_STAGE:* ステージに関連するコンテナにディスプレイオブジェクトが追加された
* *Event.REMOVED:* コンテナからディスプレイオブジェクトが取り除かれた
* *Event.REMOVED_FROM_STAGE:* ディスプレイオブジェクトがステージへの接続を失った
* *Event.ENTER_FRAME:* 時間が経って、新しいフレームが描画された（この後取り扱います）
* *Event.COMPLETE:* 何か（ムービークリップの再生など）が終了した

=== Custom Events

Dogs bark for different reasons, right?
Einstein might indicate that he wants to pee, or that he is hungry.
It might also be a way to tell a cat that it's high time to make an exit.

Dog people will probably hear the difference (I'm a cat person; I won't).
That's because smart dogs set up a _BarkEvent_ that stores their intent.

[source, as3]
----
public class BarkEvent extends Event
{
    public static const BARK:String; // <1>

    private var _reason:String; // <2>

    public function BarkEvent(type:String, reason:String, bubbles:Boolean=false)
    {
        super(type, bubbles); // <3>
        _reason = reason;
    }

    public function get reason():Boolean { return _reason; } // <4>
}
----
<1> It's a good practice to store the event type right at the custom event class.
<2> The reason for creating a custom event: we want to store some information with it. Here, that's the `reason` String.
<3> Call the super class in the constructor. (We will look at the meaning of `bubbles` shortly.)
<4> Make `reason` accessible via a property.

The dog can now use this custom event when barking:

[source, as3]
----
class Dog extends Sprite
{
    function advanceTime():void
    {
        var reason:String = this.hungry ? "hungry" : "pee";
        var event:BarkEvent = new BarkEvent(BarkEvent.BARK, reason);
        dispatchEvent(event);
    }
}

var einstein:Dog = new Dog();
einstein.addEventListener("bark", onBark);

function onBark(event:BarkEvent):void // <1>
{
    if (event.reason == "hungry") // <2>
        einstein.feed();
    else
        einstein.walk();
}
----
<1> Note that the parameter is of type `BarkEvent`.
<2> That's why we can now access the `reason` property and act accordingly.

That way, any dog owners familiar with the _BarkEvent_ will finally be able to truly understand their dog.
Quite an accomplishment!

=== Simplifying

Agreed: it's a little cumbersome to create that extra class just to be able to pass on that `reason` string.
After all, it's very often just a single piece of information we are interested in.
Having to create additional classes for such a simple mechanism feels somewhat inefficient.

That's why you won't actually need the subclass-approach very often.
Instead, you can make use of the `data` property of the _Event_ class, which can store arbitrary references (its type: _Object_).

Replace the _BarkEvent_ logic with this:

[source, as3]
----
// create & dispatch event
var event:Event = new Event(Dog.BARK);
event.data = "hungry"; // <1>
dispatchEvent(event);

// listen to event
einstein.addEventListener(Dog.BARK, onBark);
function onBark(event:Event):void
{
    trace("reason: " + event.data as String); // <2>
}
----
<1> Store the _reason_ for barking inside the `data` property.
<2> To get the reason back, cast `data` to _String_.

The downside of this approach is that we lose some type-safety.
But in my opinion, I'd rather have that cast to _String_ than implement a complete class.

Furthermore, Starling has a few shortcuts that simplify this code further!
Look at this:

[source, as3]
----
// create & dispatch event
dispatchEventWith(Dog.BARK, false, "hungry"); // <1>

// listen to event
einstein.addEventListener(Dog.BARK, onBark);
function onBark(event:Event, reason:String):void
{
    trace("reason: " + reason); // <2>
}
----
<1> Creates an event of type `Dog.BARK`, populates the `data` property, and dispatches the event -- all in one line.
<2> The `data` property is passed to the (optional) second argument of the event handler.

We got rid of quite an amount of boiler plate code that way!
Of course, you can use the same mechanism even if you don't need any custom data.
Let's look at the most simple event interaction possible:

[source, as3]
----
// create & dispatch event
dispatchEventWith(Dog.HOWL); // <1>

// listen to event
dog.addEventListener(Dog.HOWL, onHowl);
function onHowl():void // <2>
{
    trace("hoooh!");
}
----
<1> Dispatch an event by only specifying its type.
<2> Note that this function doesn't contain any parameters! If you don't need them, there's no need to specify them.

NOTE: The simplified `dispatchEventWith` call is actually even more memory efficient, since Starling will pool the _Event_ objects behind the scenes.

=== Bubbling

In our previous examples, the event dispatcher and the event listener were directly connected via the `addEventListener`-method.
But sometimes, that's not what you want.

Let's say you created a complex game with a deep display list.
Somewhere in the branches of this list, _Einstein_ (the protagonist-dog of this game) ran into a trap.
He howls in pain, and in his final breaths, dispatches a `GAME_OVER` event.

Unfortunately, this information is needed far up the display list, in the game's root class.
On such an event, it typically resets the level and returns the dog to its last save point.
It would be really cumbersome to hand this event up from the dog over numerous display objects until it reaches the game root.

That's a very common requirement -- and the reason why events support something that is called _bubbling_.

Imagine a real tree (it's your display list) and turn it around by 180 degrees, so that the trunk points upwards.
The trunk, that's your stage, and the leaves of the tree are your display objects.
Now, if a leaf creates a bubbling event, that event will move upwards just like the bubbles in a glass of soda, traveling from branch to branch (from parent to parent) until it finally reaches the trunk.

.An event bubbles all the way up to the stage.
image::bubbling.png[Bubbling, 200]

Any display object along this route can listen to this event.
It can even pop the bubble and stop it from traveling further. All that is required to do that is to set the `bubbles`-property of an event to true.

[source, as3]
----
// classic approach:
var event:Event = new Event("gameOver", true); // <1>
dispatchEvent(event);

// one-line alternative:
dispatchEventWith("gameOver", true); // <2>
----
<1> Passing `true` as second parameter of the Event constructor activates bubbling.
<2> Alternatively, `dispatchEventWith` takes the exact same parameters.

Anywhere along its path, you can listen to this event, e.g. on the dog, its parent, or the stage:

[source, as3]
----
dog.addEventListener("gameOver", onGameOver);
dog.parent.addEventListener("gameOver", onGameOver);
stage.addEventListener("gameOver", onGameOver);
----

This feature comes in handy in numerous situations; especially when it comes to user input via mouse or touch screen.

=== Touch Events

While typical desktop computers are controlled with a mouse, most mobile devices, like smartphones or tablets, are controlled with your fingers.

Starling unifies those input methods and treats all "pointing-device" input as `TouchEvent`.
That way, you don't have to care about the actual input method your game is controlled with.
Whether the input device is a mouse, a stylus, or a finger: Starling will always dispatch touch events.

First things first: if you want to support multitouch, make sure to enable it before you create your Starling instance.

[source, as3]
----
Starling.multitouchEnabled = true;

var starling:Starling = new Starling(Game, stage);
starling.simulateMultitouch = true;
----

Note the property `simulateMultitouch`.
If you enable it, you can simulate multitouch input with your mouse on your development computer.
Press and hold the kbd:[Ctrl] or kbd:[Cmd] keys (Windows or Mac) when you move the mouse cursor around to try it out.
Add kbd:[Shift] to change the way the alternative cursor is moving.

.Simulating Multitouch with mouse and keyboard.
image::simulate-multitouch.png[Simulate Multitouch]

To react to touch events (real or simulated), you need to listen for events of the type `TouchEvent.TOUCH`.

[source, as3]
----
sprite.addEventListener(TouchEvent.TOUCH, onTouch);
----

You might have noticed that I've just added the event listener to a _Sprite_ instance.
_Sprite_, however, is a container class; it doesn't have any _tangible_ surface itself.
Is it even possible to touch it, then?

Yes, it is -- thanks to _bubbling_.

To understand that, think back to the _MessageBox_ class we created a while ago.
When the user clicks on its text field, anybody listening to touches on the text field must be notified -- so far, so obvious.
But the same is true for somebody listening for touch events on the message box itself; the text field is part of the message box, after all.
Even if somebody listens to touch events on the stage, he should be notified.
Touching any object in the display list means touching the stage!

Thanks to bubbling events, Starling can easily represent this type of interaction.
When it detects a touch on the screen, it figures out which _leaf object_ was touched.
It creates a _TouchEvent_ and dispatches it on that object.
From there, it will bubble up along the display list.

==== Touch Phases

Time to look at an actual event listener:

[source, as3]
----
private function onTouch(event:TouchEvent):void
{
    var touch:Touch = event.getTouch(this, TouchPhase.BEGAN);
    if (touch)
    {
        var localPos:Point = touch.getLocation(this);
        trace("Touched object at position: " + localPos);
    }
}
----

That's the most basic case: Find out if somebody touched the screen and trace out the coordinates.
The method `getTouch` is provided by the _TouchEvent_ class and helps you find the touches you are interested in.

NOTE: The _Touch_ class encapsulates all information of a single touch: where it occurred, where it was in the previous frame, etc.

As first parameter, we passed `this` to the `getTouch` method.
Thus, we're asking the the event to return any touches that occurred on on `this` _or its children_.

Touches go through a number of _phases_ within their life time:

[horizontal]
`TouchPhase.HOVER`:: Only for mouse input; dispatched when the cursor moves over the object with the mouse button _up_.
`TouchPhase.BEGAN`:: The finger just hit the screen, or the mouse button was pressed.
`TouchPhase.MOVED`:: The finger moves around on the screen, or the mouse is moved while the button is pressed.
`TouchPhase.STATIONARY`:: The finger or mouse (with pressed button) has not moved since the last frame.
`TouchPhase.ENDED`:: The finger was lifted from the screen or from the mouse button.

Thus, the sample above (which looked for phase `BEGAN`) will write trace output at the exact moment the finger touches the screen, but not while it moves around or leaves the screen.

==== Multitouch

In the sample above, we only listened to single touches (i.e. one finger only).
Multitouch is handled very similarly; the only difference is that you call `touchEvent.getTouches` instead (note the plural).

[source, as3]
----
var touches:Vector.<Touch> = event.getTouches(this, TouchPhase.MOVED);

if (touches.length == 1)
{
    // one finger touching (or mouse input)
    var touch:Touch = touches[0];
    var movement:Point = touch.getMovement(this);
}
else if (touches.length >= 2)
{
    // two or more fingers touching
    var touch1:Touch = touches[0];
    var touch2:Touch = touches[1];
    // ...
}
----

The `getTouches` method returns a vector of touches.
We can base our logic on the length and contents of that vector.

* In the first _if_-clause, only a single finger is on the screen. Via `getMovement`, we could e.g. implement a drag-gesture.
* In the _else_-clause, two fingers are on the screen. By accessing both touch objects, we could e.g. implement a pinch-gesture.

NOTE: The demo application that's part of the Starling download contains the https://github.com/Gamua/Starling-Framework/blob/master/samples/demo/src/utils/TouchSheet.as[TouchSheet] class, which is used in the _Multitouch_ scene.
It shows a sample implementation of a touch handler that allows dragging, rotation and scaling of a sprite.

==== Mouse Out and End Hover

There's a special case to consider when you want to detect that a mouse was moved away from an object (with the mouse button in "up"-state).
(This is only relevant for mouse input.)

If the target of a hovering touch changed, a _TouchEvent_ is dispatched to the previous target to notify it that it's no longer being hovered over.
In this case, the `getTouch` method will return `null`.
Use that knowledge to catch what could be called a _mouse out_ event.

[source, as3]
----
var touch:Touch = event.getTouch(this);
if (touch == null)
    resetButton();
----
