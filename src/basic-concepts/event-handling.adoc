== イベントハンドリング

"イベント" というのは、プログラマなら関心があるであろう出来事の事である、と考える事ができます。

* 例えば、モバイルアプリはデバイスが回転した時やユーザが画面をタッチした際に通知してくれるでしょう。
* もっと下層の話で言えば、ボタンが押された時や、ゲーム中ナイトの体力が尽きた時などの通知もあるでしょう。

そのような目的で、Starling のイベントシステムはあるのです。

=== 詳細
//原文：意味がわからない。。=== Motivation

イベントのシステムは Starling の構成機能のうち、キーとなる物です。
簡単に言うと、イベントによりオブジェクトは相互にコミュニケーションを取る事ができるようになります。

こう思うかもしれません。同じ目的で使える "メソッド" と言うものがあるじゃないか、と。
それも確かに正しいです。ですが、メソッドは１方向で動作するものです。
例えば、_ボタン_ を持つ _メッセージボックス_ を見てみましょう。

[ditaa, messagebox-calls-button]
....
/------------\
| MessageBox |
\-----+------/
      |
      | メソッド
      v
  /---+----\
  | Button |
  \--------/
....

メッセージボックスはボタンを保持しているので、そのメソッドとプロパティを利用する事ができます。

[source, as3]
----
public class MessageBox extends DisplayObjectContainer
{
    private var _yesButton:Button;

    private function disableButton():void
    {
        _yesButton.enabled = false; // <1>
    }
}
----
<1> プロパティを通してボタンとやりとりをする。

ところで _ボタン_ インスタンスは、メッセージボックスの参照を持っていません。
ボタンはどんなコンポーネントからでも使う事ができ、メッセージボックスには全く依存していません。
これは良い事です。なぜならそうでない場合メッセージボックスの中でしかボタンを使う事ができなくなってしまいます。（うーむ。）

それでも、ボタンはある理由で存在しています。押されたならば、それを誰かに伝えなくてはなりません。
//原文：Still: the button is there for a reason -- 
つまり、ボタンはオーナーが誰であれ、そこに対してメッセージを送信する事が必要なのです。

[ditaa, button-dispatches-to-messagebox]
....
/------------\
| MessageBox |
\------------/
      ^
      | イベント
      |
  /---+----\
  | Button |
  \--------/
....

=== イベントとイベントディスパッチャー

一つ白状しなくてはいけません。Starling のディスプレイオブジェクトのクラスの継承図を見せた時、実際のベースクラスを省略していたのです。_EventDispatcher_ と言うクラスです。

[plantuml, class-hierarchy-with-eventdispatcher]
....
include::../defaults.plantuml[]

abstract class DisplayObject
abstract class DisplayObjectContainer

EventDispatcher <|-- DisplayObject
DisplayObject <|-- Mesh
DisplayObject <|-- DisplayObjectContainer
....

このクラスは全てのディスプレイオブジェクトにイベントの発行とイベントの取り扱いをする術を与えます。
_EventDispatcher_ を全てのディスプレイオブジェクトが継承しているのは、偶然ではありません。
Starling では、イベントのシステムはディスプレイリストと強く統合しています。
後ほど取り扱いますが、これによっていくつか有利な点があります。

実際の例を見ながら解説します。

犬を手に入れた場合の事を考えて見ましょう。その犬をアインシュタインと呼びます。
毎日何回か、_アインシュタイン_ は、吠えることによって外へ散歩に行きたいと表現をします。

[source, as3]
----
class Dog extends Sprite
{
    function advanceTime():void
    {
        if (timeToPee)
        {
            var event:Event = new Event("bark"); // <1>
            dispatchEvent(event); // <2>
        }
    }
}

var einstein:Dog = new Dog();
einstein.addEventListener("bark", onBark); // <3>

function onBark(event:Event):void // <4>
{
    einstein.walk();
}
----
<1> `bark` と言う文字列がイベントを定義します。_Event_ のインスタンス内にカプセル化されます。
<2> 全ての `bark` イベントの購読者に `event` を発行します。
<3> ここで、`addEventListener` メソッドを使って、購読を設定しています。最初の引数はイベントのタイプで、２つ目はリスナ関数です。
<4> 犬が吠えた際このメソッドがイベントパラメータとともに呼ばれます。

今、イベントシステムの３つの構成要素を確認しました。

* イベントは*イベント*クラス（またはそのサブクラス）のインスタンス内にカプセル化されます。
* イベントを発行するには、発行元が _イベント_ インスタンスとともに *dispatchEvent* メソッドを実行します。
* イベントを購読するには、購読者は *addEventListener* を呼び出します。その際、どのイベントのタイプに興味があるかと、イベント発行時に呼び出すメソッドを指定します。

時には、あなたのおばさんも犬の世話をするでしょう。
その際は、犬が吠えても気にしなくて良いのです。おばさんも何のために購読をしたのか知っています。
なので、イベントのリスナ登録を解除してしまいましょう。これは犬の飼い主だけでなく、Starling の開発者にも有効な習慣です。

[source, as3]
----
einstein.removeEventListener("bark", onBark); // <1>
einstein.removeEventListeners("bark"); // <2>
----
<1> これにより `onBark` リスナーが解除されます。
<2> こちらの方法では、このタイプのイベントの全てのリスなを解除します。
`bark` イベントについてはこのような感じとなります。
もちろん、 _アインシュタイン_ は他にもいくつかのタイプのイベントを発行する事ができます。例えば、遠吠え(`howl`) や 唸り(`growl`) などです。

このような文字列は静的な定数に定義しておくのが良いでしょう。Dog クラス内の定数としてなどです。

[source, as3]
----
class Dog extends Sprite
{
    public static const BARK:String = "bark";
    public static const HOWL:String = "howl";
    public static const GROWL:String = "growl";
}

einstein.addEventListener(Dog.GROWL, burglar.escape);
einstein.addEventListener(Dog.HOWL, neighbor.complain);
----

Starling はあらかじめ、便利なイベントのタイプを _Event_ クラスに定義しています。
以下は、メジャーな物の一部です。

* *Event.TRIGGERED:* ボタンが押された
* *Event.ADDED:* コンテナにディスプレイオブジェクトが追加された
* *Event.ADDED_TO_STAGE:* ステージに関連するコンテナにディスプレイオブジェクトが追加された
* *Event.REMOVED:* コンテナからディスプレイオブジェクトが取り除かれた
* *Event.REMOVED_FROM_STAGE:* ディスプレイオブジェクトがステージへの接続を失った
* *Event.ENTER_FRAME:* 時間が経って、新しいフレームが描画された（この後取り扱います）
* *Event.COMPLETE:* 何か（ムービークリップの再生など）が終了した

=== カスタムイベント

犬と言う生き物は色々な理由で吠えますよね。
アインシュタインはおしっこをしたい、または、お腹が減った、と伝えているのかもしれません。
猫に対して出て行けと伝えるのにも使われるでしょう。
//原文：It might also be a way to tell a cat that it's high time to make an exit.

犬好きの人々はおそらくそれらを聞き分けます。（自分は猫好きなのでできませんが。）
これが、賢い犬が意図を _吠えるイベント_ に仕込む理由です。

[source, as3]
----
public class BarkEvent extends Event
{
    public static const BARK:String; // <1>

    private var _reason:String; // <2>

    public function BarkEvent(type:String, reason:String, bubbles:Boolean=false)
    {
        super(type, bubbles); // <3>
        _reason = reason;
    }

    public function get reason():Boolean { return _reason; } // <4>
}
----
<1> カスタムイベントクラスにイベントのタイプを定義するのは良い慣習です。
<2> カスタムイベントを作成した理由を保持する変数。ここに理由の情報を保持する。
<3> コンストラクタでの superクラス呼び出し。 （`bubbles` の意味はこの後すぐに取り扱います。）
<4> プロパティ経由で `理由` を取得できるようにします。

犬は吠える際にこのカスタムクラスが使えるようになりました。

[source, as3]
----
class Dog extends Sprite
{
    function advanceTime():void
    {
        var reason:String = this.hungry ? "hungry" : "pee";
        var event:BarkEvent = new BarkEvent(BarkEvent.BARK, reason);
        dispatchEvent(event);
    }
}

var einstein:Dog = new Dog();
einstein.addEventListener("bark", onBark);

function onBark(event:BarkEvent):void // <1>
{
    if (event.reason == "hungry") // <2>
        einstein.feed();
    else
        einstein.walk();
}
----
<1> 引数の型が `BarkEvent` になっています。
<2> 理由に応じて何をするのか決定します。
//原文：That's why we can now access the `reason` property and act accordingly.

このようにして、_BarkEvent_ の取り扱いに慣れている犬のオーナーは、彼らの犬について本当に知る事ができるのです。
まったく素晴らしい技能です！

=== もっと単純に
//原文：=== Simplifying

ただ `reason` を渡すだけで追加のクラスを作る事がやや面倒である事には同意します。
結局、ただ１つの情報にしか興味がない事はよくあります。
そのようにシンプルな機能のために新たなクラスを作るのは能率が悪いように思えます。

ですので、本当はサブクラスを作るアプローチを取る必要はそんなにないのです。
代わりに、_Event_ クラスの `data` プロパティを任意の情報を持たせる事に使う事ができます。（`data` の型は _Object_ です。）

_BarkEvent_ の実装を下記のように変更しましょう。

[source, as3]
----
// イベントを作成して発行する
var event:Event = new Event(Dog.BARK);
event.data = "hungry"; // <1>
dispatchEvent(event);

// イベントを購読する
einstein.addEventListener(Dog.BARK, onBark);
function onBark(event:Event):void
{
    trace("reason: " + event.data as String); // <2>
}
----
<1> 吠える _理由_ を `data` プロパティに設定します。
<2> 理由を取り出すには、`data` を _String_ 型に変換します。

このアプローチの悪い点は型安全でなくなる事です。
しかし、私のとしては、完全なクラスを実装するよりも むしろ _String_ に型を変換することを好みます。

さらに、Starling はこのコードをさらに単純化するショートカットをいくつか持っています。
下記を見てください。

[source, as3]
----
// イベントを作成して発行する
dispatchEventWith(Dog.BARK, false, "hungry"); // <1>

// イベントを購読する
einstein.addEventListener(Dog.BARK, onBark);
function onBark(event:Event, reason:String):void
{
    trace("reason: " + reason); // <2>
}
----
<1> `Dog.BARK` のイベントを作成して、`data` プロパティを設定して、イベントを発行する、これを全て一行で行います。
<2> `data` プロパティは（任意の）２番目の引数として、イベントハンドラに渡されます。

このようにしてたくさんの一般的なコード記述を取り除く事ができました！
もちろん、カスタム data が必要ない場合でもこの記述を使う事ができます。
最も単純なイベントの取り扱い例を見てみましょう。

[source, as3]
----
// イベントを作成して発行する
dispatchEventWith(Dog.HOWL); // <1>

// イベントを購読する
dog.addEventListener(Dog.HOWL, onHowl);
function onHowl():void // <2>
{
    trace("hoooh!");
}
----
<1> タイプのみ指定してイベントを発行します。
<2> この関数は引数を持っていません。必要がないのなら、それを指定する必要もないのです！

NOTE: 単純化された `dispatchEventWith` 呼び出しは、メモリーをさらに効率的に使います。Starling は _Event_ オブジェクトを裏で使いまわしているからです。

=== バブリング

一つ前のサンプルでは、`addEventListener` メソッドを通じてイベントの発行者 (dispatcher) と購読者 (dispatcher) は直接繋がっていました。
しかし、時折それは望んでいる状態ではない事があります。

複雑なゲームを作り、深く構造となったディスプレイリスト構造ができていたとします。
そのリストのどこかで、_アインシュタイン_ (ゲームの主人公です）が罠にはまったとします。
苦しんで遠吠えをし、息を引き取りながら `GAME_OVER` イベントを発行します。

残念ながら、この情報はディスプレイリストのはるか上層、ゲームのルートクラスで必要とされています。
このようなイベントは、マップをリセットし、犬を最後のセーブポイントまで戻します。
このイベントを犬からゲームのルートまでたくさんのディスプレイオブジェクトを経由して受け渡していくのはとても面倒です。
//原文：It would be really cumbersome to hand this event up from the dog over numerous display objects until it reaches the game root.

これはよくある要望です。そしてそれが _バブリング_ をイベントがサポートする理由です。

ディスプレイリストを実際の木と想像してみましょう。180度ひっくり返せば、幹の部分が上方にきます。
幹はステージに相当し、木の葉は各々のディスプレイオブジェクトに相当します。
１つの葉がバブリングイベントを作成したとすると、ソーダ水の中の泡のようにイベントが上方に移動していきます。枝から枝（親から親）へ、幹にたどり着くまで移動します。

.イベントのバブルがステージまで登っていく。
image::bubbling.png[Bubbling, 200]
//原文:An event bubbles all the way up to the stage.

経路の途中に位置するディスプレイオブジュエクトはこのイベントを購読する事ができます。
そこで、バブルを弾いて移動をストップする事もできます。そのような振る舞いとするには、イベントの `bubbles` プロパティを true に設定する必要があります。

[source, as3]
----
// 一般的なアプローチ
var event:Event = new Event("gameOver", true); // <1>
dispatchEvent(event);

// １行で記述するやり方
dispatchEventWith("gameOver", true); // <2>
----
<1> バブリングを有効とするため、イベントのコンストラクタの第二引数に `true`を渡します。
<2> 代わりに `dispatchEventWith` に同じパラメータを渡す事もできます。

イベントの経路上であればどこでも、このイベントを購読できます。犬の親の階層でもステージでもそれが可能です。

[source, as3]
----
dog.addEventListener("gameOver", onGameOver);
dog.parent.addEventListener("gameOver", onGameOver);
stage.addEventListener("gameOver", onGameOver);
----

この機能はたくさんのシチュエーションで役に立ちます。特にマウスやスクリーンのタッチなどを通したユーザの操作で有効となるでしょう。

=== タッチイベント

一般的なデスクトップコンピューターがマウスでコントロールされるのに対し、ほとんどのモバイルデバイス、スマートフォンやタブレットでは指でコントロールされます。

Starling はそれらのインプットを統合して、`TouchEvent` という ポインティングデバイス入力として扱います。
これにより、実際にゲームがどのような入力でコントロールされているのかを気にする必要がなくなります。
それがマウスであろうとも、スタイラスペンでも、指であっても、です。Starling はいつでもそれをタッチイベントとして発行します。

最初に大事なことを言うと、マルチタッチを扱いたい場合は、Starling のインスタンスを作成する前に間違いなくそれを有効にしておかなくてはいけません。

[source, as3]
----
Starling.multitouchEnabled = true;

var starling:Starling = new Starling(Game, stage);
starling.simulateMultitouch = true;
----

`simulateMultitouch` プロパティに注目してください。
もしこれを有効とすると、開発コンピュータ上のマウスを使ってマルチタッチをシミュレートする事ができるようになります。
キーボードの[Ctrl] か [Cmd] キーを（Windows か Mac かで異なります。) 押しながら、マウスを動かしてみてください。
[Shift] キーを追加すると、カーソルが動いている向きを反対に変更する事ができます。

.マウスとキーボードでマルチタッチをシュミレートする様子。
image::simulate-multitouch.png[Simulate Multitouch]

シュミレートであれ実際のものであれ、タッチイベントを扱うには、`TouchEvent.TOUCH` イベントを購読する必要があります。

[source, as3]
----
sprite.addEventListener(TouchEvent.TOUCH, onTouch);
----

_Sprite_ インスタンスにリスな登録を行った事に気づいたでしょうか？
_Sprite_ はコンテナクラスです。それ自身にはタッチ判定となる領域を持っていません。
これでタッチが可能なのでしょうか？

答えはイエスです。_バブリング_ の機構のおかげでそれが可能となります。

これを理解するには、ちょっと前に作成した _MessageBox_ クラスに戻って考えてみましょう。
テキストフィールドをユーザがクリックした際、テキストフィールドに対してタッチイベントの購読をしている誰にでも通知が飛びます。ここまでは明白です。
しかし、メッセージボックス自体に対してイベントを購読している者にも同じ通知が行きます。テキストフィールドは結局メッセージボックスの一部なのです。
ステージに対してタッチイベントの購読を行っている者にも通知が行くはずです。
ディスプレイリスト内のどのオブジェクトに対するタッチでも、それはステージをタッチしたと言う事になります！

バブリングイベントの仕組みのおかげで、Starling は簡単にこのインタラクションのタイプを理解する事ができます。
//原文：Thanks to bubbling events, Starling can easily represent this type of interaction.
スクリーンのタッチを検知した時、どの _葉要素_ がタッチされたのかが判定されます。
タッチイベントが作成され、そのオブジェクトから発行されます。
そこから、ディスプレイリストに沿ってイベントは上層へと登って行きます。

==== タッチフェーズ

実際のタッチイベントのリスナ関数を確認してみましょう。

[source, as3]
----
private function onTouch(event:TouchEvent):void
{
    var touch:Touch = event.getTouch(this, TouchPhase.BEGAN);
    if (touch)
    {
        var localPos:Point = touch.getLocation(this);
        trace("Touched object at position: " + localPos);
    }
}
----

上記は最も基本的な例です。スクリーンのタッチを検知して、その座標をログ出力します。
`getTouch` メソッドは、_TouchEvent_ クラスによって提供され、これは、関心があるタッチを選出するのに役立ちます。

NOTE: _Touch_ クラスは、シングルタッチの全ての情報をカプセル化します。どこでそれが起こって、前のフレームではその場所がどこであったか、などがその情報の例です。

`getTouch` メソッドへの最初の引数として、ここでは `this` を渡しました。
したがって、`this` か、またはその子要素で発生したいくつかのタッチについての情報を得る事ができます。
//原文：Thus, we're asking the the event to return any touches that occurred on on `this` _or its children_.

タッチは、その存在期間中、いくつかの _フェーズ_ を経て行きます。
//原文：Touches go through a number of _phases_ within their life time:

[horizontal]
`TouchPhase.HOVER`:: マウスインプットのみ。マウスのボタンが押されない状態でオブジェクト上をカーソルが通過した際に発行されます。
`TouchPhase.BEGAN`:: 指が画面に触れた、またはマウスボタンが押されたタイミングで発行されます。
`TouchPhase.MOVED`:: 指が画面上で移動した際、または、マウスがボタンが押されながら移動した際に発行されます。
`TouchPhase.STATIONARY`:: 指、またはマウスが押されたまま、前のフレームから移動がない場合に発行されます。
`TouchPhase.ENDED`::指が画面から離れた、または、マウスボタンが離された際に発行されます。

よって、上のサンプル（`BEGAN` フェーズを扱っています。）では、指が画面に触れたタイミングでログ出力を行います。
しかし、指が葉要素に沿って、またはスクリーン上を移動する際は何もログに表示しません。

==== Multitouch

In the sample above, we only listened to single touches (i.e. one finger only).
Multitouch is handled very similarly; the only difference is that you call `touchEvent.getTouches` instead (note the plural).

[source, as3]
----
var touches:Vector.<Touch> = event.getTouches(this, TouchPhase.MOVED);

if (touches.length == 1)
{
    // one finger touching (or mouse input)
    var touch:Touch = touches[0];
    var movement:Point = touch.getMovement(this);
}
else if (touches.length >= 2)
{
    // two or more fingers touching
    var touch1:Touch = touches[0];
    var touch2:Touch = touches[1];
    // ...
}
----

The `getTouches` method returns a vector of touches.
We can base our logic on the length and contents of that vector.

* In the first _if_-clause, only a single finger is on the screen. Via `getMovement`, we could e.g. implement a drag-gesture.
* In the _else_-clause, two fingers are on the screen. By accessing both touch objects, we could e.g. implement a pinch-gesture.

NOTE: The demo application that's part of the Starling download contains the https://github.com/Gamua/Starling-Framework/blob/master/samples/demo/src/utils/TouchSheet.as[TouchSheet] class, which is used in the _Multitouch_ scene.
It shows a sample implementation of a touch handler that allows dragging, rotation and scaling of a sprite.

==== Mouse Out and End Hover

There's a special case to consider when you want to detect that a mouse was moved away from an object (with the mouse button in "up"-state).
(This is only relevant for mouse input.)

If the target of a hovering touch changed, a _TouchEvent_ is dispatched to the previous target to notify it that it's no longer being hovered over.
In this case, the `getTouch` method will return `null`.
Use that knowledge to catch what could be called a _mouse out_ event.

[source, as3]
----
var touch:Touch = event.getTouch(this);
if (touch == null)
    resetButton();
----
