== Starling の設定

Starling を使ったアプリケーション作成の最初のステップです。
_Starling_ クラス (`starling.core` パッケージ下にあります。)のインスタンスを作ります。
コンストラクタの引数は以下のようになっています。

[source, as3]
----
public function Starling(
    rootClass:Class,
    stage:Stage,
    viewPort:Rectangle = null,
    stage3D:Stage3D = null,
    renderMode:String = auto,
    profile:Object = auto);
----

rootClass:: _Stage3D_ の初期化が終わったタイミングですぐにインスタンス化されるクラスです。
`starling.display.DisplayObject` のサブクラスでなくてはいけません。

stage:: いつもの Flash の stage です。Starling で参照が保持されます。
これによって Starling と Flash の ディスプレイリストがお互いに接続されるようになります。

viewPort:: Flash の stage 全体のうち、Starling が描画するエリアです。
stage と同じ大きさにされる事が多いため、値を指定しないか `null` を指定する事で、自動的に stage 全体の大きさが使われます。

stage3D:: 描画に使われる _Stage3D_ のインスタンスです。
全ての Flash の stage は複数の _Stage3D_ インスタンスを持つ事ができるため、そのうちの一つを選択する事ができます。
しかし、たいていの場合、デフォルトの null パラメータを渡せば（引数を省略すれば）十分です。
自動的に 利用可能な _Stage3D_ オブジェクトの最初の一つが Starling に利用されるようになります。

//原文：renderMode:: The whole idea behind _Stage3D_ is to provide hardware-accelerated rendering.
renderMode:: _Stage3D_ の背後にある全てのアイデアは、ハードウェアを使って描画を行う事です。
//原文：However, there is also a software fallback mode; it may be forced by passing `Context3DRenderMode.SOFTWARE`.
しかし、renderMode の引数に `Context3DRenderMode.SOFTWARE` を渡すごとにより、ソフトウェアのレンダリングモードに切り替えることもできます。
といってもデフォルトの `auto` 値が推奨されます。
`auto` 値の指定では、ハードウェアレンダリングが使えない状況のみ、自動でソフトウェアのレンダリングに切り替わります。

//原文：profile:: _Stage3D_ provides a set of capabilities that are grouped into different _profiles_
profile:: _Stage3D_ は、いくつかの _プロファイル_ 設定 として そのGPUの能力をいくつかのグループに振り分けます。
（ プロファイルは、Context3DProfile クラスの定数として設定されています。）
良いハードウェアの上でアプリが動いているほど、プロファイルも良いものが選択可能になります。
`auto` の設定では単純に一番良いプロファルを選択します。

たいていの引数はデフォルトの引数が適切に設定されています。よって全てを指定する必要はありません。
下記のコードは、Starling を実行するわかりやすい例です。
_Flash Player_ もしくは、_AIR_ プロジェクト用の _Main_ クラスを見ています。

[source, as3]
----
package
{
    import flash.display.Sprite;
    import starling.core.Starling;

    [SWF(width="640", height="480",
         backgroundColor="#808080",
         frameRate="60")]
    public class Main extends Sprite
    {
        private var _starling:Starling;

        public function Main()
        {
            _starling = new Starling(Game, stage);
            _starling.start();
        }
    }
}
----

ここで Main クラスが `flash.display.Sprite` を継承しており、Starling の Sprite を継承しているのでは無い事に注目してください。
_AS3_ で作られた全てのプロジェクトで _Main_ クラスはこのような形である必要があります。
//原文：the logic is moved over to the _Game_ class, which builds our link to the `starling.display` world.
しかし、Starling が初期化を終えるとすぐに、`starling.display` の世界を形作る _Game_ クラスに処理が移ります。

[NOTE]
.フレームレートの設定
====
いくつかの設定は class 定義より前の、"SWF" _MetaData_ タグで設定されています。フレームレートもそこで設定されます。
Starling 自体にはフレームレートの設定がありません、stage の _frameRate_ 値をそのまま利用します。
`nativeStage` 値は `nativeStage` のプロパティ経由で動的に変更することもできます。

[source, as3]
----
Starling.current.nativeStage.frameRate = 60;
----
====

Starling の初期化プロセスは非同期処理です。
これは、Main 命令の最後の段階ではまだ Game インスタンスにアクセスできない事を意味します。
Game インスタンスが作成されたタイミングは `ROOT_CREATED` を受け取ることで知る事ができます。

[source, as3]
----
public function Main()
{
    _starling = new Starling(Game, stage);
    _starling.addEventListener(Event.ROOT_CREATED, onRootCreated);
    _starling.start();
}

private function onRootCreated(event:Event, root:Game):void
{
    root.start(); // Game クラスには 'start' メソッドが定義されている前提です。
}
----

=== The ViewPort

_Stage3D_ は Starling に矩形の描画エリアを提供します。
描画エリアは stage のどこでも構いません。つまり、_Flash Player_ 画面内のどこでも、_AIR_ の場合はアプリケーション画面内のどこでも、です。

Starling では、この描画エリアを _viewPort_ と呼びます。
大抵は画面全体を使いたいかと思いますが、場合によってはエリアを制限した方が理にかないます。

4:3 のアスペクト比をもつゲームを 16:9 のそれをもつ画面上で動かすことを考えます。
By centering the 4:3 _viewPort_ on the screen, you will end up with a "letterboxed" game,
4:3 比率の _viewPort_ を画面の真ん中に配置する事で、"letterbox" されたゲーム、
つまり、画面上下に何も表示しないエリアのもつゲームが出来上がります。

// TODO: add image

//原文：You can't talk about the _viewPort_ without looking at Starling's _stage_, as well.
Starling の _stage_ を考えずに、_viewPort_ についてあれこれ言う事はできません。
デフォルトでは stage の大きさと _viewPort_ の大きさは等しくなります。

これはもちろんとても理にかなっています。
1024 × 768 ピクセルのディスプレイを持っているデバイスは同じ stage の大きさを持っているはずです。

しかし、stage の大きさは、変更する事ができます。
`stage.stageWidth` や `stage.stageHeight` のプロパティ値を変更する事で可能です。

[source, as3]
----
stage.stageWidth = 1024;
stage.stageHeight = 768;
----

しかし、これは何を意味するでしょう？
描画エリアは _viewPort_ で定義されるのでしょうか？それとも _stageの大きさ_ で定義されるのでしょうか？

慌てなくとも大丈夫です。描画エリアはそれでも 先に説明されたように _viewPort_ によって定義されます。
`stageWidth` や `stageHeight` を変更しても描画エリアは全く変化しません。
//原文：the stage is always stretched across the complete _viewPort_.
_viewPort_ の値によってのみ、 stage は大きさを変えます。
//原文：What you are changing, though, is the size of the stage's _coordinate system_.
では、何を変更していたのでしょうか。それは stage の _coordinate システム_ のサイズです。

//原文：That means that with a stage width of `1024`, an object with an x-coordinate of `1000` will be close to the right edge of the stage; no matter if the viewPort is `512`, `1024`, or `2048` pixels wide.
つまり、stage の横幅が `1024` である時、x座標が `1000` であるあるオブジェクトはほぼ右端に表示されます。viewPort の値が `512` `1024` `2048` などどんなピクセル数であろうと関係ありません。

これは _HiDPI_ スクリーンに対して開発をしている時に特に役に立ちます。
例えば、_iPad_ にはノーマル解像度のものとレティナ解像度のものがありますが、後者は縦横のピクセル幅が倍で、トータル4倍のピクセル数を持っています。
そのようなスクリーン上でのユーザーインターフェースは、小さくは表示されずに、よりきめ細かく表示されるべきです。

//原文：By differentiating between the _viewPort_ and the _stage size_, this is easily reproduced in Starling.
_viewPort_ と _stage サイズ_ の違いを理解する事で、この解像度の違いは 簡単に Starling 上で再現する事ができます。
//原文：On both device types, the stage size will be 1024×768; the viewPort, on the other hand, will reflect the size of the screen in pixels.
どちらのタイプの端末でも、stage サイズは 1024×768 になります。対して、viewPort 値は実際の端末のピクセル値となります。
//原文：The advantage: you can use the same coordinates for your display objects, regardless of the device on which the application is running.
さらに、この調整は画面上に表示しているオブジェクトに対しても適用する事ができます。どのようなデバイスでアプリケーションが動いているかに関わらず。

[NOTE]
.Points と Pixels
====
この事についてよく理解をしたならば、そのようなレティナデバイス上では、x座標が 1 である表示オブジェクトは、
実際には 2 ピクセルの位置にある事がわかるでしょう。
つまり、計測単位が変わったのです。
もはやピクセルの単位ではなく、ポイントの単位で考えています。
低い解像度のスクリーンでは 1ピクセル ＝ 1ポイント ですが、HiDPI スクリーンでは 2ピクセル ＝ 1ポイントです。
（端末によってはそれ以上となります。）
====

実際の幅をピクセル数で求めるには、単に `viewPort.width` 値を `stage.stageWidth` 値で割ってやれば良いです。
もしくは Starling の contentScaleFactor プロパティ値を参照します。同じ計算をしてくれます。

[source, as3]
----
starling.viewPort.width = 2048;
starling.stage.stageWidth = 1024;
trace(starling.contentScaleFactor); // -> 2.0
----

このコンセプトが実際にどのように役に立つかは <<モバイル開発>> の章で詳しく説明します。
//↑ここのアンカーリンク正しく動いていないが原文からしてそうなので一旦放置

=== Context3D Profiles

The platforms Starling is running on feature a wide variety of graphics processors.
Of course, those GPUs have different capabilities.
The question is: how to differentiate between those capabilities at runtime?

That's what _Context3D profiles_ (also called _render profiles_) are for.

[NOTE]
.What is a Context3D?
====
When using _Stage3D_, you are interacting with a rendering pipeline that features a number of properties and settings.
The _context_ is the object that encapsulate that pipeline.
Creating a texture, uploading shaders, rendering triangles -- that's all done through the context.
====

Actually, Starling makes every effort to hide any profile limitations from you.
To ensure the widest possible reach, it was designed to work even with the lowest available profile.
At the same time, when running in a higher profile, it will automatically make best use of it.

Nevertheless, it might prove useful to know about their basic features.
Here's an overview of each profile, starting with the lowest.

`BASELINE_CONSTRAINED`:: If a device supports Stage3D at all, it must support this profile. It comes with several mean limitations, e.g. it only supports textures with side-lengths that are powers of two, and the length of shaders is very limited. That profile is mainly found on old desktop computers.

`BASELINE`:: The minimum profile to be found on mobile devices. Starling runs well with this profile; the removal of the power-of-two limitation allows for more efficient memory usage, and the length of shader programs is easily sufficient for its needs.

`BASLINE_EXTENDED`:: Raises the maximum texture size from `2048x2048` to `4096x4096` pixels, which is crucial for high-resolution devices.

`STANDARD_CONSTRAINED`, `STANDARD`, `STANDARD_EXTENDED`:: Starling currently doesn't need any of the features coming with these profiles. They provide additional shader commands and other low-level enhancements.

My recommendation: simply let Starling pick the best available profile (`auto`) and let it deal with the implications.

[NOTE]
.Maximum Texture Size
====
There's only one thing you need to take care of yourself: making sure that your textures are not too big.
The maximum texture size is accessible via the property `Texture.maxSize`, but only _after_ Starling has finished initializing.
====

//原文：=== Native Overlay
=== Flash描画の重ね合わせ

Starling のメインコンセプトは Stage3D API を利用して描画を速くする、という事です。
しかし、クラシック （元々のFlashの）ディスプレイリストには Starling では実現できない機能がたくさんあることは否定できません。
よって、両者を合わせて使ってやることは理にかなっています。

`nativeOverlay` プロパティを扱うのが、それを行う簡単な方法です。
//原文：That's a conventional `flash.display.Sprite` that lies directly on top of Starling, taking _viewPort_ and _contentScaleFactor_ into account.
_viewPort_ 値と _contentScaleFactor_ 値を考慮した状態で、Starlingの前面に従来の `flash.display.Sprite` が表示されます。

従来の Flash 描画オブジェクトを使いたい場合、この `nativeOverlay` にそれらを add してください。

しかし、従来の Flash 描画を _Stage3D_ 上に重ねると、いくつかの（モバイルの）端末ではパフォーマンスの低下を招く事には注意してください。
For that reason, always remove all objects from the overlay when you don't need them any longer.
この理由で、逆に必要がない場合は全ての Flash 描画オブジェクトを取り除くようにしましょう。

[NOTE]
====
質問される前に…Starling のディスプレイオブジェクトの背面に従来の Flash 描画オブジェクトを配置する事はできません。
Stage3D の領域はいつでも最背面に存在します。それ以外の状態はありえないのです。
====

=== Skipping Unchanged Frames

It happens surprisingly often in an application or game that a scene stays completely static for several frames.
The application might be presenting a static screen or wait for user input, for example.
So why redraw the stage at all in those situations?

That's exactly the point of the `skipUnchangedFrames`-property.
If enabled, static scenes are recognized as such and the back buffer is simply left as it is.
On a mobile device, the impact of this feature can't be overestimated.
There's simply no better way to enhance battery life!

I'm already hearing your objection: if this feature is so useful, why isn't it activated by default?
There must be a catch, right?

Indeed, there is: it doesn't work well with _Render-_ and _VideoTextures_.
Changes in those textures simply won't show up.
It's easy to work around that, though: either disable `skipUnchangedFrames` temporarily while using them, or call `stage.setRequiresRedraw()` whenever their content changes.

Now that you know about this feature, make it a habit to always activate it!
In the meantime, I hope that I can solve the mentioned problems in a future Starling version.

IMPORTANT: On mobile platforms, there's another limitation you should be aware of: as soon as there's any content on the native (Flash) stage (e.g. via Starling's `nativeOverlay`), Starling can't skip any frames.
That's the consequence of a Stage3D limitation.

=== The Statistics Display

When developing an application, you want as much information as possible about what's going on.
That way, you will be able to spot problems early and maybe avoid running into a dead end later.
The statistics display helps with that.

[source, as3]
----
_starling.showStats = true;
----

.The statistics display (by default at the top left).
image::stats-display.png[The statistics display]

What's the meaning of those values?

* The _framerate_ should be rather self-explanatory: the number of frames Starling managed to render during the previous second.
* _Standard memory_ is, in a nutshell, what your _AS3_ objects fill up. Whether it's a _String_, a _Sprite_, a _Bitmap_, or a _Function_: all objects require some memory.
  The value is given in megabytes.
* _GPU memory_ is separate from that. Textures are stored in graphics memory, as are vertex buffers and shader programs.
  Most of the time, textures will overshadow everything else.
* The number of _draw calls_ indicates how many individual "draw"-commands are sent to the GPU in each frame.
  Typically, a scene renders faster when there are fewer draw calls.
  We will look in detail at this value when we talk about <<Performance Optimization>>.

You might notice that the background color of the statistics display alternates between black and dark green.
That's a subtle clue that's referring to the `skipUnchangedFrames` property:
whenever the majority of the last couple of frames could be skipped, the box turns green.
Make sure that it stays green whenever the stage is static; if it doesn't, some logic is preventing frame skipping to kick in.

TIP: You can customize the location of the statistics display on the screen via the method `showStatsAt`.
