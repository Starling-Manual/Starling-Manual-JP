== マルチ解像度を扱う開発

１つの画面サイズでゲームを作ればよかった時代はどこへ行ってしまったのでしょう？
当時は html 上の四角い小さなエリアに、スプライトやテキストや画像を表示していました。
１つの画面解像度だけ考えて実装をすればよかったのです。いい時代ですよね。

//原文：Alas ... the times they are a-changin'!
ああ、時代は変わってしまった！
モバイル端末の大きさは様々です。そしてデスクトップコンピューターやノートPCであっても、細かい密度のディスプレイを持つようになりました。
これは消費者としてはとても喜ぶべき事です、しかし、決して開発者の生活を楽にするものではありません。

でも希望をしてないでください。どうにかする事は可能です。
//原文：It's just a matter of thinking ahead and making use of a few simple mechanisms provided by Starling.
単に事前に考慮して、 Starling が提供するいくつかのシンプルな機能を利用すればいいだけの事です。

難しいのは、最初のうちはその問題にちょっと圧倒されてしまうという所です。
That's why we'll do this in small steps -- and we will begin in 2007.
ですので、まずは2007年の頃の状況に戻って考えて、少しずつ対応を進めていきます。

//原文：Yes, you heard right: step into the DeLorean, start up the Flux Capacitor(TM) and hold tight while we hit those eighty miles per hour.
ええ、聞き間違いではありません。デロリアンに乗り込んで、次元転送装置を起動しましょう。
時速120km以上のスピードで問題にぶつかってていくので、引き締まっていきましょう！

=== iPhone

iPhone は間違いなく最近のゲームで最も人気なプラットフォームです。
2007年の頃、iPhone は簡単に開発ができる _唯一の_ デバイスでした。
それは App Store の大ゴールドラッシュと呼べるような時代でした。

画面解像度が 320x480 に固定されていたので、最初の iPhone はとても開発がしやすかったのです。
//原文：Granted, Starling wasn't around back then,but you would have started it up like this:
もちろん、その頃に Starling は存在しませんでしたが、もしあったとすると下記のようなコードで実装を始めた事でしょう。

[source, as3]
----
var screenWidth:int  = stage.fullScreenWidth;
var screenHeight:int = stage.fullScreenHeight;
var viewPort:Rectangle = new Rectangle(0, 0, screenWidth, screenHeight);

starling = new Starling(Game, stage, viewPort);
----

_viewPort_ の大きさを画面サイズ 320×480 の目一杯に設定します。
デフォルトの状態では、Stage は画面解像度と全く同じ大きさを持ちます。

.初代 iPhone で我々のゲームを動かした図
image::iphone-penguflip.png[PenguFlip on the iPhone, 120]

ここまではとても簡単です。ブラウザでゲームを作るのと変わりません。
（それはInternet Explorer 6 上であったかも知れませんね。）

では次に、2010年に移動してみましょう。

=== iPhone レティナ

//原文：We park our DeLorean right around the corner of the old Apple campus and check out the App Store charts.
古き Apple 学園の角のあたりにデロリアンを停めて、当時の App Store のランニングを見てみましょう。
//原文：Hurray! Apparently, our game was a huge success in 2007, and it's still in the top 10!
やりました！2007年に大成功した我々のゲームは、まだランキングトップ10に止まっているようです！
//原文：There's no time to lose: we must make sure it looks well on the iPhone 4 that's going to come out in a few weeks.
時間を無駄にしてはいけません、あと数週間でリリースされる iPhone 4 上でもきちんとした見た目になるよう、ゲームを調整しなくては。

//原文：Since we're coming from the future, we know about its major innovation, the high-resolution screen dubbed "Retina Display" by the Apple marketing team.
我々は未来からやってきたので、この大技術革新について知っています。Apple のマーケティングチームによって "レティナ ディスプレイ" と名付けられた、高解像度スクリーンの事です。
//原文：We fire up our game from 2007 and start it up on this yet-to-be released device.
2007年のゲームを起動して、未だリリースされていないこのデバイス上で動かしてみましょう。

.全く意図しない状態になりました。
image::iphone4-wrong.png[PenguFlip with a wrong scale on the iPhone4, 160]

//原文：Damn, the game is now only taking up a quarter of the screen!
なんとした事か、画面のたった1/4のエリアでしかゲームが動いていません。
一体どういう事なのか？

2007年のコードを見返してみると、_viewPort_ の大きさをスクリーンと同じ大きさにしたのがわかるでしょう。
iPhone 4 では、スクリーンサイズは倍になっていて、640×960 ピクセルの大きさを持ちます。
//原文：The code that placed display objects on the stage expected a coordinate system of just 320×480, though.
しかし、ステージ上のディスプレイオブジェクトのコードは 320×480 の大きさを持つシステムで動いている事を期待しているのです。
よって画面右端(`x=320`)に配置したつもりのオブジェクトは、突如として真ん中に現れるのです。

でも、これは簡単に解決する事ができます。

Starling の `viewPort` の値と `stageWidthとstageHeight` の値は、独立して設定できる事を思い出してください。

* viewPort の設定はスクリーン上のどのエリアに Starling が描画すべきかを設定します。これはいつでもピクセルの単位で記述されます。
//原文：* The stage size decides the size of the coordinate system that is displayed in that viewPort.
//When your stage width is 320, any object with an x-coordinate between 0 and 320 will be within the stage, no matter the size of the viewPort.
* stage サイズの値は、viewPort 内で描画されているシステムがどのくらいの大きさの解像度で動作するのを設定します。stage の幅を 320 と設定した場合、x座標を 0 から 320 の間で設定されたオブジェクトが画面内に表示されます。viewPort の大きさの設定値は関係ありません。

この知識があれば、拡大表示をする事は簡単です。

[source, as3]
----
var screenWidth:int  = stage.fullScreenWidth;
var screenHeight:int = stage.fullScreenHeight;
var viewPort:Rectangle = new Rectangle(0, 0, screenWidth, screenHeight);

starling = new Starling(Game, stage, viewPort);
starling.stage.stageWidth  = 320;
starling.stage.stageHeight = 480;
----

//原文：The viewPort is still dynamic, depending on the device the game is started on;
viewPort 値は依然動的であって、ゲームを動かすデバイスによって変わります。
//原文：but we added two lines at the bottom that hard-code the stage size to fixed values.
しかし、コードの最後の２行の部分にステージの大きさを静的な値としてハードコードしています。

NOTE: これら stage の大きさの値は、もはやピクセル値を示さないので _ポイント_ という単位として考えることにしましょう。
つまり、ステージサイズは 320 ポイント × 480 ポイントである、というように表せる事となります。

これで iPhone 4 でのゲームの見た目は下記のようになりました。

.良くなりました、が、ちょっとボケています。
image::iphone4-scale-blurry.png[PenguFlip scaled up blurry, 285]

全画面表示ができるようになったのは良いです。
しかし、画像がボケて表示されてしまいました。
まだこの大きな解像度の画面をうまく使いこなせていないのです。

すでに、悪い内容のレビューが付いているのがわかります。修正しなくてはいけません。

==== HD テクスチャ

このような問題を解決するには、高いピクセル密度の画面には専用のテクスチャを用意すればいいのです。

ピクセル密度に合わせて、それぞれ低解像度と高解像度の両方のテクスチャセットを使います。
//原文：The advantage: except for the logic that picks the textures, we don't need to change any of our code.
この方法の良い点は、どちらのテクスチャセットを適用するか選択するロジック以外は、コードの変更が必要とされない、という事です。

//原文：It's not enough to simply load a different set of files, though.
しかし、ただ単純に異なる解像度のテクスチャセットを読み込むだけではダメです。
//原文：After all, bigger textures will return bigger values for _width_ and _height_.
固定横幅320ポイントのステージ上でも、結局大きなテクスチャは大きな幅と高さを返します。
//原文：With our fixed stage width of 320 points,

//原文：* an SD texture with a width of 160 pixels will fill half of the stage;
* 横幅160ピクセルの SD テクスチャはステージの半分のサイズとなります。
//原文：* a corresponding HD texture (width: 320 pixels) would fill the complete stage.
* 対応する横幅320ピクセルの HD テクスチャはステージ全体を覆います。

//原文：What we want instead is for the HD texture to report the same size as the SD texture, but provide more detail.
理想の状態は、HD テクスチャも SD テクスチャと同じサイズだと計測され、しかし、より細かい詳細な見た目である事です。

ここが Starling の _contentScaleFactor_ が役に立つ領域です。

//原文：We implicitly set it up when we configured Starling's _stage_ and _viewPort_ sizes.
私たちが Starling で _stage_ と _viewPort_ のサイズを設定した際、_contentScaleFactor_ 値は自動で設定されています。

//原文：With the setup shown above, run the following code on an iPhone 4:
設定のコードは上にあるもののままです。試しに、iPhone 4 で下記のコードを実行してください。

[source, as3]
----
trace(starling.contentScaleFactor); // → 2
----

_contentScaleFactor_ は _viewPortの横幅_ を _stageの横幅_ で割った値を返します。

レティナ端末では、"2" を、非レティナ端末では、 "1" が返されます。

//原文：This tells us which textures to load at runtime.
この値を使って、どのテクスチャセットを読み込むか決定する事ができます。

NOTE: contentScaleFactor 値が整数を返すのは、偶然ではありません。
Apple は、できるだけアンチエイリアスの問題を避けるため、デバイスの横幅・縦幅をちょうど２倍に設定しています。

texture クラスは単純に `scale` と呼ばれる、似たようなプロパティを持っています。
//原文：When set up correctly, the texture will work just like we want it to.
設定が正しく終わると、texture は期待通りの振る舞いをします。

[source, as3]
----
var scale:Number = starling.contentScaleFactor; // <1>
var texturePath:String = "textures/" + scale + "x"; // <2>
var appDir:File = File.applicationDirectory;

assetManager.scaleFactor = scale; // <3>
assetManager.enqueue(appDir.resolvePath(texturePath));
assetManager.loadQueue(...);

var texture:Texture = assetManager.getTexture("penguin"); // <4>
trace(texture.scale); // → Either '1' or '2' <5>
----
<1> Starling のインスタンスから `contentScaleFactor` の値を得ます。
<2> scale factor 値に合わせて、`1x` または `2x` という名前のテクスチャを読み込む準備をします。
<3> _AssetManager_ に先ほどの scale factor 値を設定します。読み込まれたテクスチャはこの値を利用して初期化されます。
<4> 実際にテクスチャにアクセスする際は、scale factor について気をかける必要はありません。
<5> テクスチャの `scale` プロパティにアクセスして、scale 値を確認する事は可能です。

NOTE: _AssetManager_ を使わないでプログラムをしていますか？
問題ありません。全てのテクスチャ作成メソッド（`Texture.from...`で始まるメソッド）は scale factor を指定する引数を持っています。
この値はテクスチャ作成時に設定しなくてはいけません。後から値を変える事は不可能です。

//原文：The textures will now take the _scale factor_ into account when you query their width or height.
テクスチャの縦幅・横幅を得ようとすると、内部計算で _scale factor_ が考慮された後の値を得る事ができます。
For example, here's what will happen with the game's full-screen background texture.
下記は、我々のゲームで使っている背景画像の大きさを取得した例です。

|===
|ファイル名 |ピクセルサイズ |Scale Factor |ポイントでのサイズ

|textures/1x/bg.jpg
|320×480
|1.0
|320×480

|textures/2x/bg.jpg
|640×960
|2.0
|320×480

|===

さて、これで準備が整いました！

//原文：* Our graphic designer on the back seat (call him Biff) creates all textures in a high resolution (ideally, as vector graphics).
* 後ろの席に座っているグラフィックデザイナー（Biffと呼びましょう）は全てのテクスチャをまず高解像度で作成します。理想としてはベクターグラフィクスであると良いです。
//原文：* In a preprocessing step, the textures are converted into the actual resolutions we want to support (`1x`, `2x`).
* 次に実際に利用するテクスチャを作ります。先ほどの高解像度テクスチャを(`1x`, `2x`)としてサポートできる解像度に変換します。
* 実際の利用時は、Starling の _contentScaleFactor_ 値を確認し、対応したテクスチャをロードします。

これで終了です。くっきりとした見た目のレティナディスプレイ対応ゲームを作る事ができました！
//原文：Our player's will appreciate it, I'm sure of that.
ゲームのプレイヤーは喜ぶに違いありません。

.レティナディスプレイを使った例です。
image::iphone4-scale-hd.png[PenguFlip on the iPhone, 285]

TIP: https://www.codeandweb.com/texturepacker/starling?source=gamua[TexturePacker] のようなツールを使うと、今まで説明した手順を簡単に行う事ができます。
//原文：Feed them with all your individual textures (in the highest resolution) and let them create multiple texture atlases, one for each scale factor.
ツールに、一番高解像度の個々のテクスチャを登録してください。そこからそれぞれの scale factor 用のテクスチャアトラスを書き出す事ができます。

We celebrate our success at a http://gizmodo.com/5520438/how-apple-lost-the-next-iphone[bar] in Redwood, drink a beer or two, and move on.

=== iPhone 5

//原文：In 2012, the iPhone has another surprise in store for us: Apple changed the screen's aspect ratio.
2012年、iPhone は更なる驚きを我々に用意してくれていました。Apple は画面サイズの縦横比を変えてしまったのです。
横方向は640ピクセルのままでしたが、縦方向に少し伸びて1136ピクセルとなりました。
//原文：It's still a retina display, of course, so our new logical resolution is 320×568 points.
これはもちろんレティナディスプレイでもあります。よって我々の考えるベース解像度は320×568ポイントとなります。

//原文：As a quick fix, we simply center our stage on the _viewPort_ and live with the black bars at the top and bottom.
これに対応する簡単な対応として、単純に今までの _viewPort_ を真ん中に表示して、
上下の空いた場所はそのまま黒いエリアとしてしまいましょう。

[source, as3]
----
var offsetY:int = (1136 - 960) / 2;
var viewPort:Rectangle = new Rectangle(0, offsetY, 640, 960);
----

これでちゃんと動くようです！
//原文：It's even a fair strategy for all those Android smartphones that are beginning to pop up in this time line.
この対処方法は、この過去の旅に登場しはじめ用としている全てのAndroid スマートフォンに対しても有効です。
//原文：Yes, our game might look a little blurry on some devices, but it's not too bad: the image quality is still surprisingly good.
我々のゲームはいくつかのデバイス上では少しぼやけてしまうかもしれません。しかしものすごく悪い状態というわけでもありません。画像のクオリティはそれでもかなり良いのです。
ほとんどのユーザーはその事に気がつかないでしょう。

.レターボックス法。
image::iphone5-letterbox.png[PenguFlip with letterbox bars, 160]

私は、この対応のやり方を *レターボックス法* と呼びます。

* ゲームは固定サイズ（例えば320×480ポイントの大きさ）で作成します。
* いくつかの scale factor 値に対応したアセットを作成します。(`1x`, `2x`, `3x` など。)
* 歪みなくスクリーン全体にフィットするよう、アプリのサイズを拡大します。

これがおそらく最も実用的な解決方法です。

//原文：It allows your game to run in an acceptable quality on all available display resolutions,
この方法であれば、どのような画面解像度の端末上であっても、そこそこのクオリティの見た目であなたのゲームを動かす事ができます。
//原文： and you don't have to do any extra work other than setting the viewPort to the right size.
このためにあなたがすべきことは、viewPort を正しいサイズに設定することだけです。

ところで、Starling に付属する _RectangleUtil_ を使うと、後者はとても簡単に実現できます。
viewPort を拡大するには、下記のようなコードを記述してください。

[source, as3]
----
const stageWidth:int  = 320; // 単位：points
const stageHeight:int = 480;
const screenWidth:int  = stage.fullScreenWidth; // 単位：pixels
const screenHeight:int = stage.fullScreenHeight;

var viewPort:Rectangle = RectangleUtil.fit(
    new Rectangle(0, 0, stageWidth, stageHeight),
    new Rectangle(0, 0, screenWidth, screenHeight),
    ScaleMode.SHOW_ALL);
----

シンプルですが、効果的ですね！
//原文：We definitely earned ourselves another trip with the time machine. //訳しづらい。。
さて、当然タイムマシーンの旅には続きがあります。車に乗り込みましょう！

=== iPhone 6 及び Android

2014にやってきましたが、、、なんて事だ！
App Store の年鑑を確認すると、我々のソフトの売り上げは最後のアップデートから著しくない事がわかりました。

どうやら Apple はレターボックスのやり方が気にくわなかったようで、今回はアプリをフューチャーしてくれませんでした。ムムム…。

//原文：Well, I guess we have no other choice now: let's bite the bullet and make use of that additional screen space.
どうやらこうするしかないようです、なんとか追加のスクリーンスペースも利用してましょう。

//原文：So long, hard-coded coordinates!
自動調整機能よ、さようなら！

これからは、全てのディスプレイオブジェクトに対して、相対座標を用いて扱っていきます。

私はこのやり方を、*スマート オブジェクト プレースメント* と、呼ぼうと思います。
最初のコーディングは今までの物ととても似ています。

[source, as3]
----
var viewPort:Rectangle = new Rectangle(0, 0, screenWidth, screenHeight);

starling = new Starling(Game, stage, viewPort);
starling.stage.stageWidth  = 320;
starling.stage.stageHeight = isIPhone5() ? 568 : 480;
----

//原文：Yeah, I smell it too.
ええ、ちょっとこれも臭いますね。。
デバイスによるステージの高さの違いをハードコードしています。これはあまり賢いアイデアではありません。
//原文：Promised, we're going to fix that soon.
ここは、後ほどすぐに修正する事を約束します。

しかしこれは今の所正しく動きます。_viewPort_ も _stage_ も正しいサイズです。
しかしどのように利用しましょう？
ここで、_Game_ クラスをみてみましょう。このクラスは Starling の root ディスプレイオブジェクトとして振る舞います。

[source, as3]
----
public class Game extends Sprite
{
    public function Game()
    {
        addEventListener(Event.ADDED_TO_STAGE, onAddedToStage); // <1>
    }

    private function onAddedToStage():void
    {
        setup(stage.stageWidth, stage.stageHeight); // <2>
    }

    private function setup(width:Number, height:Number):void
    {
        // ...

        var lifeBar:LifeBar = new LifeBar(width); // <3>
        lifeBar.y = height - lifeBar.height;
        addChild(lifeBar);

        // ...
    }
}
----
<1> Game クラスのコンストラクタがよばれた際、まだ Game インスタンスは Stage 上に配置されていません。
//原文：So we postpone initialization until we are.
なので、実際の初期化処理は準備ができるまで遅らせます。
<2> 準備をできた後、setup メソッドを飛ぶときにステージのサイズを引数に渡します。
//原文：<3> Exemplary, we create a _LifeBar_ instance (a custom user interface class) at the bottom of the screen.
<3> ゲームでよく見かけるような _ライフバー_を、画面の下部に配置します。

ざっと見た所、難しくはないですよね？
//原文：The trick is to always take the stage size into account.
種は、ステージサイズを計算に入れるという事です。

//原文：Here, it pays off if you created your game in clean components,
//原文：with separate classes responsible for different interface elements.
さて、もしもあなたの作ったゲームが、整理された構成をしており、
それぞれのユーザーインターフェースのオブジェクトにはそれぞれ専用のクラスが用意してあるなら、
このようなやり方でうまくいきます。

//原文：For any element where it makes sense,
//原文：you pass the size along (like in the _LifeBar_ constructor above) and let it act accordingly.
ユーザーインターフェースのオブジェクトのうち、調整して意味があるもの全てに対して、
（_LifeBar_ のコンストラクタの例のように）ステージのサイズを受け渡して、
それに応じてうまく大きさや位置を変えて振る舞うようにするのです。

.No more レータボックスの帯のエリアはもうありません。画面全体が利用されています。
image::iphone5-smart-objects.png[PenguFlip without letterbox bars, 160]

iPhone 5 でこの方法はとてもうまく動きます。
2012年の時点でこのように対応しておけばよかった！
//原文：Here, in 2014, things have become even more complicated.
2014現在では自体はもっと複雑になっています。

//原文：* Android is quickly gaining market share, with phones in all different sizes and resolutions.
//原文：* Even Apple introduced bigger screens with the _iPhone 6_ and _iPhone 6 Plus_.
//原文：* Did I mention tablet computers?
* Android はマーケット上でどんどんとシェアを伸ばしてきており、端末毎に大きさも解像度も異なっています。
* Apple も _iPhone 6_ と _iPhone 6 Plus_ という端末でさらに大きな画面を導入しました。
* タブレット端末についてはもう説明しましたっけ？

//原文：By organizing our display objects relative to the stage dimensions,
//原文：we already laid the foundations to solve this.
ディスプレイオブジェクトの配置をステージの大きさに合わせて、整理する事により、
すでに問題に対する基本対応方針はできあがっています。
我々のゲームは色々なステージサイズの端末で動作する事でしょう。

//原文：The remaining problem is which values to use for stage size and content scale factor.
残った問題は、どの値をステージの大きさと scale factor 値のために使うかという事です。
//原文：Looking at the range of screens we have to deal with, this seems like a daunting task!
扱うスクリーンの種類の多さを見ると、気持ちが折れてしまいそうです。

|===
|デバイス |スクリーンサイズ |スクリーン密度 |解像度

|iPhone 3
|3,50"
|163 dpi
|320×480

|iPhone 4
|3,50"
|326 dpi
|640×960

|iPhone 5
|4,00"
|326 dpi
|640×1136

|iPhone 6
|4,70"
|326 dpi
|750×1334

|iPhone 6 Plus
|5,50"
|401 dpi
|1080×1920

|Galaxy S1
|4,00"
|233 dpi
|480×800

|Galaxy S3
|4,80"
|306 dpi
|720×1280

|Galaxy S5
|5,10"
|432 dpi
|1080×1920

|Galaxy S7
|5,10"
|577 dpi
|1440×2560

|===

The key to figuring out the scale factor is to take the screen's density into account.

* The higher the density, the higher the scale factor.
  In other words: we can infer the scale factor from the density.
* From the scale factor, we can calculate the appropriate stage size.
  Basically, we reverse our previous approach.

The original iPhone had a screen density of about 160 dpi.
We take that as the basis for our calculations: for any device, we divide the density by 160 and round the result to the next integer.
Let's make a sanity check of that approach.

|===
|デバイス |スクリーンサイズ |スクリーン密度 |Scale Factor 値 |ステージサイズ

|iPhone 3
|3,50"
|163 dpi
|1.0
|320×480

|iPhone 4
|3,50"
|326 dpi
|2.0
|320×480

|iPhone 5
|4,00"
|326 dpi
|2.0
|320×568

|iPhone 6
|4,70"
|326 dpi
|2.0
|375×667

|iPhone 6 Plus
|5,50"
|401 dpi
|3.0
|414×736

|Galaxy S1
|4,00"
|233 dpi
|1.5
|320×533

|Galaxy S3
|4,80"
|306 dpi
|2.0
|360×640

|Galaxy S5
|5,10"
|432 dpi
|3.0
|360×640

|Galaxy S7
|5,10"
|577 dpi
|4.0
|360×640

|===

Look at the resulting stage sizes: they are now ranging from 320×480 to 414×736 points.
That's a moderate range, and it also makes sense: a screen that's physically bigger is supposed to have a bigger stage.
The important thing is that, by choosing appropriate scale factors, we ended up with reasonable coordinate systems.
This is a range we can definitely work with!

NOTE: You might have noticed that the scale factor of the _Galaxy S1_ is not an integer value.
This was necessary to end up with an acceptable stage size.

Let's see how I came up with those scale values.
Create a class called `ScreenSetup` and start with the following contents:

[source, as3]
----
public class ScreenSetup
{
    private var _stageWidth:Number;
    private var _stageHeight:Number;
    private var _viewPort:Rectangle;
    private var _scale:Number;
    private var _assetScale:Number;

    public function ScreenSetup(
        fullScreenWidth:uint, fullScreenHeight:uint,
        assetScales:Array=null, screenDPI:Number=-1)
    {
        // ...
    }

    public function get stageWidth():Number { return _stageWidth; }
    public function get stageHeight():Number { return _stageHeight; }
    public function get viewPort():Rectangle { return _viewPort; }
    public function get scale():Number { return _scale; }
    public function get assetScale():Number { return _assetScale; }
}
----

This class is going to figure out the _viewPort_ and _stage size_ Starling should be configured with.
Most properties should be self-explanatory -- except for the `assetScale`, maybe.

The table above shows that we're going to end up with scale factors ranging from "1" to "4".
However, we probably don't want to create our textures in all those sizes.
The pixels of the densest screens are so small that your eyes can't possibly differentiate them, anyway.
Thus, you'll often get away with just providing assets for a subset of those scale factors (say, 1-2 or 1-3).

* The `assetScales` argument in the constructor is supposed to be an array filled with the scale factors for which you created textures.
* The `assetScale` property will tell you which of those asset-sets you need to load.

TIP: Nowadays, it's even rare for an application to require scale factor "1".
However, that size comes in handy during development, because you can preview your interface without requiring an extremely big computer screen.

Let's get to the implementation of that constructor, then.

[source, as3]
----
public function ScreenSetup(
    fullScreenWidth:uint, fullScreenHeight:uint,
    assetScales:Array=null, screenDPI:Number=-1)
{
    if (screenDPI <= 0) screenDPI = Capabilities.screenDPI;
    if (assetScales == null || assetScales.length == 0) assetScales = [1];

    var iPad:Boolean = Capabilities.os.indexOf("iPad") != -1; // <1>
    var baseDPI:Number = iPad ? 130 : 160; // <2>
    var exactScale:Number = screenDPI / baseDPI;

    if (exactScale < 1.25) _scale = 1.0; // <3>
    else if (exactScale < 1.75) _scale = 1.5;
    else _scale = Math.round(exactScale);

    _stageWidth  = int(fullScreenWidth  / _scale); // <4>
    _stageHeight = int(fullScreenHeight / _scale);

    assetScales.sort(Array.NUMERIC | Array.DESCENDING);
    _assetScale = assetScales[0];

    for (var i:int=0; i<assetScales.length; ++i) // <5>
        if (assetScales[i] >= _scale) _assetScale = assetScales[i];

    _viewPort = new Rectangle(0, 0, _stageWidth * _scale, _stageHeight * _scale);
}
----
<1> We need to add a small workaround for the Apple iPad. We want it to use the same set of scale factors you get natively on iOS.
<2> Our base density is 160 dpi (or 130 dpi on iPads). A device with such a density will use scale factor "1".
<3> Our scale factors should be integer values or `1.5`. This code picks the closest one.
<4> Here, we decide the set of assets that should be loaded.

TIP: If you want to see the results of this code if run on the devices I used in the tables above, please refer to this https://gist.github.com/PrimaryFeather/505fc4f120c06d09d2c56910476ab710[Gist].
You can easily add some more devices to this list and check out if you are pleased with the results.

Now that everything is in place, we can adapt the startup-code of Starling.
This code presumes that you are providing assets with the scale factors "1" and "2".

[source, as3]
----
var screen:ScreenSetup = new ScreenSetup(
    stage.fullScreenWidth, stage.fullScreenHeight, [1, 2]);

_starling = new Starling(Root, stage, screen.viewPort);
_starling.stage.stageWidth  = screen.stageWidth;
_starling.stage.stageHeight = screen.stageHeight;
----

When loading the assets, make use of the `assetScale` property.

[source, as3]
----
var scale:Number = screen.assetScale;
var texturePath:String = "textures/" + scale + "x";
var appDir:File = File.applicationDirectory;

assetManager.scaleFactor = scale;
assetManager.enqueue(appDir.resolvePath(texturePath));
assetManager.loadQueue(...);
----

That's it!
You still have to make sure to set up your user interface with the stage size in mind, but that's definitely manageable.

TIP: The Starling repository contains a project called _Mobile Scaffold_ that contains all this code.
It's the perfect starting point for any mobile application.
(If you can't find the _ScreenSetup_ class in your download yet, please have a look at the head revision of the GitHub project.)

TIP: If you are using _Feathers_, the class _ScreenDensityScaleFactorManager_ will do the job of the _ScreenSetup_ class we wrote above.
In fact, the logic that's described here was heavily inspired by that class.

=== iPad 及び その他タブレット

//原文：Back in the present, we're starting to wonder if it would make sense to port our game to tablets.
ここで現在に戻って、我々のゲームをタブレットに対応させる事がうまくいくのか考えてみましょう。
上のコードはタブレットでもそのままうまく動作します。
しかし、今までの例よりもずっと広いステージとよりたくさんのコンテンツを配置する空間を目にする事になります。
これにどのように対応すべきかは、あなたが作っているアプリケーションによりけりです。

==== いくつかのゲームでは拡大しているだけ

//原文：Games like _Super Mario Bros_ or _Bejeweled_ look great scaled to a big screen with detailed textures.
_Super Mario Bros_ や _Bejeweled_ のようなゲームは大きなスクリーンに対しても細かいテクスチャとともに綺麗に拡大表示されます。
//原文：In that case, you could ignore the screen density and calculate the scale factor based just on the amount of available pixels.
このような場合、画面密度は無視して、表示可能なピクセル数のみから scale factor 値を計算すれば良いです。

* 初代 iPad（解像度: 768×1024）は、画面サイズが 384×512 であり、scale factor が "2" のデバイスとして扱えます。
* レティナ iPad (解像度: 1536×2048）も、画面サイズが 384×512 であり、scale factor が "4" のデバイスとして扱えます。

==== よりたくさん物を表示するタイプも
_Sim City_ や _Command & Conquer_ のようなゲームについて考えてみましょう。
//原文：such games could show the user much more of the landscape.
そのようなゲームでは、大きな画面であれば街並みや風景をよりたくさん見せる事ができます。
//原文：The user interface elements would take up less space compared to the game's content.
ユーザーインターフェースの要素はゲームのコンテンツに対してより小さなスペースをしめるようになります。

==== またある場合は全く異なったユーザーインターフェースを考える必要がある事も

特に実用アプリの場合、これは正しい事です。
モバイルフォンの小さな画面上では、Eメールアプリは、メール本文か受信箱かメールボックスのどれか１つを表示する事になると思われます。
一方、タブレット端末上ではその３つを同時に表示する事ができるでしょう。

//原文：Don't underestimate the development effort this will cause.
この対応をするのに必要な開発の労力を甘く見ないようにしましょう。