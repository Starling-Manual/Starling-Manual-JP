== コンテキストロス

全ての Stage3D によるレンダリングは "レンダーコンテキスト" と呼ばれる _Context3D_ クラスのインスタンスを通して行われます。
レンダーコンテキストは、アクティブなテクスチャ一覧や頂点データなど、GPU の現在の設定を保持しています。
レンダーコンテキスト は GPU とのコネクションなのです。これがないと、Stage3D のレンダリングは何も行う事ができません。

ここで問題があります。このコンテキストはしばしば失われてしまうのです。
つまり、グラフィックスメモリー上にあった全てのデータへの参照を失うと言う事です。例えば、テクスチャが失われます。

そのようなコンテキストロス(紛失)は全てのシステムで同じ頻度で起こるわけではありません。 _iOS_ と _macOS_ ではほとんど再現せず、
_Windows_ は時々再現し、_Android_では頻繁に再現します。（画面を回転すると…再現！）
//原文：happens from time to time on _Windows_ and very often on _Android_ (rotating the screen? Bam!).
これが起こる事自体はどうする事もできないので、最悪のケースが起きる事を想定し、コンテキストロスにあらかじめ準備しておく事が必要です。

=== デフォルトの振る舞い

現在のコンテキストを紛失した事を Starling が認識すると、下記の一連の処理を実行します。

* Starling は自動で新しいコンテキストを作成し、今までと同じセッティングで初期化します、
* 全ての頂点及び頂点インデックスバッファを復元します。
* 全ての頂点シェーダーとピクセルシェーダーを再コンパイルします。
* テクスチャを可能な限り再ロードします。(メモリ/ディスク/その他から。)

バッファの内容とプログラムを元に戻すことは問題にはなりません。Starling は必要な全てのデータを保持しており、元に戻す時間も長くかかりません。
しかし、テクスチャに関しては頭の痛い問題です。
説明のため、最悪のケースの例を見てみましょう。テクスチャの生成に埋め込みビットマップを使っていた場合です。

[source, as3]
----
[Embed(source="hero.png")]
public static const Hero:Class;

var bitmap:Bitmap = new Hero();
var texture:Texture = Texture.fromBitmap(bitmap);
----

`Texture.fromBitmap` メソッドを呼び出した瞬間、ビットマップが GPU メモリにアップロードされます。つまりビットマップがコンテキストの一部になったと言うことです。
コンテキストが永久に存在すると信頼できるのなら、これでやる事は終了です。

しかし、そのように信頼する事はできません。テクスチャのデータはいつでもなくなりうるのです。
そのため、Starling はオリジナルのビットマップのコピーを保持します。
最悪の事態となった時、テクスチャを復元するために使われます。
この処理は自動で行われます。

驚くべきことに、１つのテクスチャが３箇所でメモリー上に存在することになります！

* "Hero" クラス内（通常のメモリー）
* コピーされているビットマップ（通常のメモリー）
* テクスチャ（グラフィックスメモリー）

モバイル端末などとてもメモリ量が制限されている場合、これは大惨事であると言えます。
このような状態は避けたいですね！
//原文：You don't want this to happen!

下記のようにコードを多少変更することで、若干問題を緩和する事が可能です。

[source, as3]
----
// 代わりに 'fromEmbeddedAsset' メソッドを使う。
var texture:Texture = Texture.fromEmbeddedAsset(Hero);
----

このようにすると、Starling は埋め込みクラスから直接テクスチャを再生成します。(`new Hero()` を呼び出します。）
つまりテクスチャはメモリー上に２箇所にか存在しない事になります。
埋め込みクラスに対しては、これがベストの対応です。

しかし、理想としては１箇所しかテクスチャをメモリー上に持ちたくありません。
そのためには、アセットを埋め込んではいけません。代わりに、ローカルもしくはリモートからアセットを読み込むようにします。
その場合 URL のみを保持すればよく、実際のデータは元の場所から再読み込みができるのです。

２つの方法があります。

* _AssetManager_ を用いてテクスチャのロードを行う。
* 手動でテクスチャを読み込み直す。

オススメはいつでも _AssetManager_ を使う事です。
メモリーを浪費する事なくコンテキストロスに対応する事ができます。
テクスチャを復元するためのどんな特別処理も記述する必要がなくなります。

しかし、裏で何が行われているか知る事は良い事です。
ひょっとすると、手動でテクスチャを復元せざるを得ない状況がありえるかもしれません。

=== テクスチャの手動復元

`Texture.fromEmbeddedAsset()` は実際にはどのように動いているのでしょうか。
このメソッドの考えられる実装をみてみましょう。

[source, as3]
----
public static function fromEmbeddedAsset(assetClass:Class):Texture
{
    var texture:Texture = Texture.fromBitmap(new assetClass());
    texture.root.onRestore = function():void
    {
        texture.root.uploadFromBitmap(new assetClass());
    };
    return texture;
}
----

`root.onRestore` コールバック内で重要な処理が行われている事がわかります。
しかし、`root` とは何でしょう？

知らないかもしれませんが、_テクスチャ_ のインスタンスを生成した際、それはしばしば実際の完全なテクスチャではないのです。
実はそれは、他のテクスチャの一部の領域への参照かもしれないのです。（それを _SubTexture_ といいます。）
`fromBitmap` メソッドを呼び出しでさえも、その参照を返します。
（しかし、その理由を説明するのは、このチャプターの範疇を超えてしまいます。）

いずれにしろ、`texture.root` は いつでも、_ConcreteTexture_ オブジェクトを返します。そして、そのオブジェクトには `onRestore` コールバックが存在します。
このコールバックはコンテキストロスの後に直接呼び出され、テクスチャを復元する機会を与えてくれます。

今回のコールバックの例では、もう一度同じビットマップをインスタンス化して、ルートテクスチャとしてアップロードしてやります。
さあ、テクスチャが復元されました！
//原文：Voilà, the texture is restored!

しかし、詳細な部分には悪魔が住んでいるものです。
`onRestore` コールバックは、知らぬ間に別のビットマップのコピーを保持してしまわないよう、厳重に慎重に作成しましょう。
ここに一見無害ではあるものの、実はとてもよろしくないコールバックの例があります。

[source, as3]
----
public static function fromEmbeddedAsset(assetClass:Class):Texture
{
    // このコードを実際に利用してはいけません！悪いコードの例です。
	
    var bitmap:Bitmap = new assetClass();
    var texture:Texture = Texture.fromBitmap(bitmap);
    texture.root.onRestore = function():void
    {
        texture.root.uploadFromBitmap(bitmap);
    };
    return texture;
}
----

良くない点があるのがわかりましたか？

問題は、このメソッドが _Bitmap_ オブジェクトを生成し、コールバック内で利用しているという事です。
このコールバックは、_クロージャー_ と呼ばれるもので、周辺の変数とともに保持されるインライン(関数内)の関数です。
//原文：that's an inline function that will be stored together with some of the variables that accompany it.
言い換えれば、メモリー上に関数オブジェクトが保持して、コンテキストロス発生時に呼び出される事が出来るようにします。
そして、はっきりとそのように設定をしていないにも関わらず、ビットマップのインスタンスがその内部に保持されます。
（実際は、`bitmap` をコールバック内で利用する事によってそれを行なっているのです。）

元のコードでは、ビットマップは参照されず、コールバック内で _作成_ されています。
従ってクロージャーに `bitmap` インスランスが保持される事はないのです。
`assetClass` オブジェクトだけがコールバック内で参照されます。どちらにしろメモリー内にですが。

このテクニックはどんなシナリオでも上手く働きます。

* テクスチャが URL からローヂされているのなら、その URL を使ってコールバック内で読み込み直します。
* それが ATF テクスチャであってもやり方は同じです。異なるのは `root.uploadATFData` メソッドを代わりに使うだけです。
* 従来の Flash のディスプレイオブジェクトのレンダリングをビットマップとして使っている場合、
コールバック内では、そのディスプレイオブジェクトを新しいビットマップにレンダリングし直してください。
（Starling の _TextField_ クラスがちょうど同じように処理をしています。）
//原文：For a bitmap containing a rendering of a conventional display object,
//just reference that display object and draw it into a new bitmap in the callback.
//(That's just what Starling's _TextField_ class does.)

NOTE: 強調すると、_AssetManager_ はこのような処理をいい感じに自動で行なってくれます。ただどのようにそれが実装されているのか説明しておきたかったのです。
//原文：Let me emphasize: the _AssetManager_ does all this for you, so that's the way to go. I just wanted to show you how that is achieved.

=== レンダーテクスチャー

コンテキストロスが悩ましいまた別の領域はレンダーテクスチャに関する所です。
他のテクスチャと同じように、レンダーテクスチャも内容を失いうります。しかし、簡単にそれを復元する方法は存在しないのです。
結局、その内容というのは動的なたくさんの描画処理の結果なのですから。

もしも、_レンダーテクスチャー_ が見た目の賑やかし用途だけで使われているのなら（例えば雪面の足跡など）、
全てをなかったことにしてやり直すのでも良いかもしれません。
しかし、内容がとても重要であるのなら、この問題を解決しなくてはいけません。

特にこれといった対応方法はありません。手動でテクスチャを描画し直して、内容を復元する必要があります。
`onRestore` コールバックがここでも役にたつかもしれません。

[source, as3]
----
renderTexture.root.onRestore = function():void
{
    var contents:Sprite = getContents();
    renderTexture.clear(); // テクスチャの復元に必要
    renderTexture.draw(contents);
});
----

言いたい事はわかります。おそらく一つ以上のオブジェクトを描画していて、長い時間をかけて何度も描画された結果であったのだと。
例えば、お絵かきソフトでは _RenderTexture_ をキャンバスとして使い、たくさんのブラシストロークで絵が描かれている事でしょう。

そのような場合、最初から同じ手順で描画をし直せるように、必要な情報（操作手順）を保持しておく事が必要です。

お絵かきアプリの場合についてさらに考えるなら、どちらにしろそのアプリはアンドゥ・リドゥをサポートしたい所でしょう。
そのようなシステムを実装する場合、個々の処理内容を表すオブジェクトをリストの形式で保持しておくのが一般的です。
コンテキストロスの場合でも、その仕組みを再利用して、全ての描画操作を復元する事ができるでしょう。

さて、システムを実装する前に、意識しなくてはいけない潜在的な問題があります。
`root.onRestore` コールバックが呼ばれる際、たいていの場合全てのテクスチャがまだ利用できる状態ではないという事です。
やはり、それらも復元されなくてはならず、しばらく時間がかかるのです！

もしもテクスチャを _AssetManager_ を用いてロードしているのなら、そこはうまく扱ってくれます。
その際は代わりに、`TEXTURES_RESTORED` イベントを購読しましょう。
また、パフォーマンスを考慮して、`drawBundled` メソッドを間違いなく使うようにしましょう。

[source, as3]
----
assetManager.addEventListener(Event.TEXTURES_RESTORED, function():void
{
    renderTexture.drawBundled(function():void
    {
        for each (var command:DrawCommand in listOfCommands)
            command.redraw(); // `renderTexture.draw()` を実行します。
    });
});
----

NOTE: この場合は、クリア命令を実行する必要はありません。なぜなら、それが `onRestore` コールバックでのデフォルトの振る舞いで、それを変更してはいないので。
上記処理は別のコールバック(`Event.TEXTURES_RESTORED`)内であり、`onRestore` コールバックはデフォルトの振る舞いから変更されていない事を覚えておきましょう。
