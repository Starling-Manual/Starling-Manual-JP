== コンテキストロス

全ての Stage3D によるレンダリングは "レンダーコンテキスト" と呼ばれる _Context3D_ クラスのインスタンスを通して行われます。
レンダーコンテキストは、アクティブなテクスチャ一覧や頂点データなど、GPU の現在の設定を保持しています。
レンダーコンテキスト は GPU とのコネクションなのです。これがないと、Stage3D のレンダリングは何も行う事ができません。

ここで問題があります。このコンテキストはしばしば失われてしまうのです。
つまり、グラフィックスメモリー上にあった全てのデータへの参照を失うと言う事です。例えば、テクスチャが失われます。

そのようなコンテキストロス(紛失)は全てのシステムで同じ頻度で起こるわけではありません。 _iOS_ と _macOS_ ではほとんど再現せず、
_Windows_ は時々再現し、_Android_では頻繁に再現します。（画面を回転すると…再現！）
//原文：happens from time to time on _Windows_ and very often on _Android_ (rotating the screen? Bam!).
これが起こる事自体はどうする事もできないので、最悪のケースが起きる事を想定し、コンテキストロスにあらかじめ準備しておく事が必要です。

=== デフォルトの振る舞い

現在のコンテキストを紛失した事を Starling が認識すると、下記の一連の処理を実行します。

* Starling は自動で新しいコンテキストを作成し、今までと同じセッティングで初期化します、
* 全ての頂点及び頂点インデックスバッファを復元します。
* 全ての頂点シェーダーとピクセルシェーダーを再コンパイルします。
* テクスチャを可能な限り再ロードします。(メモリ/ディスク/その他から。)

バッファの内容とプログラムを元に戻すことは問題にはなりません。Starling は必要な全てのデータを保持しており、元に戻す時間も長くかかりません。
しかし、テクスチャに関しては頭の痛い問題です。
説明のため、最悪のケースの例を見てみましょう。テクスチャの生成に埋め込みビットマップを使っていた場合です。

[source, as3]
----
[Embed(source="hero.png")]
public static const Hero:Class;

var bitmap:Bitmap = new Hero();
var texture:Texture = Texture.fromBitmap(bitmap);
----

`Texture.fromBitmap` メソッドを呼び出した瞬間、ビットマップが GPU メモリにアップロードされます。つまりビットマップがコンテキストの一部になったと言うことです。
コンテキストが永久に存在すると信頼できるのなら、これでやる事は終了です。

しかし、そのように信頼する事はできません。テクスチャのデータはいつでもなくなりうるのです。
そのため、Starling はオリジナルのビットマップのコピーを保持します。
最悪の事態となった時、テクスチャを復元するために使われます。
この処理は自動で行われます。

驚くべきことに、１つのテクスチャが３箇所でメモリー上に存在することになります！

* "Hero" クラス内（通常のメモリー）
* コピーされているビットマップ（通常のメモリー）
* テクスチャ（グラフィックスメモリー）

モバイル端末などとてもメモリ量が制限されている場合、これは大惨事であると言えます。
このような状態は避けたいですね！
//原文：You don't want this to happen!

下記のようにコードを多少変更することで、若干問題を緩和する事が可能です。

[source, as3]
----
// 代わりに 'fromEmbeddedAsset' メソッドを使う。
var texture:Texture = Texture.fromEmbeddedAsset(Hero);
----

このようにすると、Starling は埋め込みクラスから直接テクスチャを再生成します。(`new Hero()` を呼び出します。）
つまりテクスチャはメモリー上に２箇所にか存在しない事になります。
埋め込みクラスに対しては、これがベストの対応です。

しかし、理想としては１箇所しかテクスチャをメモリー上に持ちたくありません。
そのためには、アセットを埋め込んではいけません。代わりに、ローカルもしくはリモートからアセットを読み込むようにします。
その場合 URL のみを保持すればよく、実際のデータは元の場所から再読み込みができるのです。

２つの方法があります。

* _AssetManager_ を用いてテクスチャのロードを行う。
* 手動でテクスチャを読み込み直す。

オススメはいつでも _AssetManager_ を使う事です。
メモリーを浪費する事なくコンテキストロスに対応する事ができます。
テクスチャを復元するためのどんな特別処理も記述する必要がなくなります。

しかし、裏で何が行われているか知る事は良い事です。
ひょっとすると、手動でテクスチャを復元せざるを得ない状況がありえるかもしれません。

=== テクスチャの手動復元

`Texture.fromEmbeddedAsset()` は実際にはどのように動いているのでしょうか。
このメソッドの考えられる実装をみてみましょう。

[source, as3]
----
public static function fromEmbeddedAsset(assetClass:Class):Texture
{
    var texture:Texture = Texture.fromBitmap(new assetClass());
    texture.root.onRestore = function():void
    {
        texture.root.uploadFromBitmap(new assetClass());
    };
    return texture;
}
----

`root.onRestore` コールバック内で重要な処理が行われている事がわかります。
しかし、`root` とは何でしょう？

知らないかもしれませんが、_テクスチャ_ のインスタンスを生成した際、それはしばしば実際の完全なテクスチャではないのです。
実はそれは、他のテクスチャの一部の領域への参照かもしれないのです。（それを _SubTexture_ といいます。）
`fromBitmap` メソッドを呼び出しでさえも、その参照を返します。
（しかし、その理由を説明するのは、このチャプターの範疇を超えてしまいます。）

いずれにしろ、`texture.root` は いつでも、_ConcreteTexture_ オブジェクトを返します。そして、そのオブジェクトには `onRestore` コールバックが存在します。
このコールバックはコンテキストロスの後に直接呼び出され、テクスチャを復元する機会を与えてくれます。

今回のコールバックの例では、もう一度同じビットマップをインスタンス化して、ルートテクスチャとしてアップロードしてやります。
さあ、テクスチャが復元されました！
//原文：Voilà, the texture is restored!

しかし、詳細な部分には悪魔が住んでいるものです。
`onRestore` コールバックは、知らぬ間に別のビットマップのコピーを保持してしまわないよう、厳重に慎重に作成しましょう。
ここに一見無害ではあるものの、実はとてもよろしくないコールバックの例があります。

[source, as3]
----
public static function fromEmbeddedAsset(assetClass:Class):Texture
{
    // このコードを実際に利用してはいけません！悪いコードの例です。
	
    var bitmap:Bitmap = new assetClass();
    var texture:Texture = Texture.fromBitmap(bitmap);
    texture.root.onRestore = function():void
    {
        texture.root.uploadFromBitmap(bitmap);
    };
    return texture;
}
----

良くない点があるのがわかりましたか？

問題は、このメソッドが _Bitmap_ オブジェクトを生成し、コールバック内で利用しているという事です。
このコールバックは、_クロージャー_ と呼ばれるもので、周辺の変数とともに保持されるインライン(関数内)の関数です。
//原文：that's an inline function that will be stored together with some of the variables that accompany it.
言い換えれば、メモリー上に関数オブジェクトが保持して、コンテキストロス発生時に呼び出される事が出来るようにします。
そして、はっきりとそのように設定をしていないにも関わらず、ビットマップのインスタンスがその内部に保持されます。
（実際は、`bitmap` をコールバック内で利用する事によってそれを行なっているのです。）

元のコードでは、ビットマップは参照されず、コールバック内で _作成_ されています。
従ってクロージャーに `bitmap` インスランスが保持される事はないのです。
`assetClass` オブジェクトだけがコールバック内で参照されます。どちらにしろメモリー内にですが。

このテクニックはどんなシナリオでも上手く働きます。

* テクスチャが URL からローヂされているのなら、その URL を使ってコールバック内で読み込み直します。
* それが ATF テクスチャであってもやり方は同じです。異なるのは `root.uploadATFData` メソッドを代わりに使うだけです。
* 従来の Flash のディスプレイオブジェクトのレンダリングをビットマップとして使っている場合、
コールバック内では、そのディスプレイオブジェクトを新しいビットマップにレンダリングし直してください。
（Starling の _TextField_ クラスがちょうど同じように処理をしています。）
//原文：For a bitmap containing a rendering of a conventional display object,
//just reference that display object and draw it into a new bitmap in the callback.
//(That's just what Starling's _TextField_ class does.)

NOTE: 強調すると、_AssetManager_ はこのような処理をいい感じに自動で行なってくれます。ただどのようにそれが実装されているのか説明しておきたかったのです。
//原文：Let me emphasize: the _AssetManager_ does all this for you, so that's the way to go. I just wanted to show you how that is achieved.

=== Render Textures

Another area where a context loss is especially nasty: render textures.
Just like other textures, they will lose all their contents -- but there's no easy way to restore them.
After all, their contents is the result of any number of dynamic draw operations.

If the _RenderTexture_ is just used for eye candy (say, footprints in the snow), you might be able to just live with it getting cleared.
If its contents is crucial, on the other hand, you need a solution for this problem.

There's no way around it: you will need to manually redraw the texture's complete contents.
Again, the `onRestore` callback could come to the rescue:

[source, as3]
----
renderTexture.root.onRestore = function():void
{
    var contents:Sprite = getContents();
    renderTexture.clear(); // required on texture restoration
    renderTexture.draw(contents);
});
----

I hear you: it's probably more than just one object, but a bunch of draw calls executed over a longer period.
For example, a drawing app with a _RenderTexture_-canvas, containing dozens of brush strokes.

In such a case, you need to store sufficient information about all draw commands to be able to reproduce them.

If we stick with the drawing app scenario, you might want to add support for an _undo/redo_ system, anyway.
Such a system is typically implemented by storing a list of objects that encapsulate individual commands.
You can re-use that system in case of a context loss to restore all draw operations.

Now, before you start implementing this system, there is one more gotcha you need to be aware of.
When the `root.onRestore` callback is executed, it's very likely that not all of your textures are already available.
After all, they need to be restored, too, and that might take a while!

If you loaded your textures with the _AssetManager_, however, it has got you covered.
In that case, you can listen to its `TEXTURES_RESTORED` event instead.
Also, make sure to use `drawBundled` for optimal performance.

[source, as3]
----
assetManager.addEventListener(Event.TEXTURES_RESTORED, function():void
{
    renderTexture.drawBundled(function():void
    {
        for each (var command:DrawCommand in listOfCommands)
            command.redraw(); // executes `renderTexture.draw()`
    });
});
----

NOTE: This time, there is no need to call clear, because that's the default behavior of `onRestore`, anyway -- and we did not modify that.
Remember, we are in a different callback here (`Event.TEXTURES_RESTORED`), and `onRestore` has not been modified from its default implementation.
