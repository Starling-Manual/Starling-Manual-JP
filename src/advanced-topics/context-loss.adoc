== コンテキストロス

Stage3D によるレンダリングは、全て "レンダーコンテキスト" と呼ばれる _Context3D_ クラスのインスタンスを通して行われます。
レンダーコンテキストは、アクティブなテクスチャの一覧や頂点データなど、GPU の現在の設定を保持しています。
レンダーコンテキスト は GPU とのコネクションです。これがないと、Stage3D のレンダリングを行う事ができません。

ここで問題があります。このコンテキストはしばしば失われてしまうのです。
つまり、グラフィックスメモリ上にあった全てのデータへの参照を失うと言う事です。例として、テクスチャも失われます。

そのようなコンテキストの紛失 (コンテキストロス) は全てのシステムで同じ頻度で起こるわけではありません。
_iOS_ と _macOS_ ではほとんど再現せず、_Windows_ は時々再現し、_Android_ では頻繁に再現します。（画面を回転するだけで再現します！）
//原文：happens from time to time on _Windows_ and very often on _Android_ (rotating the screen? Bam!).
これが起きてしまう事自体はどうしようもないので、最悪のケースが起きる事を想定し、コンテキストロスにあらかじめ準備しておく事が必要です。

=== デフォルトの振る舞い

現在のコンテキストを紛失した事を Starling が認識すると、下記のような一連の処理を実行します。

* Starling は自動で新しいコンテキストを作成し、それまでと同じ設定で初期化します、
* 全ての頂点及び頂点インデックスバッファを復元します。
* 全ての頂点シェーダーとピクセルシェーダーを再コンパイルします。
* テクスチャを可能な限り再ロードします。(メモリ/ディスク/その他から)

バッファの内容とプログラムを元に戻すことは問題ではありません。Starling は必要な全てのデータを保持しており、すぐに元に戻す事ができます。
しかし、テクスチャに関しては頭の痛い問題です。
最悪のケースの例を見てみましょう。テクスチャの生成に埋め込みビットマップを使っている場合の例です。

[source, as3]
----
[Embed(source="hero.png")]
public static const Hero:Class;

var bitmap:Bitmap = new Hero();
var texture:Texture = Texture.fromBitmap(bitmap);
----

`Texture.fromBitmap` メソッドを呼び出した時は、ビットマップが GPU メモリにアップロードされます。
つまりビットマップがコンテキストの一部になったと言うことです。
コンテキストが永久に存在すると信頼できるのなら、これ以外にやる事はありません。

しかし、実際にはそのような信頼はありまません。テクスチャのデータはいつでもなくなりうるのです。
そのため、Starling はオリジナルのビットマップのコピーを作って保持しておきます。
最悪の事態となった時、テクスチャを復元するためにそのコピーが使われます。この処理は自動で行われます。

驚くべきことに、１つのテクスチャがメモリ上３箇所に存在することになります！

* "Hero" クラス内（通常のメモリ）
* コピーされているビットマップ（通常のメモリ）
* テクスチャ（グラフィックスメモリ）

モバイル端末など、メモリ量がかなり制限されている場合、これは大問題であると言えます。
このような状態は避けたいものです！
//原文：You don't want this to happen!

下記のようにコードを多少変更することで、問題を若干ですが緩和する事が可能です。

[source, as3]
----
// 代わりに 'fromEmbeddedAsset' メソッドを使う。
var texture:Texture = Texture.fromEmbeddedAsset(Hero);
----

このようにすると、Starling は埋め込みクラスから直接テクスチャを再生成します。(`new Hero()` を呼び出します。）
つまりテクスチャはメモリ上に２箇所しか存在しない事になります。
埋め込みクラスに対しては、これがベストの対応です。

しかし、理想としてはメモリ上１箇所だけにテクスチャを持ちたい所です。
そのためには、アセットを埋め込んではいけません。代わりに、ローカルもしくはリモートからアセットを読み込むようにします。
その場合 URL のみを保持すればよく、実際のデータは元の場所から再読み込みができるのです。

２つの方法があります。

* _AssetManager_ を用いてテクスチャのロードを行う。
* 手動でテクスチャを読み込み直す。

推奨する方法はいつでも _AssetManager_ を使う事です。
メモリを浪費する事なくコンテキストロスに対応する事ができます。
テクスチャを復元するための特別処理を全く記述する必要がなくなります。

しかし、内部で何が行われているか知るのは良い事です。
ひょっとすると、手動でテクスチャを復元せざるを得ない状況がありえるかもしれません。

=== テクスチャの手動復元

`Texture.fromEmbeddedAsset()` は実際どのように動いているのでしょうか。
このメソッドの考えられる実装をみてみましょう。

[source, as3]
----
public static function fromEmbeddedAsset(assetClass:Class):Texture
{
    var texture:Texture = Texture.fromBitmap(new assetClass());
    texture.root.onRestore = function():void
    {
        texture.root.uploadFromBitmap(new assetClass());
    };
    return texture;
}
----

`root.onRestore` コールバック内で重要な処理が行われている事がわかります。
しかし、`root` と書いているのは何でしょう？

実は、_テクスチャ_ のインスタンスを生成した際、それはしばしば実際の完全なテクスチャではないのです。
他のテクスチャの一部の領域への参照かもしれません。（それを _SubTexture_ と言います。）
`fromBitmap` メソッドを呼び出しでさえも、その参照を返します。
（しかし、その理由を説明するのは、このチャプターの範疇を超えてしまいます。）

いずれにしろ、`texture.root` は いつでも、_ConcreteTexture_ オブジェクトを返します。そして、そのオブジェクトには `onRestore` コールバックが存在します。
このコールバックはコンテキストロスの後に直接呼び出され、テクスチャを復元する機会を与えてくれます。

今回のコールバック例では、もう一度同じビットマップをインスタンス化して、ルートテクスチャとしてアップロードしてやります。
さあ、テクスチャが復元されました！
//原文：Voilà, the texture is restored!

しかし、細部には悪魔が住んでいるものです。
`onRestore` コールバックが、知らぬ間に別のビットマップのコピーを保持してしまわないよう、厳重にコードを記述しましょう。
ここに一見無害ではあるものの、実はとてもよくないコールバックのコード例があります。

[source, as3]
----
public static function fromEmbeddedAsset(assetClass:Class):Texture
{
    // このコードを実際に利用してはいけません！悪いコードの例です。
	
    var bitmap:Bitmap = new assetClass();
    var texture:Texture = Texture.fromBitmap(bitmap);
    texture.root.onRestore = function():void
    {
        texture.root.uploadFromBitmap(bitmap);
    };
    return texture;
}
----

好ましくない部分がどこだかわかりましたか？

問題は、このメソッドが _Bitmap_ オブジェクトを生成し、コールバック内でそれを利用しているという事です。
このコールバックは、_クロージャー_ と呼ばれるもので、周辺の変数とともに保持されるインライン(関数内)の関数です。
//原文：that's an inline function that will be stored together with some of the variables that accompany it.
言い換えれば、メモリ上に関数オブジェクトが保持して、コンテキストロス発生時に呼び出される事が出来るようにします。
そして、はっきりとそのように設定をしていないにも関わらず、ビットマップのインスタンスがその内部に保持されます。
（実際は、`bitmap` をコールバック内で利用する事によってメモリに保持する行為しているのです。）

元のコードでは、ビットマップは参照されず、コールバック内で _作成_ されています。
従ってクロージャーに `bitmap` インスランスが保持される事はないのです。
`assetClass` オブジェクトだけがコールバック内で参照されます。どちらにしろメモリ内にですが。

このテクニックはどんなシナリオでもうまく働きます。

* テクスチャが URL からロードされているのなら、その URL を使ってコールバック内でビットマップを読み込み直します。
* それが ATF テクスチャであってもやり方は同じです。異なるのは `root.uploadATFData` メソッドを代わりに使うだけです。
* 従来の Flash のディスプレイオブジェクトのレンダリングをビットマップとして使っている場合、
コールバック内では、そのディスプレイオブジェクトを新しいビットマップにレンダリングし直してください。
（Starling の _TextField_ クラスがちょうどそのような処理をしています。）
//原文：For a bitmap containing a rendering of a conventional display object,
//just reference that display object and draw it into a new bitmap in the callback.
//(That's just what Starling's _TextField_ class does.)

NOTE: 強調しますが、_AssetManager_ はこの処理を自動でよしなに行なってくれます。
ここでは、ただそれがどのように実装されているのかを説明しておきたかったのです。
//原文：Let me emphasize: the _AssetManager_ does all this for you, so that's the way to go. I just wanted to show you how that is achieved.

=== レンダーテクスチャー

レンダーテクスチャに関しても、コンテキストロスが悩ましい所です。
他のテクスチャと同じように、レンダーテクスチャも内容を失う事がありえます。しかし、簡単にそれを復元する方法が存在しないのです。
結局、レンダーテクスチャの内容というのは、動的なたくさんの描画処理の結果なのですから。

もしも、_レンダーテクスチャー_ が見た目を賑やかす用途だけで使われているのなら（例えば雪面の足跡など）、
全てを消し去った状態そのままとしてしまうのでも良いかもしれません。
しかし、その内容がとても重要であるのなら、この問題はなんとか解決しなくてはいけません。

実際には、特にこれといった良い対応方法はありません。手動でテクスチャを描画し直して、内容を復元する必要があります。
`onRestore` コールバックがここでも役にたつかもしれません。

[source, as3]
----
renderTexture.root.onRestore = function():void
{
    var contents:Sprite = getContents();
    renderTexture.clear(); // テクスチャの復元に必要
    renderTexture.draw(contents);
});
----

言いたい事はわかります。おそらくは、オブジェクト一つだけでなく、長い時間をかけてたくさんのオブジェクトを何度も描画していたのだと。
例えば、お絵かきソフトでは _RenderTexture_ をキャンバスとして使い、たくさんのブラシストロークの重ね合わせで絵が描かれている事でしょう。

そのような場合、最初から同じ手順で実行し直せるように、必要な情報（操作手順）を保持しておく事が必要です。

さらにお絵かきアプリの場合について考えるなら、どちらにしろそのアプリはアンドゥ・リドゥをサポートしたい所です。
そのようなアンドゥ・リドゥのシステムを実装する場合、個々の処理内容を表すオブジェクトをリストの形式で保持しておくのが一般的です。
コンテキストロスの場合でも、その仕組みを再利用して、全ての描画操作を復元する事ができるでしょう。

さて、システムを実装する前に、意識しなくてはいけない潜在的な問題があります。
`root.onRestore` コールバックが呼ばれる際、たいていの場合で全てのテクスチャがまだ利用できる状態ではないという事です。
それらも同様に復元されなくてはならず、それにはしばらく時間がかかるのです！

もしもテクスチャを _AssetManager_ を用いてロードしているのなら、そのあたりは自動でうまく処理してくれます。
その際は代わりに、`TEXTURES_RESTORED` イベントを購読しましょう。
また、パフォーマンスを考慮して、`drawBundled` メソッドを忘れずに使うようにしましょう。

[source, as3]
----
assetManager.addEventListener(Event.TEXTURES_RESTORED, function():void
{
    renderTexture.drawBundled(function():void
    {
        for each (var command:DrawCommand in listOfCommands)
            command.redraw(); // `renderTexture.draw()` を実行します。
    });
});
----

NOTE: この場合は、クリア命令を実行する必要はありません。なぜなら、それが `onRestore` コールバックでのデフォルトの振る舞いであって、それを変更しているわけではないので。
上記処理は別のコールバック (`Event.TEXTURES_RESTORED`) であり、`onRestore` コールバックはデフォルトの振る舞いから変更されていない事を覚えておきましょう。
