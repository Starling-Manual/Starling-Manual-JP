== メモリ管理

たくさんの Starling デベロッパーがアプリやゲームをモバイル向けに作るためにこのフレームワークを利用しています。
そして遅かれ早かれそのほとんど全員が、開発に苦労して、モバイル端末は嫌になるほどメモリが少ないと言う事を知ります。
なぜでしょう？

* ほとんどのモバイル端末はとても高い解像度のスクリーンを持ちます。
* そのような端末で2Dゲームを動かす場合、同様に高い解像度のテクスチャが必要になります。
* 利用可能な RAM 容量は、テクスチャデータ全てを保持するには少なすぎるのです。

つまり、ハードウェア的に見てひどい組み合わせだ、と言えるでしょう。

では、メモリが足りなくなった場合は どのような事が起きるでしょう？
ほとんどの場合、エラー番号 3691 (このリソース種類に対応するリソースを使い果たした) と言う、悪名高いエラーが起こり、アプリはクラッシュするでしょう。
下記に続くのは、このたちの悪いエラーを避けるためのヒントです。

=== 無駄なメモリ浪費をなくす

もしも、あるオブジェクトがその後必要とされないのなら、忘れずに `dispose` メソッドを呼んでやりましょう。
Flash のオブジェクトと異なり、ガベージコレクターは Stage3D リソースのメモリを掃除してくれません！
開発者自身がメモリ管理に責任を持つ必要があるのです。

==== テクスチャ

テクスチャは扱う様々なオブジェクトの中で最も重要なものです。
いつでもメモリ領域全体で一番大きな割合を占めるでしょう。

もちろん、Starling はこれの問題うまくカバーしようと働きます。
例えば、アトラステクスチャを扱う際は、アトラス側を廃棄するだけでよく、実際のサブテクスチャは廃棄する必要がありません。
アトラスは GPU メモリを必要とし、"部分部分" の各テクスチャはそのアトラスをただ参照するだけとなっています。

[source, as3]
----
var atlas:TextureAtlas = ...;
var hero:Texture = atlas.getTexture("hero");

atlas.dispose(); // この処理は "hero" テクスチャも同時に廃棄します。
----

==== ディスプレイオブジェクト

ディスプレイオブジェクト自体は多くのグラフィックメモリを必要としない（いくつかは全く必要としない）のですが、それでもきちんと廃棄するのは良い習慣と言えます。
特にテキストフィールドは大きなオブジェクトなので、慎重に扱いましょう。

ディスプレイオブジェクトコンテナは期待通りに、子孫要素全ての面倒も見てくれます。
コンテナを破棄すると、子孫のオブジェクトも同時に自動的に破棄されます。

[source, as3]
----
var parent:Sprite = new Sprite();
var child1:Quad = new Quad(100, 100, Color.RED);
var child2:Quad = new Quad(100, 100, Color.GREEN);

parent.addChild(child1);
parent.addChild(child2);

parent.dispose(); // この処理で子ディスプレイオブジェクトも破棄されます。
----

概して、最近のバージョンの Starling では、ディスプレイオブジェクトの破棄に関して、寛容になりました。
ほとんどのディスプレイオブジェクトはもはや Stage3D のリソースを保持していないので、ディスプレイオブジェクトを破棄するのを忘れたとしても大きな問題にはなりません。

==== イメージ

ここにまず最初の落とし穴が存在します。イメージを破棄してもテクスチャは破棄されません。

[source, as3]
----
var texture:Texture = Texture.fromBitmap(/* ... */);
var image:Image = new Image(texture);

image.dispose(); // ここでテクスチャは破棄されません！
----

なぜなら Starling は、このテクスチャを今後も利用する気があるのか、知りようがないからです。
実際、同じテクスチャを共有する別のイメージをすでに利用しているかもしれません。

逆に、そのテクスチャが他の場所で使われていない事を知っているのであれば、破棄してしまいましょう。

[source, as3]
----
image.texture.dispose();
image.dispose();
----

==== フィルター

フラグメントフィルターも多少デリケートです。
オブジェクトを破棄する時、同様にフィルターも破棄されます。

[source, as3]
----
var object:Sprite = createCoolSprite();
object.filter = new BlurFilter();
object.dispose(); // ここでフィルターも破棄されます。
----

しかし、下記のような似たコードではフィルターが破棄されないのです。

[source, as3]
----
var object:Sprite = createCoolSprite();
object.filter = new BlurFilter();
object.filter = null; // ここでフィルターは破棄 *されません。* 
----

もう一度言いますが、 Starling は、このフィルターを今後も利用する気があるのか、知りようがないのです。

しかし、実際にはこれは問題になりません。
フィルターが破棄されてなくても、Starling が全てのリソースを消去するからです。
よって、この操作でメモリリークを引き起こすことはありません。

NOTE: 以前の Starling のバージョン(2.0未満) では、この場合にメモリリークを起こします。

=== テクスチャを埋め込まない

`Embed` メタデータ設定を行い、ActionScript の開発者はビットマップを直接 swf ファイル内に埋め込んできたものです。
web コンテンツ作成においてこれはとても有効です。全てのデータを１つのファイルにまとめる事ができるのですから。

先の <<コンテキストロス>> セクションにて、Starling または一般的な Stage3D コンテンツでは、このアプローチがいくつか深刻な問題をはらんでいる事を確認しました。
１つのテクスチャデータがメモリ内に少なくとも２箇所、１箇所は通常の（グラフィックス用ではない）メモリに、もう１箇所はグラフィックスメモリに、存在してしまうのです。

[source, as3]
----
[Embed(source="assets/textures/hero.png")]
private static var Hero:Class; // <1>

var texture:Texture = Texture.fromEmbeddedAsset(Hero); // <2>
----
<1> このクラスは通常メモリ内に保持されます。
<2> このテクスチャはグラフィックメモリ内に保持されます。

このサンプルでは `Texture.fromEmbeddedAsset` メソッドを使ってテクスチャをロードしている事に注目してください。
<<コンテキストロス>> セクションでその理由は述べました。他の方法（`Texture.fromBitmap`）ではさらに余分なメモリを使ってしまうのです。

テクスチャを確実に１つしかメモリに保持しないように保障するたった一つの方法は、URL からそれをロードする事です。
画像の読み込みに _AssetManager_ を使っているなら、大した手間にはなりません。

[source, as3]
----
var appDir:File = File.applicationDirectory;
var assets:AssetManager = new AssetManager();

assets.enqueue(appDir.resolvePath("assets/textures"));
assets.loadQueue(...);

var texture:Texture = assets.getTexture("hero");
----

=== RectangleTexture を使う

Starling の _Texture_ クラスは、実際は2つの Stage3D クラスの単なるラッパーです。

`flash.display3D.textures.Texture`:: どのプロファイルでも利用可能です。ミップマップとラッピングをサポートしますが、縦横のサイズが２の倍数である事が要求されます。
`flash.display3D.textures.RectangleTexture`:: `BASELINE` プロファイル以降で利用できます。ミップマップトラッピングをサポートしませんが、任意のサイズを取る事ができます。

あまり知られていないのですが、前者はちょっと変わった短所があります。必要であろうともなかろうと、いつでもミップマップ用のメモリを確保してしまうのです。
つまり、1/3 の分だけ余計にメモリを浪費している事になります！

それにより、後者の `RectangleTexture` を使う事が好まれます。
Starling は利用可能な場合、後者のタイプのテクスチャを優先して使います。

しかし、少なくとも `BASELINE` プロファイルで動作できる環境でないとそのような選択はできません。またミップマップが必要な場合も使えません。
１つ目の条件は 利用可能な Context3D プロファイルのうち、最も高度な物を選択する事で満たす事ができます。
これは、Starling のデフォルトのコンストラクタの振る舞いです。

[source, as3]
----
// このように Starling を初期化した場合、
... = new Starling(Game, stage);

// 下記の設定をしたのと同じ事になります。
... = new Starling(Game, stage, null, null, "auto", "auto");
----

最後の引数の `auto` は、Starling に 選択可能なプロファイルのうち、一番上位のものを使うように指定しています。
つまり、デバイスが RectangleTexture をサポートするなら、Starling はそれを優先して使うという事です。

ミップマップに関しては、要求された場合のみ作成されます。
いくつかの `Texture.from...` で始まるテクスチャ生成系のメソッドは、その指定パラメータを持っています。
そして、_AssetManager_ には `useMipMaps` プロパティが存在します。
デフォルトでは、ミップマップが無効になる設定になっています。

=== ATF テクスチャを使う

<<ATF テクスチャ>> に関しては、すでに考察しました。 しかし、このセクションでも、もう一度取り上げる意義があります。
GPU が JPG や PNG 圧縮のデータをそのまま使う事ができない事を思い出してください。
それらのファイルはテクスチャは一度展開され、非圧縮状態でグラフィックメモリにアップロードされます。

ATF テクスチャの場合は異なります。圧縮された状態のまま描画され、たくさんのメモリを節約します。
もしも ATF テクスチャのセクションを読み飛ばしてきたのなら、目を通しておく事をオススメします！

ATF テクスチャの悪い点は、もちろんですが、イメージのクオリティが劣化する事です。
しかし、全てのゲームに適用できるわけではありませんが、下記のようなテクニックを適用する事が可能です。

. 実際に必要な大きさより若干大きくテクスチャを生成する。
. ATF ツールで圧縮。
. ランタイムでは、実際に必要なサイズに縮小してテクスチャを利用する。

このやり方でも、かなりたくさんのメモリの節約が可能です。そして画質の劣化ははっきりとは確認できません。

=== 16ビットテクスチャを使う

ATF テクスチャが適切でない場合、おそらくアプリケーションでは色数が制限されたアニメ調の絵柄を用いているのかと思われます。
//原文：If ATF textures don't work for you, chances are that your application uses a comic-style with a limited color palette.
良いニュースがあります。そのようなタイプのテクスチャでは、また別の解決方法が適用できます！

* デフォルトのテクスチャフォーマット (`Context3DTextureFormat.BGRA`) はピクセルごとに32ビット（１つのチャンネルに8ビット)の容量を使います。
* それとは別のフォーマット (`Context3DTextureFormat.BGRA_PACKED`) が存在し、こちらは半分のサイズ、ピクセルごとに16ビット（１つのチャンネルに4ビット)の容量を使います。

Starling ではこのフォーマットを `Texture.from...` 系のメソッドの `format` 引数で指定するか、AssetManager の `textureFormat` プロパティで指定する事ができます。
これにより 50% ものメモリを節約する事ができます！

当然、この処理は画像のクオリティの低下も招きます。
もしもグラーデーションを利用しているのなら、16ビットテクスチャはむしろ汚くなります。
しかし、ディザリングを使う事でその問題を解決する事ができます。

.ディザリングで色深度が減った事をカバーする事ができます。
image::dithering.png[Dithering]

わかりやすくするため、上記のサンプルのグラデーションはたったの16色(4ビット)まで減色されています。
このような少ない色数でも、ディザリングで画像のクオリティが受け入れられるレベルに保つ事ができます。

大抵の画像編集ソフトでは、色深度を減らす際に自動でディザリングを適用してくれます。
_TexturePacker_ でも、それを行う事が可能です。

_AssetManager_ は読み込みファイルごとに、適切な色深度を選択するように設定する事ができます。
//原文：The _AssetManager_ can be configured to select a suitable color depth on a per-file basis.

[source, as3]
----
var assets:AssetManager = new AssetManager();

// 16bitテクスチャをキューに積む
assets.textureFormat = Context3DTextureFormat.BGRA_PACKED;
assets.enqueue(/* ... */);

// 32bitテクスチャをキューに積む
assets.textureFormat = Context3DTextureFormat.BGRA;
assets.enqueue(/* ... */);

// 読み込みの開始
assets.loadQueue(/* ... */);
----

=== ミップマップを避ける

ミップマップは元となるテクスチャを縮小したバージョンの事です。レンダリングのスピードを上げつつ、エイリアシングを軽減する目的で使われます。

.ミップマップを持つテクスチャの例。
image::mipmap.jpg[Mipmap]

Starling のバージョン2からは、デフォルトでミップマップを生成しない仕様となりました。
デフォルト設定として好ましい事がわかったからです。なぜなら、

* テクスチャの読み込みが速い。
* テクスチャが使うメモリ量が少ない。（オリジナルのピクセル分だけで済みます。）
* ぼやけた描画になる事を避ける事ができる。（ミップマップはしばしば曖昧な見た目を生じます。）

一方で、ミップマップを有効とするとオブジェクトがかなり縮小されていた場合は、描画速度が著しく上がります。
そして表示にエイリアシングがかかる事を避ける事ができます。（エイリアスとぼやけは正反対のものです。）
ミップマップを有効にするには、`Texture.from...` 系のメソッドで対応するパラメータを設定してください。

=== ビットマップフォントを使う

すでに議論されましたが、テキストフィールドでは２種類のフォントをサポートします。TrueType フォントと、ビットマップフォントです。

TrueType フォントはとても簡単に使えますが、いくつかの短所も持っています。

* テキストを変更するたびに、新しくテクスチャが生成されグラフィックメモリーにアップロードされます。これは時間がかかる処理です。
* たくさんのテキストフィールドを生成したり、大きなものを生成した場合、たくさんのテクスチャメモリが必要となります。

一方で、ビットマップフォントは、

* 更新が高速です。
* 必要なメモリ量は一定です。（あらかじめ用意した glyph テクスチャのみとなります。）

これらの理由で、Starling 内にテキストを表示する方法として好ましいのです。
個人的には、いつでもビットマップフォントを使う事をオススメします！

TIP: ビットマップフォントは16ビットテクスチャを適用する候補として適切です。なぜなら大抵は白一色データが、テキストフィールド設定色にランタイムで着色されるからです。

=== テクスチャアトラスを最適化する

できる限りコンパクトにテクスチャアトラスをパックする事はとても重要な事でしょう。
https://www.codeandweb.com/texturepacker/starling?source=gamua[TexturePacker] のようなツールでは下記のようなオプション指定が可能です。

* 周辺の透明部分をトリムする。
* より効率よくパックする場合、テクスチャを90度回転して扱う。
* カラーの深度を減らす。（上の考察を参照。）
* 重複する画像を削除する。
* その他。

これらの機能をぜひ利用しましょう！
たくさんのテクスチャを１枚のアトラスに収める事で、メモリ全体の浪費を抑えるだけでなく、ドローコールの回数も抑える事ができます。
（詳しくは次のチャプターで取り扱います。）

[[memory_management_scout]]
//パフォチューノページと記載を合わせる 英語のままでいい

=== Adobe Scout を使う

https://www.adobe.com/products/scout.html[Adobe Scout] は、軽量かつ包括的な ActionScript と Stage3D のためのプロファイリングツールです。
どんな Flash または AIR アプリケーションに対して、モバイル端末上で動いていようともブラウザで動いていようとも、コードの変更なしに素早くプロファイリングを行う事ができます。
そして、Adobe Scout は素早く効率的にパフォーマンスに影響を与えうる問題を検出します。

Scout を使うと、パフォーマンスのボトルネックになる ActionScript のコードを見つけられるだけでなく、
時間とともに散り積もって行く通常メモリ及びグラフィックメモリの浪費についての詳細を知る事もできます。
非常に素晴らしい事です！

NOTE: Adobe Scout は、Adobe Creative Cloud メンバーシップの _無料_ 契約があれば利用する事ができます。ツールを入手するために有料の契約を結ぶ必要はありません。
次のリンクは Thibault Imbert 氏による、Adobe Scout をどのように使うかの詳細を説明する素晴らしい内容のチュートリアルビデオです。
http://www.adobe.com/devnet/scout/articles/adobe-scout-getting-started.html[Getting started with Adobe Scout]

.Adobe Scout
image::scout-screenshot.png[Adobe Scout]

=== 常にStat表示を確認する

Stat表示 (`starling.showStats` メソッドを実行すると表示されます。) には、通常メモリとグラフィックスメモリの情報がともに含まれています。
開発中はそれらの値に注目し続ける価値があります。

そうですね、しばしば通常メモリの値は誤解される事があります。ガベージコレクションがいつ起こるかは、わからないのです。
一方、グラフィックメモリに関してはとても正確な値が表示されます。 
テクスチャを作ると、メモリ使用量が上がります。テクスチャを破棄すると使用量が下がります。これはすぐさま確認できます。

実際、この機能を Starling に追加した時、Starling のデモアプリにメモリリークを発見するのに５分ほどしかかかりませんでした。
//原文：Actually, when I added this feature to Starling, it took about five minutes and I had already found the first memory leak -- in Starling's demo app.
その際は、下記のようなアプローチで利用しました。

* メインメニューにて、GPUメモリの利用率を測定します。
* デモシーンに１つづつ移動します。
* メインメニューに戻るたびに、GPUメモリが元の値に戻っているかを確認します。
* あるシーンから戻ってきた際、メモリ量が元に戻りませんでした。実際、コードレビューをしてみると、一つテクスチャを破棄し忘れているのがわかりました。

.Stat表示で現在のメモリ利用量が確認できます。
image::stats-display.png[The statistics display]

言うまでもなく、Adobe Scout では、さらに詳細なメモリ利用量を測定できます。
しかし、Stat表示はいつでも利用する事ができるので、それがなければ簡単に見過ごしてしまうような事をも過ごさずに済むのです。
