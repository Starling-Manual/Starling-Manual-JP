== メモリ管理

たくさんの Starling デベロッパーがアプリやゲームをモバイル向けに作るためにフレームワークを利用しています。
そしてそのうちほとんど全員が、遅かれ早かれモバイル端末は悪い噂になるほどメモリが少ないと言う事に苦労しながら気がつきます。
なぜでしょう？

* ほとんどのモバイル端末はとても高い解像度のスクリーンを持ちます。
* そのような端末で2Dゲームを動かす場合、同様に高い解像度のテクスチャが必要になります。
* 利用可能な RAM はそのテクスチャデータ全てを保持するには少なすぎるのです。

つまりは、ひどい組み合わせだ、と言えるでしょう。

では、メモリが足りなくなった場合は どのような事が起きるでしょう？
ほとんどの場合、エラー番号 3691 (このリソース種類ためのリソースを使い果たした) と言う、有名なエラーが生じて、アプリはクラッシュするでしょう。
下記に続くヒントは、このタチの悪いエラーを避けるための方法を示すものとなります。

=== 無駄なメモリ浪費をなくす

もしも、あるオブジェクトがもう必要ないのなら、忘れずに `dispose` メソッドを呼んでやりましょう。
Flash のオブジェクトと異なり、ガベージコレクターは Stage3D のリソースのメモリを掃除してくれません！
メモリ管理に開発者自身が責任を持つのです。

==== テクスチャ

テクスチャは扱うオブジェクトの中で最も重要なものです。
いつでもメモリ領域のうち、一番大きな割合を占める事でしょう。

Starling はもちろん、この事をうまくカバーできるように働きます。
例えば、アトラスからテクスチャをロードする際、アトラスを廃棄数るだけでよく、実際のサブテクスチャを廃棄する必要はありません。
アトラスは GPU メモリだけを必要とし、"部分部分" のテクスチャはただそのアトラステクスチャを参照するだけになります。

[source, as3]
----
var atlas:TextureAtlas = ...;
var hero:Texture = atlas.getTexture("hero");

atlas.dispose(); // この処理は "hero" テクスチャも同時に廃棄します。
----

==== ディスプレイオブジェクト

ディスプレイオブジェクト自体はたくさんのグラフィックメモリを必要としない（そのうちいくつかは全く必要としない）のですが、やはりそれらを廃棄するのは良い習慣と言えます。
特にテキストフィールドなどが大きなオブジェクトですので慎重に扱いましょう。

ディスプレイオブジェクトコンテナは期待通りに、子孫要素の面倒を全て見てくれます。
コンテナを破棄すると、子孫のオブジェクトも自動的に同時に破棄されます。

[source, as3]
----
var parent:Sprite = new Sprite();
var child1:Quad = new Quad(100, 100, Color.RED);
var child2:Quad = new Quad(100, 100, Color.GREEN);

parent.addChild(child1);
parent.addChild(child2);

parent.dispose(); // この処理で子ディスプレイオブジェクトも破棄されます。
----

概して、最近のバージョンの Starling では、ディスプレイオブジェクトの破棄に関して、寛容になりました。
ほとんどのディスプレイオブジェクトはもはや Stage3D のリソースを保持していないので、ディスプレイオブジェクトを破棄するのを忘れたとしても大ごとにはなりません。

==== イメージ

ここにまず最初の落とし穴が存在します。イメージを破棄してもテクスチャは破棄されません。

[source, as3]
----
var texture:Texture = Texture.fromBitmap(/* ... */);
var image:Image = new Image(texture);

image.dispose(); // ここでテクスチャは破棄されません！
----

なぜなら Starling は、このテクスチャを今後も利用する気があるのか、知りようがないからです。
実際、同じテクスチャを共有する別のイメージをすでに利用しているかもしれません。

逆に、もしもうこのテクスチャが他の場所で使われていない事がわかっているのであれば、破棄してしまいましょう。

[source, as3]
----
image.texture.dispose();
image.dispose();
----

==== フィルター

フラグメントフィルターもちょっとデリケートです。
オブジェクトを破棄する時、同様にフィルターも破棄されます。

[source, as3]
----
var object:Sprite = createCoolSprite();
object.filter = new BlurFilter();
object.dispose(); // ここでフィルターも破棄されます。
----

しかし、下記のような似たコードではフィルターが破棄されないのです。

[source, as3]
----
var object:Sprite = createCoolSprite();
object.filter = new BlurFilter();
object.filter = null; // ここでフィルターは破棄 *されません。* 
----

もう一度言いますが、 Starling は、このフィルターを今後も利用する気があるのか、知りようがないのです。

しかし、実際にはこれは問題になりません。
フィルターが破棄されてなくても、Starling が全てのリソースを消去するからです。
よって、この操作でメモリリークを引き起こすことはありません。

NOTE: 以前の Starling のバージョン(2.0未満) では、この場合メモリリークを起こします。

=== テクスチャを埋め込まない

`Embed` メタデータ指定を使って、ActionScript の開発者はいつもビットマップを直接 swf ファイル内に埋め込んできたものです。
web コンテンツ作成においてこれはとても有効です。全てのデータを１つのファイルにまとめる事ができるのですから。

先の <<コンテキストロス>> セクションにて、Starling または一般的な Stage3D コンテンツでは、このアプローチがいくつか深刻な問題をはらんでいる事を確認しました。
テクスチャがメモリ内に少なくとも２つ（１つは通常メモリ、１つはグラフィックスメモリ）存在してしまうのです。

[source, as3]
----
[Embed(source="assets/textures/hero.png")]
private static var Hero:Class; // <1>

var texture:Texture = Texture.fromEmbeddedAsset(Hero); // <2>
----
<1> このクラスは通常のメモリ内に保持されます。
<2> このテクスチャはグラフィックメモリ内に保持されます。

このサンプルでは `Texture.fromEmbeddedAsset` メソッドを使ってテクスチャをロードしている事に注目してください。
<<コンテキストロス>> セクションでその理由は述べました。他の方法（`Texture.fromBitmap`）ではさらに余分なメモリを使ってしまうのです。

テクスチャを確実に１つしかメモリに保持しないように保障するたった一つの方法は、URL からそれをロードする事です。
画像の読み込みに _AssetManager_ を使っているなら、大した手間にはなりません。

[source, as3]
----
var appDir:File = File.applicationDirectory;
var assets:AssetManager = new AssetManager();

assets.enqueue(appDir.resolvePath("assets/textures"));
assets.loadQueue(...);

var texture:Texture = assets.getTexture("hero");
----

=== Use RectangleTextures

Starling's _Texture_ class is actually just a wrapper for two Stage3D classes:

`flash.display3D.textures.Texture`:: Available in all profiles. Supports mipmaps and wrapping, but requires side-lengths that are powers of two.
`flash.display3D.textures.RectangleTexture`:: Available beginning with `BASELINE` profile. No mipmaps, no wrapping, but supports arbitrary side-lengths.

The former (`Texture`) has a strange and little-known side effect: it will always allocate memory for mipmaps, whether you need them or not.
That means that you will waste about one third of texture memory!

Thus, it's preferred to use the alternative (`RectangleTexture`).
Starling will use this texture type whenever possible.

However, it can only do that if you run at least in `BASELINE` profile, and if you disable mipmaps.
The first requirement can be fulfilled by picking the best available Context3D profile.
That happens automatically if you use Starling's default constructor.

[source, as3]
----
// init Starling like this:
... = new Starling(Game, stage);

// that's equivalent to this:
... = new Starling(Game, stage, null, null, "auto", "auto");
----

The last parameter (`auto`) will tell Starling to use the best available profile.
This means that if the device supports RectangleTextures, Starling will use them.

As for mipmaps: they will only be created if you explicitly ask for them.
Some of the `Texture.from...` factory methods contain such a parameter, and the _AssetManager_ features a `useMipMaps` property.
Per default, they are always disabled.

=== Use ATF Textures

We already talked about <<ATF Textures>> previously, but it makes sense to mention them again in this section.
Remember, the GPU cannot make use of JPG or PNG compression; those files will always be decompressed and uploaded to graphics memory in their uncompressed form.

Not so with ATF textures: they can be rendered directly from their compressed form, which saves a lot of memory.
So if you skipped the ATF section, I recommend you take another look!

The downside of ATF textures is the reduced image quality, of course.
But while it's not feasible for all types of games, you can try out the following trick:

. Create your textures a little bigger than what's actually needed.
. Now compress them with the ATF tools.
. At runtime, scale them down to their original size.

You'll still save a quite a bit of memory, and the compression artifacts will become less apparent.

=== Use 16 bit Textures

If ATF textures don't work for you, chances are that your application uses a comic-style with a limited color palette.
I've got good news for you: for these kinds of textures, there's a different solution!

* The default texture format (`Context3DTextureFormat.BGRA`) uses 32 bits per pixel (8 bits for each channel).
* There is an alternative format (`Context3DTextureFormat.BGRA_PACKED`) that uses only half of that: 16 bits per pixel (4 bits for each channel).

You can use this format in Starling via the `format` argument of the `Texture.from...` methods, or via the AssetManager's `textureFormat` property.
This will save you 50% of memory!

Naturally, this comes at the price of a reduced image quality.
Especially if you're making use of gradients, 16 bit textures might become rather ugly.
However, there's a solution for this: dithering!

.Dithering can conceal a reduced color depth.
image::dithering.png[Dithering]

To make it more apparent, the gradient in this sample was reduced to just 16 colors (4 bits).
Even with this low number of colors, dithering manages to deliver an acceptable image quality.

Most image processing programs will use dithering automatically when you reduce the color depth.
_TexturePacker_ has you covered, as well.

The _AssetManager_ can be configured to select a suitable color depth on a per-file basis.

[source, as3]
----
var assets:AssetManager = new AssetManager();

// enqueue 16 bit textures
assets.textureFormat = Context3DTextureFormat.BGRA_PACKED;
assets.enqueue(/* ... */);

// enqueue 32 bit textures
assets.textureFormat = Context3DTextureFormat.BGRA;
assets.enqueue(/* ... */);

// now start the loading process
assets.loadQueue(/* ... */);
----

=== Avoid Mipmaps

Mipmaps are downsampled versions of your textures, intended to increase rendering speed and reduce aliasing effects.

.Sample of a texture with mipmaps.
image::mipmap.jpg[Mipmap]

Since version 2.0, Starling doesn't create any mipmaps by default.
That turned out to be the preferable default, because without mipmaps:

* Textures load faster.
* Textures require less texture memory (just the original pixels, no mipmaps).
* Blurry images are avoided (mipmaps sometimes become fuzzy).

On the other hand, activating them will yield a slightly faster rendering speed when the object is scaled down significantly, and you avoid aliasing effects (i.e. the effect contrary to blurring).
To enable mipmaps, use the corresponding parameter in the `Texture.from...` methods.

=== Use Bitmap Fonts

As already discussed, TextFields support two different kinds of fonts: TrueType fonts and Bitmap Fonts.

While TrueType fonts are very easy to use, they have a few downsides.

* Whenever you change the text, a new texture has to be created and uploaded to graphics memory. This is slow.
* If you've got many TextFields or big ones, this will require a lot of texture memory.

Bitmap Fonts, on the other hand, are

* updated very quickly and
* require only a _constant_ amount of memory (just the glyph texture).

That makes them the preferred way of displaying text in Starling.
My recommendation is to use them whenever possible!

TIP: Bitmap Font textures are a great candidate for 16 bit textures, because they are often just pure white that's tinted to the actual TextField color at runtime.

=== Optimize your Texture Atlas

It should be your top priority to pack your texture atlases as tightly as possible. Tools like https://www.codeandweb.com/texturepacker/starling?source=gamua[TexturePacker] have several options that will help with that:

* Trim transparent borders away.
* Rotate textures by 90 degrees if it leads to more effective packing.
* Reduce the color depth (see above).
* Remove duplicate textures.
* etc.

Make use of this!
Packing more textures into one atlas not only reduces your overall memory consumption, but also the number of draw calls (more on that in the next chapter).

[[memory_management_scout]]
//パフォチューノページと記載を合わせる 英語のままでいい

=== Use Adobe Scout

https://www.adobe.com/products/scout.html[Adobe Scout] is a lightweight but comprehensive profiling tool for ActionScript and Stage3D.
Any Flash or AIR application, regardless of whether it runs on mobile devices or in browsers, can be quickly profiled with no change to the code -- and Adobe Scout quickly and efficiently detects problems that could affect performance.

With Scout, you can not only find performance bottlenecks in your ActionScript code, but you'll also find a detailed roundup of your memory consumption over time, both for conventional and graphics memory.
This is priceless!

NOTE: Adobe Scout is part of the _free_ version of Adobe's Creative Cloud membership. You don't have to become a paying subscriber of CC to get it.

Here is a great tutorial from Thibault Imbert that explains in detail how to work with Adobe Scout: http://www.adobe.com/devnet/scout/articles/adobe-scout-getting-started.html[Getting started with Adobe Scout]

.Adobe Scout
image::scout-screenshot.png[Adobe Scout]

=== Keep an Eye on the Statistics Display

The statistics display (available via `starling.showStats`) includes information about both conventional memory and graphics memory.
It pays off to keep an eye on these values during development.

Granted, the conventional memory value is often misleading -- you never know when the garbage collector will run.
The graphics memory value, on the other hand, is extremely accurate.
When you create a texture, the value will rise; when you dispose a texture, it will decrease -- immediately.

Actually, when I added this feature to Starling, it took about five minutes and I had already found the first memory leak -- in Starling's demo app.
I used the following approach:

* In the main menu, I noted down the used GPU memory.
* Then I entered the demos scenes, one after another.
* Each time I returned to the main menu, I checked if the GPU memory had returned to the original value.
* After returning from one of the scenes, that value was not restored, and indeed: a code review showed that I had forgotten to dispose one of the textures.

.The statistics display shows the current memory usage.
image::stats-display.png[The statistics display]

Needless to say: Scout offers far more details on memory usage.
But the simple fact that the statistics display is always available makes it possible to find things that would otherwise be easily overlooked.
