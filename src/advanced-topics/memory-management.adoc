== メモリ管理

たくさんの Starling デベロッパーがアプリやゲームをモバイル向けに作るためにフレームワークを利用しています。
そしてそのうちほとんど全員が、遅かれ早かれモバイル端末は悪い噂になるほどメモリが少ないと言う事に苦労しながら気がつきます。
なぜでしょう？

* ほとんどのモバイル端末はとても高い解像度のスクリーンを持ちます。
* そのような端末で2Dゲームを動かす場合、同様に高い解像度のテクスチャが必要になります。
* 利用可能な RAM はそのテクスチャデータ全てを保持するには少なすぎるのです。

つまりは、ひどい組み合わせだ、と言えるでしょう。

では、メモリが足りなくなった場合は どのような事が起きるでしょう？
ほとんどの場合、エラー番号 3691 (このリソース種類ためのリソースを使い果たした) と言う、有名なエラーが生じて、アプリはクラッシュするでしょう。
下記に続くヒントは、このタチの悪いエラーを避けるための方法を示すものとなります。

=== 無駄なメモリ浪費をなくす

もしも、あるオブジェクトがもう必要ないのなら、忘れずに `dispose` メソッドを呼んでやりましょう。
Flash のオブジェクトと異なり、ガベージコレクターは Stage3D のリソースのメモリを掃除してくれません！
メモリ管理に開発者自身が責任を持つのです。

==== テクスチャ

テクスチャは扱うオブジェクトの中で最も重要なものです。
いつでもメモリ領域のうち、一番大きな割合を占める事でしょう。

Starling はもちろん、この事をうまくカバーできるように働きます。
例えば、アトラスからテクスチャをロードする際、アトラスを廃棄数るだけでよく、実際のサブテクスチャを廃棄する必要はありません。
アトラスは GPU メモリだけを必要とし、"部分部分" のテクスチャはただそのアトラステクスチャを参照するだけになります。

[source, as3]
----
var atlas:TextureAtlas = ...;
var hero:Texture = atlas.getTexture("hero");

atlas.dispose(); // この処理は "hero" テクスチャも同時に廃棄します。
----

==== ディスプレイオブジェクト

ディスプレイオブジェクト自体はたくさんのグラフィックメモリを必要としない（そのうちいくつかは全く必要としない）のですが、やはりそれらを廃棄するのは良い習慣と言えます。
特にテキストフィールドなどが大きなオブジェクトですので慎重に扱いましょう。

ディスプレイオブジェクトコンテナは期待通りに、子孫要素の面倒を全て見てくれます。
コンテナを破棄すると、子孫のオブジェクトも自動的に同時に破棄されます。

[source, as3]
----
var parent:Sprite = new Sprite();
var child1:Quad = new Quad(100, 100, Color.RED);
var child2:Quad = new Quad(100, 100, Color.GREEN);

parent.addChild(child1);
parent.addChild(child2);

parent.dispose(); // この処理で子ディスプレイオブジェクトも破棄されます。
----

概して、最近のバージョンの Starling では、ディスプレイオブジェクトの破棄に関して、寛容になりました。
ほとんどのディスプレイオブジェクトはもはや Stage3D のリソースを保持していないので、ディスプレイオブジェクトを破棄するのを忘れたとしても大ごとにはなりません。

==== イメージ

ここにまず最初の落とし穴が存在します。イメージを破棄してもテクスチャは破棄されません。

[source, as3]
----
var texture:Texture = Texture.fromBitmap(/* ... */);
var image:Image = new Image(texture);

image.dispose(); // ここでテクスチャは破棄されません！
----

なぜなら Starling は、このテクスチャを今後も利用する気があるのか、知りようがないからです。
実際、同じテクスチャを共有する別のイメージをすでに利用しているかもしれません。

逆に、もしもうこのテクスチャが他の場所で使われていない事がわかっているのであれば、破棄してしまいましょう。

[source, as3]
----
image.texture.dispose();
image.dispose();
----

==== フィルター

フラグメントフィルターもちょっとデリケートです。
オブジェクトを破棄する時、同様にフィルターも破棄されます。

[source, as3]
----
var object:Sprite = createCoolSprite();
object.filter = new BlurFilter();
object.dispose(); // ここでフィルターも破棄されます。
----

しかし、下記のような似たコードではフィルターが破棄されないのです。

[source, as3]
----
var object:Sprite = createCoolSprite();
object.filter = new BlurFilter();
object.filter = null; // ここでフィルターは破棄 *されません。* 
----

もう一度言いますが、 Starling は、このフィルターを今後も利用する気があるのか、知りようがないのです。

しかし、実際にはこれは問題になりません。
フィルターが破棄されてなくても、Starling が全てのリソースを消去するからです。
よって、この操作でメモリリークを引き起こすことはありません。

NOTE: 以前の Starling のバージョン(2.0未満) では、この場合メモリリークを起こします。

=== テクスチャを埋め込まない

`Embed` メタデータ指定を使って、ActionScript の開発者はいつもビットマップを直接 swf ファイル内に埋め込んできたものです。
web コンテンツ作成においてこれはとても有効です。全てのデータを１つのファイルにまとめる事ができるのですから。

先の <<コンテキストロス>> セクションにて、Starling または一般的な Stage3D コンテンツでは、このアプローチがいくつか深刻な問題をはらんでいる事を確認しました。
テクスチャがメモリ内に少なくとも２つ（１つは通常メモリ、１つはグラフィックスメモリ）存在してしまうのです。

[source, as3]
----
[Embed(source="assets/textures/hero.png")]
private static var Hero:Class; // <1>

var texture:Texture = Texture.fromEmbeddedAsset(Hero); // <2>
----
<1> このクラスは通常のメモリ内に保持されます。
<2> このテクスチャはグラフィックメモリ内に保持されます。

このサンプルでは `Texture.fromEmbeddedAsset` メソッドを使ってテクスチャをロードしている事に注目してください。
<<コンテキストロス>> セクションでその理由は述べました。他の方法（`Texture.fromBitmap`）ではさらに余分なメモリを使ってしまうのです。

テクスチャを確実に１つしかメモリに保持しないように保障するたった一つの方法は、URL からそれをロードする事です。
画像の読み込みに _AssetManager_ を使っているなら、大した手間にはなりません。

[source, as3]
----
var appDir:File = File.applicationDirectory;
var assets:AssetManager = new AssetManager();

assets.enqueue(appDir.resolvePath("assets/textures"));
assets.loadQueue(...);

var texture:Texture = assets.getTexture("hero");
----

=== RectangleTexture を使う

Starling の _Texture_ クラスは、実際は２つの Stage3D クラスのただのラッパーです。

`flash.display3D.textures.Texture`:: どのピロファイルでも利用可能です。ミップマップとラッピングをサポートしますが、縦横のサイズが２の倍数である事が要求されます。
`flash.display3D.textures.RectangleTexture`:: `BASELINE` プロファイル以降で利用できます。ミップマップトラッピングをサポートしませんが、任意のサイズを取る事ができます。

前者はあまり知られていない妙な短所があります。必要であろうともなかろうとも、いつでもミップマップ用のメモリを確保してしまうのです。
つまり、1/3 の分のメモリを浪費している事になります！

従って、後者の `RectangleTexture` を使う事が好まれます。
Starling は可能な場合は、こちらのタイプのテクスチャを優先して使います。

しかし、少なくとも `BASELINE` プロファイルで動作中でないとそのような事はできません。またミップマップが必要ない場合に可能となります。
１つ目の条件は Context3D プロファイルのうちベストの物を選択する事で満たす事ができます。
これは、Starling のデフォルトのコンストラクタの振る舞いです。

[source, as3]
----
// このように Starling を初期化した場合、
... = new Starling(Game, stage);

// 下記の設定をしたのと同じ事になります。
... = new Starling(Game, stage, null, null, "auto", "auto");
----

最後の引数の `auto` は、Starling に 選択可能なプロファイルのうち、一番上位のものを使うように指定しています。
つまり、デバイスが RectangleTexture をサポートするなら、Starling はそれを使うという事です。

ミップマップに関しては、要求された場合のみ作成されます。
いくつかの `Texture.from...` で始まるテクスチャ生成メソッドは、その指定のパラメータを持っています。そして、_AssetManager_ には `useMipMaps` プロパティが存在します。
デフォルトでは、ミップマップが無効になる設定になっています。

=== ATF テクスチャを使う

<<ATF テクスチャ>> に関しては、すでに考察しました。 しかし、このセクションでも、もう一度取り上げる意義があります。
GPU が JPG や PNG 圧縮のデータをそのまま使う事ができない事を思い出してください。
それらのファイルは一度展開され、非圧縮状態でグラフィックメモリにアップロードされます。

ATF テクスチャの場合は異なります。圧縮された状態のまま描画され、たくさんのメモリを節約します。
もしも ATF テクスチャのセクションを読み飛ばしてきたのなら、目を通しておく事をオススメします！

ATF テクスチャの悪い点は、もちろんですが、イメージのクオリティが劣化する事です。
しかし、全てのゲームに適用できるわけではありませんが、下記のようなテクニックを適用する事が可能です。

. 実際に必要な大きさより若干大きくテクスチャを生成します。
. ATF ツールで圧縮します。
. ランタイムでは、実際に必要なサイズに縮小してテクスチャを利用します。

この手順でも、かなりたくさんのメモリの節約が可能です。そして画質の劣化ははっきりとは確認できません。

=== 16ビットテクスチャを使う

ATF テクスチャが適切でない場合、おそらくアプリケーションでは色数が制限されたアニメ調の絵柄を用いるのかと思われます。
//原文：If ATF textures don't work for you, chances are that your application uses a comic-style with a limited color palette.
良いニュースがあります。そのようなタイプのテクスチャには、また別の解決方法があります！

* デフォルトのテクスチャフォーマット (`Context3DTextureFormat.BGRA`) はピクセルごとに32ビット（１つのチャンネルに8ビット)の容量を使います。
* それとは別のフォーマット (`Context3DTextureFormat.BGRA_PACKED`) が存在し、そちらは半分のサイズ、ピクセルごとに16ビット（１つのチャンネルに4ビット)の容量を使います。

Starling ではこのフォーマットを `Texture.from...` 系のメソッドの `format` 引数で指定するか、AssetManager の `textureFormat` プロパティで指定する事ができます。
これにより 50% ものメモリを節約する事ができます！

当然、この処理は画像のクオリティの低下も招きます。
もしもグラーデーションを利用しているのなら、16ビットテクスチャはむしろ汚くなります。
しかし、ディザリングを使う事でその問題を解決する事ができます。

.ディザリングで色深度が減った事をカバーする事ができます。
image::dithering.png[Dithering]

もっとわかりやすいするため、上記のサンプルのグラデーションはたったの16色(4ビット)まで減色されています。
このような少ない色数でも、ディザリングで画像のクオリティが受け入れられるレベルであるようにする事ができます。

大抵の画像編集ソフトでは、色深度を減らす際に自動でディザリングを適用してくれます。
_TexturePacker_ でも、それを行う事が可能です。

_AssetManager_ はファイルごとに適切な色深度を選択するように設定する事ができます。
//原文：The _AssetManager_ can be configured to select a suitable color depth on a per-file basis.

[source, as3]
----
var assets:AssetManager = new AssetManager();

// 16bitテクスチャをキューに積む
assets.textureFormat = Context3DTextureFormat.BGRA_PACKED;
assets.enqueue(/* ... */);

// 32bitテクスチャをキューに積む
assets.textureFormat = Context3DTextureFormat.BGRA;
assets.enqueue(/* ... */);

// 読み込みの開始
assets.loadQueue(/* ... */);
----

=== ミップマップを避ける

ミップマップは元となるテクスチャを縮小したバージョンの事です。レンダリングのスピードを上げつつ、エイリアシングを軽減する目的で使われます。

.ミップマップを持つテクスチャの例。
image::mipmap.jpg[Mipmap]

Starling のバージョン2からは、デフォルトでミップマップを生成しない仕様となりました。
デフォルト設定として好ましい事がわかったからです。なぜなら、

* テクスはの読み込みが速い
* テクスチャが使うメモリ量が少ない（オリジナルのピクセル文だけで済みます。）
* ぼやけた描画を避ける事ができる。（ミップマップはしばしば曖昧な見た目を生じます。）

一方で、ミップマップを有効とするとオブジェクトがかなり縮小されていた場合は、描画速度が著しく上がります。
そして表示にエイリアシングがかかる事を避ける事ができます。（エイリアスとぼやけは正反対のものです。）
ミップマップを有効にするには、`Texture.from...` 系のメソッドで対応するパラメータを設定してください。

=== ビットマップフォントを使う

すでに議論されましたが、テキストフィールドは２種類のフォントをサポートします。TrueType フォントと、ビットマップフォントです。

TrueType フォントはとても簡単に使えますが、いくつかの短所も持ちます。

* テキストを変更するたびに、新しくテクスチャが生成されグラフィックメモリーにアップロードされます。これは遅い処理です。
* たくさんのテキストフィールドを生成したり、大きなものを生成した場合、たくさんのテクスチャメモリが必要となります。

一方で、ビットマップフォントは、

* 更新が高速です。
* 必要なメモリ量は一定です。（glyph テクスチャのみとなります。）

これらの理由で、Starling 内にテキストを表示する方法として好ましいのです。
個人的には、いつでもビットマップフォントを使う事をオススメします！

TIP: ビットマップフォントは16ビットテクスチャを適用する候補として適切です。なぜなら大抵は白一色でテキストフィールド色にランタイムで着色されるからです。

=== テクスチャアトラスを最適化する

できる限りコンパクトにテクスチャアトラスをパックする事はとても重要な事でしょう。
https://www.codeandweb.com/texturepacker/starling?source=gamua[TexturePacker] のようなツールでは下記のようなオプション指定が可能です。

* 周辺の透明部分をトリムする。
* より効率よくパックする場合、テクスチャを90度回転して扱う。
* カラーの深度を減らす（上の考察を参照）
* 重複する画像を削除する
* その他

これらを利用して役に立てて下さい！
たくさんのテクスチャを１枚のアトラスに収める事で、メモリ全体の浪費を抑えるだけでなく、ドローコールの回数も抑える事ができます。（詳しくは次のチャプターで取り扱います。）

[[memory_management_scout]]
//パフォチューノページと記載を合わせる 英語のままでいい

=== Adobe Scout を使う

https://www.adobe.com/products/scout.html[Adobe Scout] は、軽量化つ包括的な ActionScript と Stage3D のためのプロファイリングツールです。
どんな Flash または AIR アプリケーションに対して、モバイル端末上で動いていようともブラウザで動いていようとも、コードの変更なしに素早くプロファイリングを行う事ができます。
そして、Adobe Scout は素早く効率的にパフォーマンスに影響を与えうる問題を検出します。

Scout を使うと、パフォーマンスのボトルネックになる ActionScript のコードを見つけられるだけでなく、
時間とともに散り積もって行く通常メモリ及びグラフィックメモリの浪費についいぇの詳細を知る事もできます。
非常に素晴らしい事です！

NOTE: Adobe Scout は、Adobe Creative Cloud メンバーシップの _無料_ 契約があれば利用する事ができます。入手するために有料の契約を結ぶ必要はありません。
次のリンクは Thibault Imbert 氏による、Adobe Scout をどのように使うかの詳細を説明する素晴らしい内容のチュートリアルビデオです。
http://www.adobe.com/devnet/scout/articles/adobe-scout-getting-started.html[Getting started with Adobe Scout]

.Adobe Scout
image::scout-screenshot.png[Adobe Scout]

=== Keep an Eye on the Statistics Display

The statistics display (available via `starling.showStats`) includes information about both conventional memory and graphics memory.
It pays off to keep an eye on these values during development.

Granted, the conventional memory value is often misleading -- you never know when the garbage collector will run.
The graphics memory value, on the other hand, is extremely accurate.
When you create a texture, the value will rise; when you dispose a texture, it will decrease -- immediately.

Actually, when I added this feature to Starling, it took about five minutes and I had already found the first memory leak -- in Starling's demo app.
I used the following approach:

* In the main menu, I noted down the used GPU memory.
* Then I entered the demos scenes, one after another.
* Each time I returned to the main menu, I checked if the GPU memory had returned to the original value.
* After returning from one of the scenes, that value was not restored, and indeed: a code review showed that I had forgotten to dispose one of the textures.

.The statistics display shows the current memory usage.
image::stats-display.png[The statistics display]

Needless to say: Scout offers far more details on memory usage.
But the simple fact that the statistics display is always available makes it possible to find things that would otherwise be easily overlooked.
