== メモリ管理

たくさんの Starling デベロッパーがアプリやゲームをモバイル向けに作るためにフレームワークを利用しています。
そしてそのうちほとんど全員が、遅かれ早かれモバイル端末は悪い噂になるほどメモリが少ないと言う事に苦労しながら気がつきます。
なぜでしょう？

* ほとんどのモバイル端末はとても高い解像度のスクリーンを持ちます。
* そのような端末で2Dゲームを動かす場合、同様に高い解像度のテクスチャが必要になります。
* 利用可能な RAM はそのテクスチャデータ全てを保持するには少なすぎるのです。

つまりは、ひどい組み合わせだ、と言えるでしょう。

では、メモリが足りなくなった場合は どのような事が起きるでしょう？
ほとんどの場合、エラー番号 3691 (このリソース種類ためのリソースを使い果たした) と言う、有名なエラーが生じて、アプリはクラッシュするでしょう。
下記に続くヒントは、このタチの悪いエラーを避けるための方法を示すものとなります。

=== 無駄なメモリ浪費をなくす

もしも、あるオブジェクトがもう必要ないのなら、忘れずに `dispose` メソッドを呼んでやりましょう。
Flash のオブジェクトと異なり、ガベージコレクターは Stage3D のリソースのメモリを掃除してくれません！
メモリ管理に開発者自身が責任を持つのです。

==== テクスチャ

テクスチャは扱うオブジェクトの中で最も重要なものです。
いつでもメモリ領域のうち、一番大きな割合を占める事でしょう。

Starling はもちろん、この事をうまくカバーできるように働きます。
例えば、アトラスからテクスチャをロードする際、アトラスを廃棄数るだけでよく、実際のサブテクスチャを廃棄する必要はありません。
アトラスは GPU メモリだけを必要とし、"部分部分" のテクスチャはただそのアトラステクスチャを参照するだけになります。

[source, as3]
----
var atlas:TextureAtlas = ...;
var hero:Texture = atlas.getTexture("hero");

atlas.dispose(); // この処理は "hero" テクスチャも同時に廃棄します。
----

==== ディスプレイオブジェクト

ディスプレイオブジェクト自体はたくさんのグラフィックメモリを必要としない（そのうちいくつかは全く必要としない）のですが、やはりそれらを廃棄するのは良い習慣と言えます。
特にテキストフィールドなどが大きなオブジェクトですので慎重に扱いましょう。

ディスプレイオブジェクトコンテナは期待通りに、子孫要素の面倒を全て見てくれます。
コンテナを破棄すると、子孫のオブジェクトも自動的に同時に破棄されます。

[source, as3]
----
var parent:Sprite = new Sprite();
var child1:Quad = new Quad(100, 100, Color.RED);
var child2:Quad = new Quad(100, 100, Color.GREEN);

parent.addChild(child1);
parent.addChild(child2);

parent.dispose(); // この処理で子ディスプレイオブジェクトも破棄されます。
----

概して、最近のバージョンの Starling では、ディスプレイオブジェクトの破棄に関して、寛容になりました。
ほとんどのディスプレイオブジェクトはもはや Stage3D のリソースを保持していないので、ディスプレイオブジェクトを破棄するのを忘れたとしても大ごとにはなりません。

==== イメージ

ここにまず最初の落とし穴が存在します。イメージを破棄してもテクスチャは破棄されません。

[source, as3]
----
var texture:Texture = Texture.fromBitmap(/* ... */);
var image:Image = new Image(texture);

image.dispose(); // ここでテクスチャは破棄されません！
----

なぜなら Starling は、このテクスチャを今後も利用する気があるのか、知りようがないからです。
実際、同じテクスチャを共有する別のイメージをすでに利用しているかもしれません。

逆に、もしもうこのテクスチャが他の場所で使われていない事がわかっているのであれば、破棄してしまいましょう。

[source, as3]
----
image.texture.dispose();
image.dispose();
----

==== フィルター

フラグメントフィルターもちょっとデリケートです。
オブジェクトを破棄する時、同様にフィルターも破棄されます。

[source, as3]
----
var object:Sprite = createCoolSprite();
object.filter = new BlurFilter();
object.dispose(); // ここでフィルターも破棄されます。
----

しかし、下記のような似たコードではフィルターが破棄されないのです。

[source, as3]
----
var object:Sprite = createCoolSprite();
object.filter = new BlurFilter();
object.filter = null; // ここでフィルターは破棄 *されません。* 
----

もう一度言いますが、 Starling は、このフィルターを今後も利用する気があるのか、知りようがないのです。

しかし、実際にはこれは問題になりません。
フィルターが破棄されてなくても、Starling が全てのリソースを消去するからです。
よって、この操作でメモリリークを引き起こすことはありません。

NOTE: 以前の Starling のバージョン(2.0未満) では、この場合メモリリークを起こします。

=== テクスチャを埋め込まない

`Embed` メタデータ指定を使って、ActionScript の開発者はいつもビットマップを直接 swf ファイル内に埋め込んできたものです。
web コンテンツ作成においてこれはとても有効です。全てのデータを１つのファイルにまとめる事ができるのですから。

先の <<コンテキストロス>> セクションにて、Starling または一般的な Stage3D コンテンツでは、このアプローチがいくつか深刻な問題をはらんでいる事を確認しました。
テクスチャがメモリ内に少なくとも２つ（１つは通常メモリ、１つはグラフィックスメモリ）存在してしまうのです。

[source, as3]
----
[Embed(source="assets/textures/hero.png")]
private static var Hero:Class; // <1>

var texture:Texture = Texture.fromEmbeddedAsset(Hero); // <2>
----
<1> このクラスは通常のメモリ内に保持されます。
<2> このテクスチャはグラフィックメモリ内に保持されます。

このサンプルでは `Texture.fromEmbeddedAsset` メソッドを使ってテクスチャをロードしている事に注目してください。
<<コンテキストロス>> セクションでその理由は述べました。他の方法（`Texture.fromBitmap`）ではさらに余分なメモリを使ってしまうのです。

テクスチャを確実に１つしかメモリに保持しないように保障するたった一つの方法は、URL からそれをロードする事です。
画像の読み込みに _AssetManager_ を使っているなら、大した手間にはなりません。

[source, as3]
----
var appDir:File = File.applicationDirectory;
var assets:AssetManager = new AssetManager();

assets.enqueue(appDir.resolvePath("assets/textures"));
assets.loadQueue(...);

var texture:Texture = assets.getTexture("hero");
----

=== RectangleTexture を使う

Starling の _Texture_ クラスは、実際は２つの Stage3D クラスのただのラッパーです。

`flash.display3D.textures.Texture`:: どのピロファイルでも利用可能です。ミップマップとラッピングをサポートしますが、縦横のサイズが２の倍数である事が要求されます。
`flash.display3D.textures.RectangleTexture`:: `BASELINE` プロファイル以降で利用できます。ミップマップトラッピングをサポートしませんが、任意のサイズを取る事ができます。

前者はあまり知られていない妙な短所があります。必要であろうともなかろうとも、いつでもミップマップ用のメモリを確保してしまうのです。
つまり、1/3 の分のメモリを浪費している事になります！

従って、後者の `RectangleTexture` を使う事が好まれます。
Starling は可能な場合は、こちらのタイプのテクスチャを優先して使います。

しかし、少なくとも `BASELINE` プロファイルで動作中でないとそのような事はできません。またミップマップが必要ない場合に可能となります。
１つ目の条件は Context3D プロファイルのうちベストの物を選択する事で満たす事ができます。
これは、Starling のデフォルトのコンストラクタの振る舞いです。

[source, as3]
----
// このように Starling を初期化した場合、
... = new Starling(Game, stage);

// 下記の設定をしたのと同じ事になります。
... = new Starling(Game, stage, null, null, "auto", "auto");
----

最後の引数の `auto` は、Starling に 選択可能なプロファイルのうち、一番上位のものを使うように指定しています。
つまり、デバイスが RectangleTexture をサポートするなら、Starling はそれを使うという事です。

ミップマップに関しては、要求された場合のみ作成されます。
いくつかの `Texture.from...` で始まるテクスチャ生成メソッドは、その指定のパラメータを持っています。そして、_AssetManager_ には `useMipMaps` プロパティが存在します。
デフォルトでは、ミップマップが無効になる設定になっています。

=== ATF テクスチャを使う

<<ATF テクスチャ>> に関しては、すでに考察しました。 しかし、このセクションでも、もう一度取り上げる意義があります。
GPU が JPG や PNG 圧縮のデータをそのまま使う事ができない事を思い出してください。
それらのファイルは一度展開され、非圧縮状態でグラフィックメモリにアップロードされます。

ATF テクスチャの場合は異なります。圧縮された状態のまま描画され、たくさんのメモリを節約します。
もしも ATF テクスチャのセクションを読み飛ばしてきたのなら、目を通しておく事をオススメします！

ATF テクスチャの悪い点は、もちろんですが、イメージのクオリティが劣化する事です。
しかし、全てのゲームに適用できるわけではありませんが、下記のようなテクニックを適用する事が可能です。

. 実際に必要な大きさより若干大きくテクスチャを生成します。
. ATF ツールで圧縮します。
. ランタイムでは、実際に必要なサイズに縮小してテクスチャを利用します。

この手順でも、かなりたくさんのメモリの節約が可能です。そして画質の劣化ははっきりとは確認できません。

=== Use 16 bit Textures

If ATF textures don't work for you, chances are that your application uses a comic-style with a limited color palette.
I've got good news for you: for these kinds of textures, there's a different solution!

* The default texture format (`Context3DTextureFormat.BGRA`) uses 32 bits per pixel (8 bits for each channel).
* There is an alternative format (`Context3DTextureFormat.BGRA_PACKED`) that uses only half of that: 16 bits per pixel (4 bits for each channel).

You can use this format in Starling via the `format` argument of the `Texture.from...` methods, or via the AssetManager's `textureFormat` property.
This will save you 50% of memory!

Naturally, this comes at the price of a reduced image quality.
Especially if you're making use of gradients, 16 bit textures might become rather ugly.
However, there's a solution for this: dithering!

.Dithering can conceal a reduced color depth.
image::dithering.png[Dithering]

To make it more apparent, the gradient in this sample was reduced to just 16 colors (4 bits).
Even with this low number of colors, dithering manages to deliver an acceptable image quality.

Most image processing programs will use dithering automatically when you reduce the color depth.
_TexturePacker_ has you covered, as well.

The _AssetManager_ can be configured to select a suitable color depth on a per-file basis.

[source, as3]
----
var assets:AssetManager = new AssetManager();

// enqueue 16 bit textures
assets.textureFormat = Context3DTextureFormat.BGRA_PACKED;
assets.enqueue(/* ... */);

// enqueue 32 bit textures
assets.textureFormat = Context3DTextureFormat.BGRA;
assets.enqueue(/* ... */);

// now start the loading process
assets.loadQueue(/* ... */);
----

=== Avoid Mipmaps

Mipmaps are downsampled versions of your textures, intended to increase rendering speed and reduce aliasing effects.

.Sample of a texture with mipmaps.
image::mipmap.jpg[Mipmap]

Since version 2.0, Starling doesn't create any mipmaps by default.
That turned out to be the preferable default, because without mipmaps:

* Textures load faster.
* Textures require less texture memory (just the original pixels, no mipmaps).
* Blurry images are avoided (mipmaps sometimes become fuzzy).

On the other hand, activating them will yield a slightly faster rendering speed when the object is scaled down significantly, and you avoid aliasing effects (i.e. the effect contrary to blurring).
To enable mipmaps, use the corresponding parameter in the `Texture.from...` methods.

=== Use Bitmap Fonts

As already discussed, TextFields support two different kinds of fonts: TrueType fonts and Bitmap Fonts.

While TrueType fonts are very easy to use, they have a few downsides.

* Whenever you change the text, a new texture has to be created and uploaded to graphics memory. This is slow.
* If you've got many TextFields or big ones, this will require a lot of texture memory.

Bitmap Fonts, on the other hand, are

* updated very quickly and
* require only a _constant_ amount of memory (just the glyph texture).

That makes them the preferred way of displaying text in Starling.
My recommendation is to use them whenever possible!

TIP: Bitmap Font textures are a great candidate for 16 bit textures, because they are often just pure white that's tinted to the actual TextField color at runtime.

=== Optimize your Texture Atlas

It should be your top priority to pack your texture atlases as tightly as possible. Tools like https://www.codeandweb.com/texturepacker/starling?source=gamua[TexturePacker] have several options that will help with that:

* Trim transparent borders away.
* Rotate textures by 90 degrees if it leads to more effective packing.
* Reduce the color depth (see above).
* Remove duplicate textures.
* etc.

Make use of this!
Packing more textures into one atlas not only reduces your overall memory consumption, but also the number of draw calls (more on that in the next chapter).

[[memory_management_scout]]
//パフォチューノページと記載を合わせる 英語のままでいい

=== Use Adobe Scout

https://www.adobe.com/products/scout.html[Adobe Scout] is a lightweight but comprehensive profiling tool for ActionScript and Stage3D.
Any Flash or AIR application, regardless of whether it runs on mobile devices or in browsers, can be quickly profiled with no change to the code -- and Adobe Scout quickly and efficiently detects problems that could affect performance.

With Scout, you can not only find performance bottlenecks in your ActionScript code, but you'll also find a detailed roundup of your memory consumption over time, both for conventional and graphics memory.
This is priceless!

NOTE: Adobe Scout is part of the _free_ version of Adobe's Creative Cloud membership. You don't have to become a paying subscriber of CC to get it.

Here is a great tutorial from Thibault Imbert that explains in detail how to work with Adobe Scout: http://www.adobe.com/devnet/scout/articles/adobe-scout-getting-started.html[Getting started with Adobe Scout]

.Adobe Scout
image::scout-screenshot.png[Adobe Scout]

=== Keep an Eye on the Statistics Display

The statistics display (available via `starling.showStats`) includes information about both conventional memory and graphics memory.
It pays off to keep an eye on these values during development.

Granted, the conventional memory value is often misleading -- you never know when the garbage collector will run.
The graphics memory value, on the other hand, is extremely accurate.
When you create a texture, the value will rise; when you dispose a texture, it will decrease -- immediately.

Actually, when I added this feature to Starling, it took about five minutes and I had already found the first memory leak -- in Starling's demo app.
I used the following approach:

* In the main menu, I noted down the used GPU memory.
* Then I entered the demos scenes, one after another.
* Each time I returned to the main menu, I checked if the GPU memory had returned to the original value.
* After returning from one of the scenes, that value was not restored, and indeed: a code review showed that I had forgotten to dispose one of the textures.

.The statistics display shows the current memory usage.
image::stats-display.png[The statistics display]

Needless to say: Scout offers far more details on memory usage.
But the simple fact that the statistics display is always available makes it possible to find things that would otherwise be easily overlooked.
