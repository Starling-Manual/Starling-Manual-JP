== カスタムフィルター

手を汚す準備はできていますか？
ついにカスタムレンダリングのコードの分野に取り掛かろうとしています。先ずは簡単なフラグメントフィルターからです。

この作業には低レイヤーのコードを取り扱う必要があります。何行かのアセンブラコードを書くことにもなるでしょう。
しかし恐れることはありません。ロケット工学を扱うわけではないのですから。
昔の数学の先生は言ったものです。訓練を積んだ猿はそんな問題は解いてしまうぞ！と。
//原文：As my old math teacher used to say: a drilled monkey could do that!

NOTE: 覚えておいて欲しいのですが、フィルターはディスプレイオブジェクトのピクセル単位で動きます。
フィルターが適用されたオブジェクトは、一度内部的にテクスチャーに変換され、その後フラグメントシェダーで処理されます。（よってこれをフラグメントフィルターを呼びます。）

=== ゴール

簡単な作成をゴールとしますが、役に立つものであるべきです。
ここでは _ColorOffsetFilter_ を作ることにしましょう。

おそらく、メッシュのどの頂点にもカラーが設定でき、色付けを施すことができる事は知っているかと思います。
レンダリング時にそのカラー設定はテクスチャーのカラーと乗算されます。テクスチャーの色味を調整するシンプルで高速なやり方です。

[source, as3]
----
var image:Image = new Image(texture);
image.color = 0x808080; // R = G = B = 0.5
----

背景にある数学的な演算はとてもシンプルです。GPU では赤・緑・青のどのチャンネルも 0 から 1 の間の数値で表されます。
例えば、純粋な赤は下記のような値になります。

  R = 1, G = 0, B = 0

レンダリング時に、このカラー値は各ピクセルのテクスチャー色(テクセルとも呼ばれます。）と乗算されます。
デフォルトのイメージのカラーは純白です。全てのチャンネル値が１となります。
したがって、テクセルのカラーは変化しません。（１をかける事は何もしない事と同じです。）

異なったカラー値を設定すると乗算結果は新しい色を生み出します。下記はその例です。

  R = 1,   G = 0.8, B = 0.6  ×
  B = 0.5, G = 0.5, B = 0.5
  -------------------------
  R = 0.5, G = 0.4, B = 0.3

そしてここで問題が起きます。この処理はオブジェクトの色味を暗くはしますが、絶対に明るくはしないのです。
何故ならば掛け合わせている値が 0 と 1 の間だけだからです。0 をかける事は黒を作り出します。そして 1 をかけると無変化となります。

.グレーのカラー設定で色味が変化した画像。
image::customfilter-tinting.png[Tinting]

この問題をこれから作るフィルターで解決してみましょう。
カラーの計算にオフセット値を含むようにします。
（Flashでは http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/geom/ColorTransform.html[ColorTransform] の設定として行なっていた事と同じです。)

* 変化後の red 値 = (元の red 値 × red 乗算値) + red オフセット値
* 変化後の green 値 = (元の green 値 × green 乗算値) + green オフセット値
* 変化後の blue 値 = (元の blue 値 × blue 乗算値) + blue オフセット値
* 変化後の alpha 値 = (元の alpha 値 × alpha 乗算値) + alpha オフセット値

乗算する機構はメッシュ基底クラスがすでに持っているので、オフセット値のみがこれから作るフィルターに必要なプロパティとなります。

.全てのチャンネルにオフセット値を与える。
image::customfilter-offset.png[Offset]

では、そろそろ始めますよ？

=== FragmentFilter を継承する

全てのフィルターは例外なく、`starling.filters.FragmentFilter` クラスを継承して作ります。

さてここで、 _ColorOffsetFilter_ クラスの完全なコードを紹介します。仮コードではなく最終のコードです。
この後のコード修正はありません。

[source, as3]
----
public class ColorOffsetFilter extends FragmentFilter
{
    public function ColorOffsetFilter(
        redOffset:Number=0, greenOffset:Number=0,
        blueOffset:Number=0, alphaOffset:Number=0):void
    {
        colorOffsetEffect.redOffset = redOffset;
        colorOffsetEffect.greenOffset = greenOffset;
        colorOffsetEffect.blueOffset = blueOffset;
        colorOffsetEffect.alphaOffset = alphaOffset;
    }

    override protected function createEffect():FilterEffect
    {
        return new ColorOffsetEffect();
    }

    private function get colorOffsetEffect():ColorOffsetEffect
    {
        return effect as ColorOffsetEffect;
    }

    public function get redOffset():Number
    {
        return colorOffsetEffect.redOffset;
    }

    public function set redOffset(value:Number):void
    {
        colorOffsetEffect.redOffset = value;
        setRequiresRedraw();
    }

    // その他の オフセット プロパティも同じようにそれぞれ実装します。

    public function get/set greenOffset():Number;
    public function get/set blueOffset():Number;
    public function get/set alphaOffset():Number;
}
----

驚くほどコンパクトですね。
実はこれはまだ話の半分ほどです。別にもうひとつのクラスを記述する必要があります。そこで、実際の色味を扱う処理が入ります。
しかし、上記のコードも詳細を追う価値があります。

このクラスは _FragmentFilter_ クラスを継承しており、'createEffect' メソッドをオーバーライドしています。
おそらく `starling.rendering.Effect` クラスを扱ったこと人がほとんどだと思いますが、それはローレベルのレンダリング用途でしか必要とならないからです。
API ドキュメントから引用すると、

====
Effect は Stage3D の描画工程の全てをカプセル化します。
レンダーコンテキストを設定し、インデックスバッファ、バーテックスバッファ、シェーダプログラムをセットアップします。
よって、基本的でローレベルな全てのレンダリングメカニズムを提供してくれます。
//原文：It configures the render context and sets up shader programs as well as index- and vertex-buffers, thus providing the basic mechanisms of all low-level rendering.
====

と、あります。

_FragmentFilter_ クラスは、このクラスもしくはこのクラスを継承した _FilterEffect_ というサブクラスを利用します。
今回のシンプルなフィルターのために、`createEffect()` をオーバライドし、カスタムエフェクトを提供します。
//原文：For this simple filter, we just have to provide a custom effect, which we're doing by overriding `createEffect()`.
その他プロパティはエフェクトを調整するだけのためのものです。
レンダリング時には、ベースクラスが、その effect を自動系に扱い、フィルターの描画をしてくれます。
以上となります！

NOTE: `colorOffsetEffect` プロパティが何をしているのか気になるでしょうか。
//原文：If you're wondering what the `colorOffsetEffect` property does:
これは、 _ColorOffsetEffect_ へのキャストを行わずに effect へのアクセスを行うためのただのショートカットです。
ベースクラスは `effect` プロパティを提供します。しかし、それは FilterEffect` 型でのオブジェクトであり、
`offset` プロパティにアクセスするためには、完全な _ColorOffsetEffect_ 型が必要であるわけです。

もっと複雑なフィルターでは `process` メソッドの継承も必要になるかもしれません。例えばマルチパスのフィルターを作る場合などです。
しかし、今回のサンプルフィルターでは必要ありません。

最後に、`setRequiresRedraw` メソッドの呼び出しについて記します。
呼び出す事で、設定が変化した場合に必ずエフェクトの再描画がかかるようにしています。
この呼び出しがないと、Starling はオブジェクトを再描画するべきタイミングを知ることができないのです。

=== FilterEffect を継承する

実際の仕事を行う時間となりました。
この _FilterEffect_ のサブクラスは、サンプルフィルターの働き者と言えます。
これは、複雑だ、という意味ではありません。ちょっと我慢して付いてきてください。
//原文：Which doesn't mean that it's very complicated, so just bear with me.

先ずは仮のスタブコードから始めましょう。

[source, as3]
----
public class ColorOffsetEffect extends FilterEffect
{
    private var _offsets:Vector.<Number>;

    public function ColorOffsetEffect()
    {
        _offsets = new Vector.<Number>(4, true);
    }

    override protected function createProgram():Program
    {
        // TODO
    }

    override protected function beforeDraw(context:Context3D):void
    {
        // TODO
    }

    public function get redOffset():Number { return _offsets[0]; }
    public function set redOffset(value:Number):void { _offsets[0] = value; }

    public function get greenOffset():Number { return _offsets[1]; }
    public function set greenOffset(value:Number):void { _offsets[1] = value; }

    public function get blueOffset():Number { return _offsets[2]; }
    public function set blueOffset(value:Number):void { _offsets[2] = value; }

    public function get alphaOffset():Number { return _offsets[3]; }
    public function set alphaOffset(value:Number):void { _offsets[3] = value; }
}
----

ここでは、offsets プロパティを _Vector_ 型の中に格納しています。その方が GPU へのアップロード時に都合がいいからです。
`offset` プロパティを、ベクターの中に読み書きする。シンプルです。

２つの継承メソッドについて見ていくと、さらに面白くなってきます。

==== createProgram

このメソッドは実際の Stage3D シェーダーコードを作成します。

[NOTE]
====
基本的な事柄は解説しますが、_Stage3D_ の全てについてそれを行うのはこのマニュアルの範疇を超えます。
さらに詳細な情報が必要であれば、下記リンクのチュートリアルを参照することができます。

  * http://www.adobe.com/devnet/flashplayer/articles/how-stage3d-works.html[How Stage3D works]
  * http://jacksondunstan.com/articles/1661[Introduction to AGAL]
  * http://help.adobe.com/en_US/as3/dev/WSd6a006f2eb1dc31e-310b95831324724ec56-8000.html[List of AGAL operations]
====

Stage3D の全てのレンダリングは、バーテックス()シェーダーとフラグメント(断片)シェーダーを通して行われます。
これらは GPU によって直接実行される小さなプログラムで、２つの役割を持ちます。

* *バーテックスシェーダー* はそれぞれの頂点に対して１度だけ実行されます。
入力情報は、頂点の属性値から作成され、通常 `VertexData` クラスを通して設定します。
出力情報は、スクリーン座標系での位置情報です。
* *フラグメントシェーダー* は１ピクセル(=断片=フラグメント)ごとに１回実行されます。
入力情報は関連する三角ポリゴンの３つの頂点の情報がピクセルの位置によって補完されたものです。
出力情報は、シンプルにそのピクセルのカラー情報です。
* ２つのシェーダが合わさって１つの *Program* を作成します。

フィルターが記述されている言語は AGAL と呼ばれます。アセンブラ言語です。
（読んだ通り、この言語はローベル中のローベルです。）
//原文：(Yes, you read right! This is as low-level as it gets.)
しかしながら、ありがたいことに大抵の AGAL プログラムはとても短く、そこまでひど事にはなりません。
//原文：Thankfully, however, typical AGAL programs are very short, so it's not as bad as it sounds.

良いニュースとして、今回はフラグメントシェーダーを書くだけですみます。
バーテックスシェーダーは大抵のフィルターで同じになるので、Starling は標準的なバーテックスシェーダーの実装を提供します。
では、そのコードを見てみましょう。

[source, as3]
----
override protected function createProgram():Program
{
    var vertexShader:String = STD_VERTEX_SHADER;
    var fragmentShader:String =
        "tex ft0, v0, fs0 <2d, linear> \n" +
        "add oc, ft0, fc0";

    return Program.fromSource(vertexShader, fragmentShader);
}
----

説明したように、バーテックスシェーダーは定数から取得されます。
フラグメントシェーダーはたったの２行です。
２つのシェーダーは合わせて１つの _Program_ インスタンスとなり、メソッドの戻り値となります。

フラグメントシェーダーにはもう少しの労力が必要です。
//原文：The fragment shader requires some further elaboration, of course.

===== AGAL コード概要

AGAL は、各行にシンプルな命令が記述されます。

  [命令] [出力場所], [引数１], ([引数２])

* 最初の３文字はオペーレーション名です。 (`tex`, `add`).
* 次の引数はオペレーション結果をどこに保存するかを指定します。
* 他の引数はオペレーションの実際の引数となるものです。
* 全てのデータはあらかじめ定義済みのレジスタに保持されます。
それらレジスタは _Vector3D_ インスタンスだと考えましょう。x、y、zのプロパティを持ちます。

レジスタにはいくつかの種類があります。例えば、定数、一時データ、シェーダーの出力用などです。
今回のシェーダーでは、そのうちいくつかはあらかじめ値を持っています。フィルターの他のメソッドによって設定されています。
（後ほど解説します。）

* `v0` (_varying レジスタ 0_)は、現在のテクスチャ座標を保持しています。
* `fs0` (_fragment サンプラ 0_)は、入力テクスチャを示します。
* `fc0` (_fragment 定数 0_)は、カラーオフセット値を保持しています。今回のキモです。
//原文：contains the color offset this is all about

フラグメントシェーダの結果はいつもカラー値となります。 出力カラー値は `oc` レジスタに格納します。

===== AGAL コード詳細

今回のフラグメントシェーダーの実際のコードを見てみましょう。
*最初の行* はカラー値をテクスチャから読み取っています。

    tex ft0, v0, fs0 <2d, linear>

`fs0` が表すテクスチャーから、`v0` が表すテクスチャ座標でカラー値を読み取ります。その際 `2d, linear` という言うオプション情報が付与されています。
`v0` にテクスチャ座標が保持されている理由は、標準バーテックスシェーダー (`STD_VERTEX_SHADER`) で設定しているからです。ここに関してはそうなのだ、と思ってください。
結果は一時レジスタの `ft0`に保持されます。（ AGAL では、演算結果がいつでも命令の第一引数に格納されることを思い出してください。）

[NOTE]
====
ちょっとここで考えて見ましょう。まだテクスチャの設定を行なっていませんよね？これはどういうことでしょう？

上で述べたように、フラグメントフィルターはピクセル毎に実行されます。フィルターへの入力は、元々のディスプレイオブジェクトが一度内部的なテクスチャとして描画されたものです。
//原文：As I wrote above, a fragment filter works at the pixel level; its input is the original object, rendered into a texture.
ベースクラスの _FilterEffect_ がそれを行なってくれます。プログラムが実行される時、テクスチャーサンプラー `fs0` はフィルターをかけようとしているテクスチャを指しています。
//原文：Our base class (_FilterEffect_) sets that up for us; when the program runs, you can be sure that the texture sampler `fs0` will point to the pixels of the object being filtered.
====

さて、ここでこの行についてちょっとだけ変更したい点があります。
//原文：You know what, actually I'd like to change this line a little.
行の最後にオプション指定があるのに気づいているかと思います。これはどのようにテクスチャデータを解釈するか指定しているものです。
しかし、アクセスしようとしてるテクスチャのタイプによって、このオプションは変化する事が判明しました。
どのテクスチャでもこのコードが動くようにするため、AGAL コードを記述してくれるヘルパーメソッドを用意したので、これを使いましょう。
//原文：To be sure the code works for every texture, let's use a helper method to write that AGAL operation.

[source, as3]
----
tex("ft0", "v0", 0, this.texture)
----

このメソッドは AGAL 文字列を返します。そして先のコードと同じ振る舞いをします。そしてオプションの内容についてはもうケアする必要がありません。
テクスチャにアクセスする際はいつもこのメソッドを利用してください。夜にぐっすり眠れるようになりますよ。

そして２行目は、今回のフィルターのキモの部分です。カラーオフセット値をテクセルカラーに加算します。
オフセット値は `fc0` に保持されています。ざっと見てみましょう。 テクセルカラー値が格納された `ft0` レジスタとkさんされた、出力レジスタの `oc` に代入されています。

    add oc, ft0, fc0

AGAL コードはとりあえずこのような感じです。
その他のオーバーライドされたメソッドを見てみましょう。

==== beforeDraw

The `beforeDraw` method is executed directly before the shaders are executed. We can use them to set up all the data required by our shader.

[source, as3]
----
override protected function beforeDraw(context:Context3D):void
{
    context.setProgramConstantsFromVector(Context3DProgramType.FRAGMENT, 0, _offsets);
    super.beforeDraw(context);
}
----

This is where we pass the offset values to the fragment shader.
The second parameter, `0`, defines the register that data is going to end up in.
If you look back at the actual shader code, you'll see that we read the offset from `fc0`, and that's exactly what we're filling up here: `fragment constant 0`.

The super call sets up all the rest, e.g. it assigns the texture (`fs0`) and the texture coordinates.

NOTE: Before you ask: yes, there is also an `afterDraw()` method, usually used to clean up one's resources.
But for constants, this is not necessary, so we can ignore it in this filter.

=== Trying it out

Our filter is ready, actually (download the complete code https://gist.github.com/PrimaryFeather/ba1e26d568320cd31086[here])!
Time to give it a test ride.

[source, as3]
----
var image:Image = new Image(texture);
var filter:ColorOffsetFilter = new ColorOffsetFilter();
filter.redOffset = 0.5;
image.filter = filter;
addChild(image);
----

.Our filter seems to have an ugly side effect.
image::customfilter-pma.png[Custom Filter PMA Issue]

Blimey!
Yes, the red value is definitely higher, but why is it now extending beyond the area of the bird!?
We didn't change the alpha value, after all!

Don't panic.
You just created your first filter, and it didn't blow up on you, right?
That must be worth something.
It's to be expected that there's some fine-tuning to do.

It turns out that we forgot to consider "premultiplied alpha" (PMA).
All conventional textures are stored with their RGB channels premultiplied with the alpha value.
So, a red with 50% alpha, like this:

  R = 1, G = 0, B = 0, A = 0.5

would actually be stored like this:

  R = 0.5, G = 0, B = 0, A = 0.5

And we didn't take that into account.
What he have to do is multiply the offset values with the alpha value of the current pixel before adding it to the output.
Here's one way to do that:

[source, as3]
----
tex("ft0", "v0", 0, texture)   // get color from texture
mov ft1, fc0                   // copy complete offset to ft1
mul ft1.xyz, fc0.xyz, ft0.www  // multiply offset.rgb with alpha (pma!)
add  oc, ft0, ft1              // add offset, copy to output
----

As you can see, we can access the `xyzw` properties of the registers to access individual color channels (they correspond with our `rgba` channels).

NOTE: What if the texture is not stored with PMA?
The `tex` method makes sure that we always receive the value with PMA, so no need to worry about that.

==== Second Try

When you give the filter another try now (complete code: https://gist.github.com/PrimaryFeather/31f1dd7f04cd6ce886f1[ColorOffsetFilter.as]), you'll see correct alpha values:

.That's more like it!
image::customfilter-pma-solved.png[Custom Filter with solved PMA issue]

Congratulations!
You just created your first filter, and it works flawlessly.
(Yes, you could have just used Starling's `ColorMatrixFilter` instead — but hey, this one is a tiny little bit faster, so it was well worth the effort.)

If you're feeling brave, you could now try to achieve the same with a mesh style instead.
It's not _that_ different, promised!
