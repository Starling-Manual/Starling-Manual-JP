== カスタムフィルター

手を汚す準備はできていますか？
ついにカスタムレンダリングのコードの分野に取り掛かろうとしています。先ずは簡単なフラグメントフィルターからです。

この作業には低レイヤーのコードを取り扱う必要があります。何行かのアセンブラコードを書くことにもなるでしょう。
しかし恐れることはありません。ロケット工学を扱うわけではないのですから。
昔の数学の先生は言ったものです。訓練を積んだ猿はそんな問題は解いてしまうぞ！と。
//原文：As my old math teacher used to say: a drilled monkey could do that!

NOTE: 覚えておいて欲しいのですが、フィルターはディスプレイオブジェクトのピクセル単位で動きます。
フィルターが適用されたオブジェクトは、一度内部的にテクスチャーに変換され、その後フラグメントシェダーで処理されます。（よってこれをフラグメントフィルターを呼びます。）

=== ゴール

簡単な作成をゴールとしますが、役に立つものであるべきです。
ここでは _ColorOffsetFilter_ を作ることにしましょう。

おそらく、メッシュのどの頂点にもカラーが設定でき、色付けを施すことができる事は知っているかと思います。
レンダリング時にそのカラー設定はテクスチャーのカラーと乗算されます。テクスチャーの色味を調整するシンプルで高速なやり方です。

[source, as3]
----
var image:Image = new Image(texture);
image.color = 0x808080; // R = G = B = 0.5
----

背景にある数学的な演算はとてもシンプルです。GPU では赤・緑・青のどのチャンネルも 0 から 1 の間の数値で表されます。
例えば、純粋な赤は下記のような値になります。

  R = 1, G = 0, B = 0

レンダリング時に、このカラー値は各ピクセルのテクスチャー色(テクセルとも呼ばれます。）と乗算されます。
デフォルトのイメージのカラーは純白です。全てのチャンネル値が１となります。
したがって、テクセルのカラーは変化しません。（１をかける事は何もしない事と同じです。）

異なったカラー値を設定すると乗算結果は新しい色を生み出します。下記はその例です。

  R = 1,   G = 0.8, B = 0.6  ×
  B = 0.5, G = 0.5, B = 0.5
  -------------------------
  R = 0.5, G = 0.4, B = 0.3

そしてここで問題が起きます。この処理はオブジェクトの色味を暗くはしますが、絶対に明るくはしないのです。
何故ならば掛け合わせている値が 0 と 1 の間だけだからです。0 をかける事は黒を作り出します。そして 1 をかけると無変化となります。

.グレーのカラー設定で色味が変化した画像。
image::customfilter-tinting.png[Tinting]

この問題をこれから作るフィルターで解決してみましょう。
カラーの計算にオフセット値を含むようにします。
（Flashでは http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/geom/ColorTransform.html[ColorTransform] の設定として行なっていた事と同じです。)

* 変化後の red 値 = (元の red 値 × red 乗算値) + red オフセット値
* 変化後の green 値 = (元の green 値 × green 乗算値) + green オフセット値
* 変化後の blue 値 = (元の blue 値 × blue 乗算値) + blue オフセット値
* 変化後の alpha 値 = (元の alpha 値 × alpha 乗算値) + alpha オフセット値

乗算する機構はメッシュ基底クラスがすでに持っているので、オフセット値のみがこれから作るフィルターに必要なプロパティとなります。

.全てのチャンネルにオフセット値を与える。
image::customfilter-offset.png[Offset]

では、そろそろ始めますよ？

=== FragmentFilter を継承する

全てのフィルターは例外なく、`starling.filters.FragmentFilter` クラスを継承して作ります。

さてここで、 _ColorOffsetFilter_ クラスの完全なコードを紹介します。仮コードではなく最終のコードです。
この後のコード修正はありません。

[source, as3]
----
public class ColorOffsetFilter extends FragmentFilter
{
    public function ColorOffsetFilter(
        redOffset:Number=0, greenOffset:Number=0,
        blueOffset:Number=0, alphaOffset:Number=0):void
    {
        colorOffsetEffect.redOffset = redOffset;
        colorOffsetEffect.greenOffset = greenOffset;
        colorOffsetEffect.blueOffset = blueOffset;
        colorOffsetEffect.alphaOffset = alphaOffset;
    }

    override protected function createEffect():FilterEffect
    {
        return new ColorOffsetEffect();
    }

    private function get colorOffsetEffect():ColorOffsetEffect
    {
        return effect as ColorOffsetEffect;
    }

    public function get redOffset():Number
    {
        return colorOffsetEffect.redOffset;
    }

    public function set redOffset(value:Number):void
    {
        colorOffsetEffect.redOffset = value;
        setRequiresRedraw();
    }

    // その他の オフセット プロパティも同じようにそれぞれ実装します。

    public function get/set greenOffset():Number;
    public function get/set blueOffset():Number;
    public function get/set alphaOffset():Number;
}
----

驚くほどコンパクトですね。
実はこれはまだ話の半分ほどです。別にもうひとつのクラスを記述する必要があります。そこで、実際の色味を扱う処理が入ります。
しかし、上記のコードも詳細を追う価値があります。

このクラスは _FragmentFilter_ クラスを継承しており、'createEffect' メソッドをオーバーライドしています。
おそらく `starling.rendering.Effect` クラスを扱ったこと人がほとんどだと思いますが、それはローレベルのレンダリング用途でしか必要とならないからです。
API ドキュメントから引用すると、

====
Effect は Stage3D の描画工程の全てをカプセル化します。
レンダーコンテキストを設定し、インデックスバッファ、バーテックスバッファ、シェーダプログラムをセットアップします。
よって、基本的でローレベルな全てのレンダリングメカニズムを提供してくれます。
//原文：It configures the render context and sets up shader programs as well as index- and vertex-buffers, thus providing the basic mechanisms of all low-level rendering.
====

と、あります。

_FragmentFilter_ クラスは、このクラスもしくはこのクラスを継承した _FilterEffect_ というサブクラスを利用します。
今回のシンプルなフィルターのために、`createEffect()` をオーバライドし、カスタムエフェクトを提供します。
//原文：For this simple filter, we just have to provide a custom effect, which we're doing by overriding `createEffect()`.
その他プロパティはエフェクトを調整するだけのためのものです。
レンダリング時には、ベースクラスが、その effect を自動系に扱い、フィルターの描画をしてくれます。
以上となります！

NOTE: `colorOffsetEffect` プロパティが何をしているのか気になるでしょうか。
//原文：If you're wondering what the `colorOffsetEffect` property does:
これは、 _ColorOffsetEffect_ へのキャストを行わずに effect へのアクセスを行うためのただのショートカットです。
ベースクラスは `effect` プロパティを提供します。しかし、それは FilterEffect` 型でのオブジェクトであり、
`offset` プロパティにアクセスするためには、完全な _ColorOffsetEffect_ 型が必要であるわけです。

もっと複雑なフィルターでは `process` メソッドの継承も必要になるかもしれません。例えばマルチパスのフィルターを作る場合などです。
しかし、今回のサンプルフィルターでは必要ありません。

最後に、`setRequiresRedraw` メソッドの呼び出しについて記します。
呼び出す事で、設定が変化した場合に必ずエフェクトの再描画がかかるようにしています。
この呼び出しがないと、Starling はオブジェクトを再描画するべきタイミングを知ることができないのです。

=== FilterEffect を継承する

実際の仕事を行う時間となりました。
この _FilterEffect_ のサブクラスは、サンプルフィルターの働き者と言えます。
これは、複雑だ、という意味ではありません。ちょっと我慢して付いてきてください。
//原文：Which doesn't mean that it's very complicated, so just bear with me.

先ずは仮のスタブコードから始めましょう。

[source, as3]
----
public class ColorOffsetEffect extends FilterEffect
{
    private var _offsets:Vector.<Number>;

    public function ColorOffsetEffect()
    {
        _offsets = new Vector.<Number>(4, true);
    }

    override protected function createProgram():Program
    {
        // TODO
    }

    override protected function beforeDraw(context:Context3D):void
    {
        // TODO
    }

    public function get redOffset():Number { return _offsets[0]; }
    public function set redOffset(value:Number):void { _offsets[0] = value; }

    public function get greenOffset():Number { return _offsets[1]; }
    public function set greenOffset(value:Number):void { _offsets[1] = value; }

    public function get blueOffset():Number { return _offsets[2]; }
    public function set blueOffset(value:Number):void { _offsets[2] = value; }

    public function get alphaOffset():Number { return _offsets[3]; }
    public function set alphaOffset(value:Number):void { _offsets[3] = value; }
}
----

ここでは、offsets プロパティを _Vector_ 型の中に格納しています。その方が GPU へのアップロード時に都合がいいからです。
`offset` プロパティを、ベクターの中に読み書きする。シンプルです。

２つの継承メソッドについて見ていくと、さらに面白くなってきます。

==== createProgram

このメソッドは実際の Stage3D シェーダーコードを作成します。

[NOTE]
====
基本的な事柄は解説しますが、_Stage3D_ の全てについてそれを行うのはこのマニュアルの範疇を超えます。
さらに詳細な情報が必要であれば、下記リンクのチュートリアルを参照することができます。

  * http://www.adobe.com/devnet/flashplayer/articles/how-stage3d-works.html[How Stage3D works]
  * http://jacksondunstan.com/articles/1661[Introduction to AGAL]
  * http://help.adobe.com/en_US/as3/dev/WSd6a006f2eb1dc31e-310b95831324724ec56-8000.html[List of AGAL operations]
====

Stage3D の全てのレンダリングは、バーテックス()シェーダーとフラグメント(断片)シェーダーを通して行われます。
これらは GPU によって直接実行される小さなプログラムで、２つの役割を持ちます。

* *バーテックスシェーダー* はそれぞれの頂点に対して１度だけ実行されます。
入力情報は、頂点の属性値から作成され、通常 `VertexData` クラスを通して設定します。
出力情報は、スクリーン座標系での位置情報です。
* *フラグメントシェーダー* は１ピクセル(=断片=フラグメント)ごとに１回実行されます。
入力情報は関連する三角ポリゴンの３つの頂点の情報がピクセルの位置によって補完されたものです。
出力情報は、シンプルにそのピクセルのカラー情報です。
* ２つのシェーダが合わさって１つの *Program* を作成します。

フィルターが記述されている言語は AGAL と呼ばれます。アセンブラ言語です。
（読んだ通り、この言語はローベル中のローベルです。）
//原文：(Yes, you read right! This is as low-level as it gets.)
しかしながら、ありがたいことに大抵の AGAL プログラムはとても短く、そこまでひど事にはなりません。
//原文：Thankfully, however, typical AGAL programs are very short, so it's not as bad as it sounds.

良いニュースとして、今回はフラグメントシェーダーを書くだけですみます。
バーテックスシェーダーは大抵のフィルターで同じになるので、Starling は標準的なバーテックスシェーダーの実装を提供します。
では、そのコードを見てみましょう。

[source, as3]
----
override protected function createProgram():Program
{
    var vertexShader:String = STD_VERTEX_SHADER;
    var fragmentShader:String =
        "tex ft0, v0, fs0 <2d, linear> \n" +
        "add oc, ft0, fc0";

    return Program.fromSource(vertexShader, fragmentShader);
}
----

説明したように、バーテックスシェーダーは定数から取得されます。
フラグメントシェーダーはたったの２行です。
２つのシェーダーは合わせて１つの _Program_ インスタンスとなり、メソッドの戻り値となります。

フラグメントシェーダーにはもう少しの労力が必要です。
//原文：The fragment shader requires some further elaboration, of course.

===== AGAL コード概要

AGAL は、各行にシンプルな命令が記述されます。

  [命令] [出力場所], [引数１], ([引数２])

* 最初の３文字はオペーレーション名です。 (`tex`, `add`).
* 次の引数はオペレーション結果をどこに保存するかを指定します。
* 他の引数はオペレーションの実際の引数となるものです。
* 全てのデータはあらかじめ定義済みのレジスタに保持されます。
それらレジスタは _Vector3D_ インスタンスだと考えましょう。x、y、zのプロパティを持ちます。

レジスタにはいくつかの種類があります。例えば、定数、一時データ、シェーダーの出力用などです。
今回のシェーダーでは、そのうちいくつかはあらかじめ値を持っています。フィルターの他のメソッドによって設定されています。
（後ほど解説します。）

* `v0` (_varying レジスタ 0_)は、現在のテクスチャ座標を保持しています。
* `fs0` (_fragment サンプラ 0_)は、入力テクスチャを示します。
* `fc0` (_fragment 定数 0_)は、カラーオフセット値を保持しています。今回のキモです。
//原文：contains the color offset this is all about

フラグメントシェーダの結果はいつもカラー値となります。 出力カラー値は `oc` レジスタに格納します。

===== AGAL コード詳細

今回のフラグメントシェーダーの実際のコードを見てみましょう。
*最初の行* はカラー値をテクスチャから読み取っています。

    tex ft0, v0, fs0 <2d, linear>

`fs0` が表すテクスチャーから、`v0` が表すテクスチャ座標でカラー値を読み取ります。その際 `2d, linear` という言うオプション情報が付与されています。
`v0` にテクスチャ座標が保持されている理由は、標準バーテックスシェーダー (`STD_VERTEX_SHADER`) で設定しているからです。ここに関してはそうなのだ、と思ってください。
結果は一時レジスタの `ft0`に保持されます。（ AGAL では、演算結果がいつでも命令の第一引数に格納されることを思い出してください。）

[NOTE]
====
ちょっとここで考えて見ましょう。まだテクスチャの設定を行なっていませんよね？これはどういうことでしょう？

上で述べたように、フラグメントフィルターはピクセル毎に実行されます。フィルターへの入力は、元々のディスプレイオブジェクトが一度内部的なテクスチャとして描画されたものです。
//原文：As I wrote above, a fragment filter works at the pixel level; its input is the original object, rendered into a texture.
ベースクラスの _FilterEffect_ がそれを行なってくれます。プログラムが実行される時、テクスチャーサンプラー `fs0` はフィルターをかけようとしているテクスチャを指しています。
//原文：Our base class (_FilterEffect_) sets that up for us; when the program runs, you can be sure that the texture sampler `fs0` will point to the pixels of the object being filtered.
====

さて、ここでこの行についてちょっとだけ変更したい点があります。
//原文：You know what, actually I'd like to change this line a little.
行の最後にオプション指定があるのに気づいているかと思います。これはどのようにテクスチャデータを解釈するか指定しているものです。
しかし、アクセスしようとしてるテクスチャのタイプによって、このオプションは変化する事が判明しました。
どのテクスチャでもこのコードが動くようにするため、AGAL コードを記述してくれるヘルパーメソッドを用意したので、これを使いましょう。
//原文：To be sure the code works for every texture, let's use a helper method to write that AGAL operation.

[source, as3]
----
tex("ft0", "v0", 0, this.texture)
----

このメソッドは AGAL 文字列を返します。そして先のコードと同じ振る舞いをします。そしてオプションの内容についてはもうケアする必要がありません。
テクスチャにアクセスする際はいつもこのメソッドを利用してください。夜にぐっすり眠れるようになりますよ。

そして２行目は、今回のフィルターのキモの部分です。カラーオフセット値をテクセルカラーに加算します。
オフセット値は `fc0` に保持されています。ざっと見てみましょう。 テクセルカラー値が格納された `ft0` レジスタとkさんされた、出力レジスタの `oc` に代入されています。

    add oc, ft0, fc0

AGAL コードはとりあえずこのような感じです。
その他のオーバーライドされたメソッドを見てみましょう。

==== beforeDraw

`beforeDraw` メソッドはシェーダーが実行される前に直接実行されます。シェーダーに必要なデータを前もって設定しておくことができます。

[source, as3]
----
override protected function beforeDraw(context:Context3D):void
{
    context.setProgramConstantsFromVector(Context3DProgramType.FRAGMENT, 0, _offsets);
    super.beforeDraw(context);
}
----

ここで、フラグメントシェーダーにオフセット値を渡しています。
２番目のパラメータの `0` は、データが格納されるレジスタを意味しています。
シェーダーのコードを見返すと、オフセット値を `fc0` から読み取っています。そここそがデータを格納した  `fragment constant 0` です。

super の呼び出しの箇所では残りのセットアップを行います。テクスチャを `fs0` に設定したり、テクスチャ座標を設定したりします。

NOTE: 尋ねられる前に。`afterDraw()` メソッドも同様に存在します。このメソッドは通常利用したリソースを開放するのに使われます。
しかし、定数に対しては必要ありません。よって今回のフィルターではそこの実装は行いません。

=== 動作確認

さあ、フィルターの実装ができました！（完全なコードは https://gist.github.com/PrimaryFeather/ba1e26d568320cd31086[ここ] から手に入ります。）
早速テストしてみましょう。

[source, as3]
----
var image:Image = new Image(texture);
var filter:ColorOffsetFilter = new ColorOffsetFilter();
filter.redOffset = 0.5;
image.filter = filter;
addChild(image);
----

.フィルターの見た目はちょっとがおかしな状態のようです。
image::customfilter-pma.png[Custom Filter PMA Issue]

なんてことでしょう！
たしかに設定どおり赤味は強まっています。しかし、鳥の外側までそれが広がってしまっているのでしょう？
アルファ値は全くいじっていないというのに！

慌てないでください。
まだ最初のフィルターを作ったばかりですし、そんなに大げさな事ではありませんね。
これは意味のある事なのです。
予想された事で、微調整する部分です。

"premultiplied alpha" (PMA) という仕組みについて考慮するのを忘れていた事がわかりました。
通常の全てのテクスチャは RGB値がアルファ値であらかじめ乗算された状態で保持されているのです。
５０％のアルファ値の赤は下記のようになりますが、

  R = 1, G = 0, B = 0, A = 0.5

実際は下記のように保存されています。

  R = 0.5, G = 0, B = 0, A = 0.5

これを考慮に入れていませんでした。
するべき事は、オフセットRGB値を足す前に現在の対象ピクセルのアルファ値を乗算してやることです。
下記のようにして実現することができます。

[source, as3]
----
tex("ft0", "v0", 0, texture)   // カラー値をテクスチャから読み取る
mov ft1, fc0                   // ft1 にカラーオフセット値をコピーする
mul ft1.xyz, fc0.xyz, ft0.www  // オフセット値のRGB要素にテクスチャのアルファ値を乗算する (pma!)
add  oc, ft0, ft1              // オフセット値をテクスチャに加えてアウトプットとする
----

上のコードにあるように、レジスタの `xyzw` プロパティに個別アクセスすることが可能です。それぞれ `rgba` チャンネルの内容を表します。

NOTE: もしもテクスチャが PMA 形式で保持されていなかったらどうすればいいでしょう？
`tex` メソッドは 必ず PMA 形式のテクスチャを返すので、心配することはありません。

==== 改めて動作確認

この調整でただしいアルファの見た目を得ることができました。（完全なコードはここにあります： https://gist.github.com/PrimaryFeather/31f1dd7f04cd6ce886f1[ColorOffsetFilter.as] ）

.良い感じなりました！
image::customfilter-pma-solved.png[Custom Filter with solved PMA issue]

おめでとうございます。正しく動くフィルターを作り終えることができました。
（実は代わりに Starling の `ColorMatrixFilter` を使うことでも同じことはできるのですが、今回作ったフィルターのほうが若干高速に動作します。よって努力の甲斐はあるのです。）

フィルターが作れたことに満足したでしょうか？では、次はメッシュスタイルを作る事に挑戦してはどうでしょう。
そんなに変わりはありませんよ、約束します！
