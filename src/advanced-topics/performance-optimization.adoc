== パフォーマンス チューニング
// 他ページとの連携で 'パフォーマンス チューニング' と訳すこと

Starling は Flash のディスプレイリストの構成を真似ていますが、背後にある実装の仕組みは全く異なっています。
最も良いパフォーマンスを得るためには、どのような仕組みで動いているのか、そのキーコンセプトを理解する必要があります。
下記のリストは、ゲームをできるだけ早く動かすために必要なベストプラクティスとなります。

=== 一般的な AS3 のチップス
//↑見出しなので =  の数が異なる

==== いつでもリリースビルドを使う

最初に考えなくてはならない最も大事なルールは、パフォーマンステストを行う際は、必ずリリースビルドを使うという事です。
通常の Flash プロジェクトと異なり、Stage3D を使ったフレームワークを扱う場合、リリースビルドとデバッグビルドには大きな違いがあります。
スピードの差は膨大です。開発対象のプラットフォームによっては、デバッグビルドのフレームレートの何倍もの値を得る事ができるでしょう。

* Flash Builder では、_menu:Project[Export Release Build]_ をクリックする事でリリースビルドを作成できます。
* Flash Develop では、"Release" 設定を選択して、プロジェクトをビルドしましょう。
その後、"ipa-ad-hoc" もしくは "ipa-app-store" オプションを選択して、"PackageApp.bat" スクリプトを実行します。
* IntelliJ IDEA では、_menu:Build[Package AIR Application]_ を選択し、アンドロイドでは "release"、 iOS では "ad hoc distribution" を選択します。
//原文： In IntelliJ IDEA, select _menu:Build[Package AIR Application]_; choose "release" for Android and "ad hoc distribution" for iOS.
AIR プロジェクトでない場合は、モジュールのコンパイラオプション設定にて、"Generate debuggable SWF" の選択を外します。
* Starling プロジェクトをコマンドラインでビルドしている場合は、必ず、`-optimize` を true にして `-debug` が false になるようにします。

.Flash Builder のダイアログに惑わされないようにしましょう。
image::not-release-build.png[Flash Builder Dialog]

==== ハードウェアをチェックする

Starling が本当に GPU レンダリングで動いているか確かめましょう。
やり方は簡単です。もしも、`Starling.current.context.driverInfo` の値が `Software` という文字列を含んでいたら、それは Stage3D がフォールバックモードになっている事を示します。
そうでなければ GPU を使ったレンダリングが行われています。

また、いくつかのモバイルデバイスでは、 _バッテリーセーブモード_ で動いている事があります。
パフォーマンステストを行う場合は、それが間違いなく off となっている事を確認しましょう。

==== フレームレートの設定

どのように頑張っても、何故かフレームレートが 24FPS で頭打ちになった場合、
おそらく目的のフレームレートをまだ設定しておらず、Flash Player のデフォルトの状態になっているのかと思われます。

変更するには、起動クラスの適切な _metadata_ を使うか、stage の framerate 設定を行います。

[source, as3]
----
[SWF(frameRate="60", backgroundColor="#000000")]
public class Startup extends Sprite
{ /* ... */ }

// もしくはソース中のどこかで
Starling.current.nativeStage.frameRate = 60;
----

==== Adobe Scout を用いる

_Adobe Scout_ は <<memory_management_scout, メモリー利用状況の分析>> だけに役に立つのではありません。
パフォーマンスのプロファイリングという事であればとてもパワフルに役に立ちます。

Scout を使うと、Starling 内外の _ActionScript_ 各々のコードが、どのくらい実行に時間がかかっているのか確認する事ができます。
これはとても有用です。なぜなら、最適化処理を施すべき箇所を示してくれるからです。

そのような場所の特定をしない場合、実際には全くフレームレートの改善に役に立たないコードを最適化してしまうかもしれません！

TIP: 早い段階でのパフォーマンスチューニングは、諸悪の根源！ である事を知っておいて下さい。

古典的なプロファイラと比べて良いと言える部分は、Scout はリリースビルドである(デバッグモードではないので全ての最適化がなされた)swfやAIRを対象にしても動くという所です。
//原文：What's nice compared to classic profilers is that it also works in release mode, with all optimizations in place.
Scout で計測される内容がとても正確である事が保証されます。
//原文：That ensures that its output is extremely accurate.

==== ロードされたイメージを非同期でデコードする

デフォルトでは、_Loader_ クラスを PNG や JPEG をロードするために使った場合、イメージデータはすぐさまデコードされません。実際に最初に使うタイミングでデコードされるのです。
これはメインスレッド上で処理され、テクスチャの作成時に青アプリケーションが突っかかるような状態になる事があります。
そのような事態を避けるには、デコードのポリシー設定を `ON_LOAD` にしましょう。
そうすれば、デコード処理はローダーのバックグラウンドスレッドで直接行われるようになります。

[source, as3]
----
loaderContext.imageDecodingPolicy = ImageDecodingPolicy.ON_LOAD;
loader.load(url, loaderContext);
----

一方で、イメージのロードには Starling の _AssetManager_ を使っているでしょうか？
そうであれば、上記のテクニックはすでに使われているので心配はしなくて大丈夫です。

==== "for each" の利用を控える

頻繁に繰り返されるループや深くネストされたループを扱う場合、`for each` を避けた方が良いです。
原始的な `for i` は http://jacksondunstan.com/articles/358[より良い] パフォーマンスをもたらします。
さらに、ループ終了条件がループごとに１度しか評価されないように気をつけましょう。
つまり、別の変数にそれを保持するのがさらに速いという事です。

[source, as3]
----
// やや遅い:
for each (var item:Object in array) { ... }

// 取り良い:
for (var i:int=0; i<array.length; ++i) { ... }

// 最も速い:
var length:int = array.length;
for (var i:int=0; i<length; ++i) { ... }
----

==== アロケーションを避ける

たくさんの一時的なオブジェクトを利用するのは避けましょう。
メモリを利用した後にガベージコレクターによって回収される必要が生じます。その間小さなしゃっくり(プチフリーズ)を伴うかもしれません。

[source, as3]
----
// 悪い例:
for (var i:int=0; i<10; ++i)
{
    var point:Point = new Point(i, 2*i);
    doSomethingWith(point);
}

// 良い例:
var point:Point = new Point();
for (var i:int=0; i<10; ++i)
{
    point.setTo(i, 2*i);
    doSomethingWith(point);
}
----

実際には、Starling は上記の最適化を手助けするクラスが存在します。_Pool_ というクラスです。
このクラスはしばしば利用されるオブジェクトを再利用のために保持する"プール"を提供してくれます。
保持されるクラスは_Point_、 _Rectangle_、 _Matrix_ などです。
プールからこれらのオブジェクトを "借りて"、使い終わった後はそこへ返しましょう。

[source, as3]
----
// 最も良い例:
var point:Point = Pool.getPoint();
for (var i:int=0; i<10; ++i)
{
    point.setTo(i, 2*i);
    doSomethingWith(point);
}
Pool.putPoint(point); // この処理を忘れない事！
----

=== Starling 固有のチップス
//↑見出しなので =  の数が異なる


==== ステージの変化を最小にする

知っての通り、Starling は Stage3D をディスプレイリストの描画に利用します。
これは全ての描画処理が GPU で行われる事を意味します。

ここで、Starling はQuad (矩形) の１つ１つを個別に GPU に送って描画させる事もできます。
実際、これは Starling の最初の頃のリリースで行なっていた方法です。
しかし、最高のパフォーマンスを出すために、GPU にはいっぺんにたくさんのでデーターを渡して１回で描画してもらうのが良いのです。

これが、その後の Starling のバージョンができるだけたくさんの Quad をバッチして GPU に送っている理由です。
ですが、バッチ処理でまとめられるのは似たようなプロパティを持っている Quad だけなのです。
Quad の状態が切り替わるたび、"ステートの変更" が生じて、そこまでのバッチが描画されます。

[NOTE]
====
このセクションでは _Quad_ と _Image_ を同義的に扱っています。
_Image_ は _Quad_ のサブクラスで、いくつかのメソッドが追加されただけなのです。
さらに、_Quad_　は _Mesh_ を継承しており、以下に書く事はメッシュに対しても同様に当てはまります。 .
====

以下は、ステートを決定する重要なプロパティです。

* _テクスチャー_ の設定。 (なのですが、同じアトラス内の異るサブテクスチャーは状態を変えません)
* ディスプレイオブジェクトの _ブレンドモード_ 設定。
* メッシュ/Quad/イメージ　の _textureSmoothing_ 設定。
* メッシュ/Quad/イメージ　の _textureRepeat_ 設定。

できる限りステート変化を抑えるようにアプリのシーンを設定する事で、
レンダリングのパーフォーマンスは著しく向上するでしょう。

再度言います、Starling の statics 表示は有益な情報を与えてくれます。
１フレームでどれだけのドローコールが発生したかの回数を表示します。
ステートの変化が多いほど、ドローコール回数も多くなっていくでしょう。

.statistics 表示には 現在のドローコール数も表示されています。
image::stats-display.png[Statistics Display]

[NOTE]
====
statistics 表示自体もドローコールを消費します。
しかし、Starling はその増加分を差し引いたドローコール数を表示してくれます。
====

やるべき事は、できる限りステートの変化を抑える事、です。
具体的な方法については下に続きます。

===== ペインターアルゴリズム

どのようにステートの変化を抑えるかを知るためには、まず Starling がどのようにディスプレイオブジェクトを処理するのかを知らなくてはいけません。

Flash のように、Starling もディスプレイリストを処理するために _ペインターアルゴリズム_ を利用します。これは、実際の画家のようにシーンを描画するアルゴリズムです。
一番背面のオブジェクト（例えば背景画像など）から処理を初めて、だんだんと前面に進んでいきます。前に描画したオブジェクトの上に次のものを重ねて描画していきます。

.ペインターアルゴリズムで描画されたシーン。
image::painters-algorithm.png[Painter's algorithm]

Starling でシーンを生成した際、３つのスプライトを配置したとします。一つは山の領域、１つは地面、一つは植物を描画という具合です。
山は一番下層にあり (index 0)、植物は最前面 (index 2) にあります。各々のスプライトはそれぞれを構成する画像をいくつか含むとします。

.上記の設定による光景のシーン構造。
image::landscape.png[Landscape Scene Graph]

レンダリングのタイミングでは、Starling は図の左の "Mountain 1" から右に向かい、一番右の "Tree 2" に到達するまで処理を進めます。
もしもそれら全てのオブジェクトが異なったステートである場合、6回のドローコールが必要となってしまいます。
これは、それぞれのテクスチャーを異なるビットマップ画像から読み込んでいる場合に起こりえる事です。

// <note tip>
// Another tool at your disposal is the [[http://doc.starling-framework.org/core/starling/display/DisplayObjectContainer.html#sortChildren()|DisplayObjectContainer::sortChildren()]] method which can be used to sort layers, within a ''Sprite'' object for example, based on properties such as ''x'', ''y'', ''alpha'' etc. The method accepts a compare function which means you can sort objects based on any criteria you wish! :-D
// </note>

===== The Texture Atlas

That's one of the reasons why texture atlases are so important.
If you load all those textures from one single atlas, Starling will be able to draw all objects at once!
(At least if the other properties listed above do not change.)

.The same scene graph, now using a single atlas texture.
image::landscape-2.png[Landscape Scene Graph 2]

The consequence of this is that you should _always_ use an atlas for your textures.
Here, each image uses the same atlas (depicted by all nodes having the same color).

Sometimes, though, not all of your textures will fit into a single atlas.
The size of textures is limited, so you'll run out of space sooner or later.
But this is no problem, as long as you arrange your textures in a smart way.

.The order of objects makes a difference.
image::landscape-3.png[Landscape Scene Graph 3]

Both those examples use two atlases (again, one color per atlas).
But while the display list on the left will force a state change for each object, the version on the right will be able to draw all objects in just two batches.

==== Use the MeshBatch class

The fastest way to draw a huge number of quads or other meshes at once is to use the _MeshBatch_ class.
That's the same class that is used internally by Starling for all rendering, so it's heavily optimized.footnote:[If you're still using Starling 1.x, look for ''QuadBatch'' instead.]
It works like this:

[source, as3]
----
var meshBatch:MeshBatch = new MeshBatch();
var image:Image = new Image(texture);

for (var i:int=0; i<100; ++i)
{
    meshBatch.addMesh(image);
    image.x += 10;
}

addChild(meshBatch);
----

Did you notice? You can add the same image as often as you want!
Furthermore, adding it is a very fast operation; e.g. no event will be dispatched (which is the case when you add an object to a container).

As expected, this has some downsides, though:

* All the objects you add must have the same state (i.e. use textures from the same atlas).
  The first image you add to the MeshBatch will decide on its state.
  You can't change the state later, except by resetting it completely.
* You can only add instances of the _Mesh_ class or its subclasses (that includes _Quad_, _Image_, and even _MeshBatch_).
* Object removal is quite tricky: you can only remove meshes by trimming the number of vertices and indices of the batch.
  However, you can overwrite meshes at a certain index.

For these reasons, it's only suitable for very specific use-cases (the _BitmapFont_ class, for example, uses a mesh batch internally).
In those cases, it's definitely the fastest option, though. You won't find a more efficient way to render a huge number of objects in Starling.

==== テキストフィールドをバッチする

デフォルトでは、１つのテキストフィールドは１回のドローコールを必要とします。フォントのテクスチャが他のメインのテクスチャと同じだったとしてもです。
何故ならば、長いテキストはバッチするために、たくさんの CPU 時間を必要とするからです。

_MeshBatch_ にメッシュをコピーせず、そのままシンプルにドローした方が速いのです。

しかし、テキストフィールドのテキスト数が少ない場合（経験的には16文字より少ない場合)、TextField の `batchable` プロパティを有効にする事ができます。
これが有効の場合、テキストフィールドは他のディスプレイオブジェクトと同様にバッチ処置されます。

==== BlendMode 設定を NONE にする

もしも矩形テクスチャが完全に不透明であるのなら、ブレンド処理を無効にする事で、GPU の負荷を減らしてあげましょう。
大きな背景画像などで役に立つと思います。

[source, as3]
----
backgroundImage.blendMode = BlendMode.NONE;
----

通常は、このテクニックによって描画ステートの変化ももたらす（ドローコールが増える）ため、多用してはいけません。
小さな画像に対しては、おそらく適用する価値がありません。（なんにしろ何か別の理由で描画ステートが変化するのなら避けましょう。）

==== ステージカラー設定を活用する

しばしば、ステージに設定されたカラーはゲーム中に見えない状態である事があります。なぜならステージ上にあるイメージやメッシュによって隠されてしまっているからです。
その場合、ステージ色の設定は完全な黒（`0x0`）か完全な白（`0xffffff`）に設定するようにしましょう。
いくつかのモバイルプラットフォームでは、`context.clear` が '1' または '0' で呼ばれた場合に、ハードウェアの最適化処理が走る事があります、
何人かの開発者が１フレームごとにミリ秒単位でのレンダリング時間をレポートしてくれましたが、そのような簡単な変更で大きな速度改善があったとの事です！

[source, as3]
----
[SWF(backgroundColor="#0")]
public class Startup extends Sprite
{
    // ...
}
----

一方で、バックグラウンドカラーがフラットな色である場合、それをステージをうまく使う事ができます。
イメージや着色された Quad を配置するのでなく、ステージ色を設定しましょう。
どちらにしろ Starling は１フレームに１回画面をクリアし直すのです。したがってステージカラーを変更したとしてもなんの描画コストも増えません。

[source, as3]
----
[SWF(backgroundColor="#ff2255")]
public class Startup extends Sprite
{
    // ...
}
----

==== width 及び height の参照を控える

`width` と `height` プロパティは予想するよりもずっと高コストな物となっています。特にスプライトにおいてそれが顕著です。
行列演算が必要であり、各々の子孫ディスプレイオブジェクトの各々の頂点を処理させる必要があります。

そのような理由で、例えばループの中など、繰り返しそれらのプロパティにアクセスする事は避けるようにしましょう。
いくつのかのクラスでは、定数値を代わりに使った方が理にかないます。
//原文：In some cases, it might even make sense to use a constant value instead.
//具体的にはどういう事だろう？

[source, as3]
----
// 悪い例:
for (var i:int=0; i<numChildren; ++i)
{
    var child:DisplayObject = getChildAt(i);
    if (child.x > wall.width)
        child.removeFromParent();
}

// 良い例:
var wallWidth:Number = wall.width;
for (var i:int=0; i<numChildren; ++i)
{
    var child:DisplayObject = getChildAt(i);
    if (child.x > wallWidth)
        child.removeFromParent();
}
----

==== コンテナのタッチ判定を無効にする

指やマウスを画面上でスライドして動かす際、Starling はどのオブジェクトがその下に存在するのか探索しなければいけません。
これは高負荷な処理です。最悪の場合、全てのディスプレイオブジェクトとの当たり判定を行わなくてはいけないのです。

よってタッチ判定される必要のないオブジェクトに関しては、タッチ無効の設定にしてしまうと状況が改善します。
コンテナであるディスプレイオブジェクトのタッチを完全に無効としてしまうのが最善です。
そうすれば Starling が子孫ディスプレイオブジェクト全ての当たり判定を行う必要がなくなります。

[source, as3]
----
// 良い例:
for (var i:int=0; i<container.numChildren; ++i)
    container.getChildAt(i).touchable = false;

// さらに良い例:
container.touchable = false;
----

==== ステージ領域から外れたオブジェクトを隠す

Starling はディスプレイリスト上のどのオブジェクトも GPU へと送信します。
これは、オブジェクトがステージの領域外にあった場合でも同様です。

こう思うかもしれません。Starling は目に見えないそれらのオブジェクトを無効にしてくれないのだろうと。
その理由は、表示されているかどうかを普遍的にチェックする事は、とても計算が高くつくからです。
実際にそれはとても割高で、全てのオブジェクトを GPU に送信して、クリッピングして表示した方が早いのです。
GPU はそのような動作でとても効率的で、オブジェクトが画面外である場合、レンダリング処理の早い段階で、それらは描画処理から取り除かれます。

しかし、やはりデータのアップロードには時間がかかります。そしてそれを避ける事は可能です。
ハイレベルなゲームロジックでは、オブジェクトが実際に表示されているかのチェックはしばしば簡単なものとなります。
（例えば、ただ定数に対して、x及びy座標をチェックするだけで済む事があります。）
もしもたくさんのオブジェクトがその表示領域から外れている場合、チェックする努力を払う価値はあります。
それらをステージから取りさるか、`visible` 値を false にしましょう。

==== Event オブジェクトをプールする

Starling は Flash のシステムにはない、イベントの発火に関する新しいメソッドを追加しました。

[source, as3]
----
// 今までのやり方
object.dispatchEvent(new Event("type", bubbles));

// 新しいやり方
object.dispatchEventWith("type", bubbles);
----

新しいアプローチは、今までのものとあまり変わりがないように見えます。
しかしシーンの裏側では、イベントオブジェクトの使い回しを行なっています。
これによって、無駄なガベージコレクションの発動を抑えることができます。

言い換えると、コード記述量が減って、動作も速くなる、という事です。したがってこれが推奨されるイベントの発火方法となります。
(もしも `Event` クラスのカスタムサブクラスを用いる必要がある場合、新しいやり方は取れません。)

