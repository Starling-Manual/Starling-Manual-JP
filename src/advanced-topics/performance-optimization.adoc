== パフォーマンス チューニング
// 他ページとの連携で 'パフォーマンス チューニング' と訳すこと

Starling は Flash のディスプレイリストの構成を真似ていますが、背後にある実装の仕組みは全く異なっています。
最も良いパフォーマンスを得るためには、どのような仕組みで動いているのか、そのキーコンセプトを理解する必要があります。
下記のリストは、ゲームをできるだけ早く動かすために必要なベストプラクティスとなります。

=== 一般的な AS3 のチップス
//↑見出しなので =  の数が異なる

==== いつでもリリースビルドを使う

最初に考えなくてはならない最も大事なルールは、パフォーマンステストを行う際は、必ずリリースビルドを使うという事です。
通常の Flash プロジェクトと異なり、Stage3D を使ったフレームワークを扱う場合、リリースビルドとデバッグビルドには大きな違いがあります。
スピードの差は膨大です。開発対象のプラットフォームによっては、デバッグビルドのフレームレートの何倍もの値を得る事ができるでしょう。

* Flash Builder では、_menu:Project[Export Release Build]_ をクリックする事でリリースビルドを作成できます。
* Flash Develop では、"Release" 設定を選択して、プロジェクトをビルドしましょう。
その後、"ipa-ad-hoc" もしくは "ipa-app-store" オプションを選択して、"PackageApp.bat" スクリプトを実行します。
* IntelliJ IDEA では、_menu:Build[Package AIR Application]_ を選択し、アンドロイドでは "release"、 iOS では "ad hoc distribution" を選択します。
//原文： In IntelliJ IDEA, select _menu:Build[Package AIR Application]_; choose "release" for Android and "ad hoc distribution" for iOS.
AIR プロジェクトでない場合は、モジュールのコンパイラオプション設定にて、"Generate debuggable SWF" の選択を外します。
* Starling プロジェクトをコマンドラインでビルドしている場合は、必ず、`-optimize` を true にして `-debug` が false になるようにします。

.Flash Builder のダイアログに惑わされないようにしましょう。
image::not-release-build.png[Flash Builder Dialog]

==== ハードウェアをチェックする

Starling が本当に GPU レンダリングで動いているか確かめましょう。
やり方は簡単です。もしも、`Starling.current.context.driverInfo` の値が `Software` という文字列を含んでいたら、それは Stage3D がフォールバックモードになっている事を示します。
そうでなければ GPU を使ったレンダリングが行われています。

また、いくつかのモバイルデバイスでは、 _バッテリーセーブモード_ で動いている事があります。
パフォーマンステストを行う場合は、それが間違いなく off となっている事を確認しましょう。

==== フレームレートの設定

どのように頑張っても、何故かフレームレートが 24FPS で頭打ちになった場合、
おそらく目的のフレームレートをまだ設定しておらず、Flash Player のデフォルトの状態になっているのかと思われます。

変更するには、起動クラスの適切な _metadata_ を使うか、stage の framerate 設定を行います。

[source, as3]
----
[SWF(frameRate="60", backgroundColor="#000000")]
public class Startup extends Sprite
{ /* ... */ }

// もしくはソース中のどこかで
Starling.current.nativeStage.frameRate = 60;
----

==== Adobe Scout を用いる

_Adobe Scout_ は <<memory_management_scout, メモリー利用状況の分析>> だけに役に立つのではありません。
パフォーマンスのプロファイリングという事であればとてもパワフルに役に立ちます。

Scout を使うと、Starling 内外の _ActionScript_ 各々のコードが、どのくらい実行に時間がかかっているのか確認する事ができます。
これはとても有用です。なぜなら、最適化処理を施すべき箇所を示してくれるからです。

そのような場所の特定をしない場合、実際には全くフレームレートの改善に役に立たないコードを最適化してしまうかもしれません！

TIP: 早い段階でのパフォーマンスチューニングは、諸悪の根源！ である事を知っておいて下さい。

古典的なプロファイラと比べて良いと言える部分は、Scout はリリースビルドである(デバッグモードではないので全ての最適化がなされた)swfやAIRを対象にしても動くという所です。
//原文：What's nice compared to classic profilers is that it also works in release mode, with all optimizations in place.
Scout で計測される内容がとても正確である事が保証されます。
//原文：That ensures that its output is extremely accurate.

==== ロードされたイメージを非同期でデコードする

デフォルトでは、_Loader_ クラスを PNG や JPEG をロードするために使った場合、イメージデータはすぐさまデコードされません。実際に最初に使うタイミングでデコードされるのです。
これはメインスレッド上で処理され、テクスチャの作成時に青アプリケーションが突っかかるような状態になる事があります。
そのような事態を避けるには、デコードのポリシー設定を `ON_LOAD` にしましょう。
そうすれば、デコード処理はローダーのバックグラウンドスレッドで直接行われるようになります。

[source, as3]
----
loaderContext.imageDecodingPolicy = ImageDecodingPolicy.ON_LOAD;
loader.load(url, loaderContext);
----

一方で、イメージのロードには Starling の _AssetManager_ を使っているでしょうか？
そうであれば、上記のテクニックはすでに使われているので心配はしなくて大丈夫です。

==== "for each" の利用を控える

頻繁に繰り返されるループや深くネストされたループを扱う場合、`for each` を避けた方が良いです。
原始的な `for i` は http://jacksondunstan.com/articles/358[より良い] パフォーマンスをもたらします。
さらに、ループ終了条件がループごとに１度しか評価されないように気をつけましょう。
つまり、別の変数にそれを保持するのがさらに速いという事です。

[source, as3]
----
// やや遅い:
for each (var item:Object in array) { ... }

// 取り良い:
for (var i:int=0; i<array.length; ++i) { ... }

// 最も速い:
var length:int = array.length;
for (var i:int=0; i<length; ++i) { ... }
----

==== アロケーションを避ける

たくさんの一時的なオブジェクトを利用するのは避けましょう。
メモリを利用した後にガベージコレクターによって回収される必要が生じます。その間小さなしゃっくり(プチフリーズ)を伴うかもしれません。

[source, as3]
----
// 悪い例:
for (var i:int=0; i<10; ++i)
{
    var point:Point = new Point(i, 2*i);
    doSomethingWith(point);
}

// 良い例:
var point:Point = new Point();
for (var i:int=0; i<10; ++i)
{
    point.setTo(i, 2*i);
    doSomethingWith(point);
}
----

実際には、Starling は上記の最適化を手助けするクラスが存在します。_Pool_ というクラスです。
このクラスはしばしば利用されるオブジェクトを再利用のために保持する"プール"を提供してくれます。
保持されるクラスは_Point_、 _Rectangle_、 _Matrix_ などです。
プールからこれらのオブジェクトを "借りて"、使い終わった後はそこへ返しましょう。

[source, as3]
----
// 最も良い例:
var point:Point = Pool.getPoint();
for (var i:int=0; i<10; ++i)
{
    point.setTo(i, 2*i);
    doSomethingWith(point);
}
Pool.putPoint(point); // この処理を忘れない事！
----

=== Starling 固有のチップス
//↑見出しなので =  の数が異なる


==== Minimize State Changes

As you know, Starling uses Stage3D to render the display list.
This means that all drawing is done by the GPU.

Now, Starling could send one quad after the other to the GPU, drawing one by one.
In fact, this is how the very first Starling release worked!
For optimal performance, though, GPUs prefer to get a huge pile of data and draw all of it at once.

That's why newer Starling versions batch as many quads together as possible before sending them to the GPU.
However, it can only batch quads that have similar properties.
Whenever a quad with a different "state" is encountered, a "state change" occurs, and the previously batched quads are drawn.

[NOTE]
====
I use _Quad_ and _Image_ synonymously in this section.
Remember, _Image_ is just a subclass of _Quad_ that adds a few methods.
Besides, _Quad_ extends _Mesh_, and what you read below is true for meshes, as well.
====

These are the crucial properties that make up a state:

* The _texture_ (different subtextures from the same atlas are fine, though)
* The _blendMode_ of display objects
* The _textureSmoothing_ value of meshes/quads/images
* The _textureRepeat_ mode of meshes/quads/images

If you set up your scene in a way that creates as little state changes as possible, your rendering performance will profit immensely.

Again, Starling's statics display provides useful data.
It shows exactly how many draw calls are executed per frame.
The more state changes you have, the higher this number will be.

.The statistics display includes the current number of draw calls.
image::stats-display.png[Statistics Display]

[NOTE]
====
The statistics display causes draw calls, as well.
However, Starling explicitly decrements the draw count displayed to take that into account.
====

Your target should always be to keep it as low as possible.
The following tips will show you how.

===== The Painter's Algorithm

To know how to minimize state changes, you need to know the order in which Starling processes your objects.

Like Flash, Starling uses the _Painter's algorithm_ to process the display list.
This means that it draws your scene like a painter would do it: starting at the object at the bottom layer (e.g. the background image) and moving upwards, drawing new objects on top of previous ones.

.Drawing a scene with the Painter's algorithm.
image::painters-algorithm.png[Painter's algorithm]

If you'd set up such a scene in Starling, you could create three sprites: one containing the mountain range in the distance, one with the ground, and one with the vegetation.
The mountain range would be at the bottom (index 0), the vegetation at the top (index 2).
Each sprite would contain images that contain the actual objects.

.The scene graph of the landscape from above.
image::landscape.png[Landscape Scene Graph]

On rendering, Starling would start at the left with "Mountain 1" and continue towards the right, until it reaches "Tree 2".
If all those objects have a different state, this would mean six draw calls.
That's exactly what will happen if you load each object's texture from a separate Bitmap.

// <note tip>
// Another tool at your disposal is the [[http://doc.starling-framework.org/core/starling/display/DisplayObjectContainer.html#sortChildren()|DisplayObjectContainer::sortChildren()]] method which can be used to sort layers, within a ''Sprite'' object for example, based on properties such as ''x'', ''y'', ''alpha'' etc. The method accepts a compare function which means you can sort objects based on any criteria you wish! :-D
// </note>

===== The Texture Atlas

That's one of the reasons why texture atlases are so important.
If you load all those textures from one single atlas, Starling will be able to draw all objects at once!
(At least if the other properties listed above do not change.)

.The same scene graph, now using a single atlas texture.
image::landscape-2.png[Landscape Scene Graph 2]

The consequence of this is that you should _always_ use an atlas for your textures.
Here, each image uses the same atlas (depicted by all nodes having the same color).

Sometimes, though, not all of your textures will fit into a single atlas.
The size of textures is limited, so you'll run out of space sooner or later.
But this is no problem, as long as you arrange your textures in a smart way.

.The order of objects makes a difference.
image::landscape-3.png[Landscape Scene Graph 3]

Both those examples use two atlases (again, one color per atlas).
But while the display list on the left will force a state change for each object, the version on the right will be able to draw all objects in just two batches.

==== Use the MeshBatch class

The fastest way to draw a huge number of quads or other meshes at once is to use the _MeshBatch_ class.
That's the same class that is used internally by Starling for all rendering, so it's heavily optimized.footnote:[If you're still using Starling 1.x, look for ''QuadBatch'' instead.]
It works like this:

[source, as3]
----
var meshBatch:MeshBatch = new MeshBatch();
var image:Image = new Image(texture);

for (var i:int=0; i<100; ++i)
{
    meshBatch.addMesh(image);
    image.x += 10;
}

addChild(meshBatch);
----

Did you notice? You can add the same image as often as you want!
Furthermore, adding it is a very fast operation; e.g. no event will be dispatched (which is the case when you add an object to a container).

As expected, this has some downsides, though:

* All the objects you add must have the same state (i.e. use textures from the same atlas).
  The first image you add to the MeshBatch will decide on its state.
  You can't change the state later, except by resetting it completely.
* You can only add instances of the _Mesh_ class or its subclasses (that includes _Quad_, _Image_, and even _MeshBatch_).
* Object removal is quite tricky: you can only remove meshes by trimming the number of vertices and indices of the batch.
  However, you can overwrite meshes at a certain index.

For these reasons, it's only suitable for very specific use-cases (the _BitmapFont_ class, for example, uses a mesh batch internally).
In those cases, it's definitely the fastest option, though. You won't find a more efficient way to render a huge number of objects in Starling.

==== テキストフィールドをバッチする

デフォルトでは、１つのテキストフィールドは１回のドローコールを必要とします。フォントのテクスチャが他のメインのテクスチャと同じだったとしてもです。
何故ならば、長いテキストはバッチするために、たくさんの CPU 時間を必要とするからです。

_MeshBatch_ にメッシュをコピーせず、そのままシンプルにドローした方が速いのです。

しかし、テキストフィールドのテキスト数が少ない場合（経験的には16文字より少ない場合)、TextField の `batchable` プロパティを有効にする事ができます。
これが有効の場合、テキストフィールドは他のディスプレイオブジェクトと同様にバッチ処置されます。

==== BlendMode 設定を NONE にする

もしも矩形テクスチャが完全に不透明であるのなら、ブレンド処理を無効にする事で、GPU の負荷を減らしてあげましょう。
大きな背景画像などで役に立つと思います。

[source, as3]
----
backgroundImage.blendMode = BlendMode.NONE;
----

通常は、このテクニックによって描画ステートの変化ももたらす（ドローコールが増える）ため、多用してはいけません。
小さな画像に対しては、おそらく適用する価値がありません。（なんにしろ何か別の理由で描画ステートが変化するのなら避けましょう。）

==== ステージカラー設定を活用する

しばしば、ステージに設定されたカラーはゲーム中に見えない状態である事があります。なぜならステージ上にあるイメージやメッシュによって隠されてしまっているからです。
その場合、ステージ色の設定は完全な黒（`0x0`）か完全な白（`0xffffff`）に設定するようにしましょう。
いくつかのモバイルプラットフォームでは、`context.clear` が '1' または '0' で呼ばれた場合に、ハードウェアの最適化処理が走る事があります、
何人かの開発者が１フレームごとにミリ秒単位でのレンダリング時間をレポートしてくれましたが、そのような簡単な変更で大きな速度改善があったとの事です！

[source, as3]
----
[SWF(backgroundColor="#0")]
public class Startup extends Sprite
{
    // ...
}
----

一方で、バックグラウンドカラーがフラットな色である場合、それをステージをうまく使う事ができます。
イメージや着色された Quad を配置するのでなく、ステージ色を設定しましょう。
どちらにしろ Starling は１フレームに１回画面をクリアし直すのです。したがってステージカラーを変更したとしてもなんの描画コストも増えません。

[source, as3]
----
[SWF(backgroundColor="#ff2255")]
public class Startup extends Sprite
{
    // ...
}
----

==== width 及び height の参照を控える

`width` と `height` プロパティは予想するよりもずっと高コストな物となっています。特にスプライトにおいてそれが顕著です。
行列演算が必要であり、各々の子孫ディスプレイオブジェクトの各々の頂点を処理させる必要があります。

そのような理由で、例えばループの中など、繰り返しそれらのプロパティにアクセスする事は避けるようにしましょう。
いくつのかのクラスでは、定数値を代わりに使った方が理にかないます。
//原文：In some cases, it might even make sense to use a constant value instead.
//具体的にはどういう事だろう？

[source, as3]
----
// 悪い例:
for (var i:int=0; i<numChildren; ++i)
{
    var child:DisplayObject = getChildAt(i);
    if (child.x > wall.width)
        child.removeFromParent();
}

// 良い例:
var wallWidth:Number = wall.width;
for (var i:int=0; i<numChildren; ++i)
{
    var child:DisplayObject = getChildAt(i);
    if (child.x > wallWidth)
        child.removeFromParent();
}
----

==== コンテナのタッチ判定を無効にする

指やマウスを画面上でスライドして動かす際、Starling はどのオブジェクトがその下に存在するのか探索しなければいけません。
これは高負荷な処理です。最悪の場合、全てのディスプレイオブジェクトとの当たり判定を行わなくてはいけないのです。

よってタッチ判定される必要のないオブジェクトに関しては、タッチ無効の設定にしてしまうと状況が改善します。
コンテナであるディスプレイオブジェクトのタッチを完全に無効としてしまうのが最善です。
そうすれば Starling が子孫ディスプレイオブジェクト全ての当たり判定を行う必要がなくなります。

[source, as3]
----
// 良い例:
for (var i:int=0; i<container.numChildren; ++i)
    container.getChildAt(i).touchable = false;

// さらに良い例:
container.touchable = false;
----

==== Hide objects that are outside the Stage bounds

Starling will send any object that is part of the display list to the GPU.
This is true even for objects that are outside the stage bounds!

You might wonder: why doesn't Starling simply ignore those invisible objects?
The reason is that checking the visibility in a universal way is quite expensive.
So expensive, in fact, that it's faster to send objects up to the GPU and let it do to the clipping.
The GPU is actually very efficient with that and will abort the whole rendering pipeline very early if the object is outside the screen bounds.

However, it still takes time to upload that data, and you can avoid that.
Within the high level game logic, it's often easier to make visibility checks (you can e.g. just check the x/y coordinates against a constant).
If you've got lots of objects that are outside those bounds, it's worth the effort.
Remove those elements from the stage or set their `visible` property to `false`.

==== Make use of Event Pooling

Compared to classic Flash, Starling adds an additional method for event dispatching:

[source, as3]
----
// classic way:
object.dispatchEvent(new Event("type", bubbles));

// new way:
object.dispatchEventWith("type", bubbles);
----

The new approach will dispatch an event object just like the first one, but behind the scenes, it will pool event objects for you.
That means that you will save the garbage collector some work.

In other words, it's less code to write _and_ is faster -- thus, it's the preferred way to dispatch events.
(Except if you need to dispatch a custom subclass of `Event`; they cannot be dispatched with that method.)
