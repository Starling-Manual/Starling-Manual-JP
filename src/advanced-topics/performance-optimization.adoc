== パフォーマンス チューニング
// 他ページとの連携で 'パフォーマンス チューニング' と訳すこと

Starling は Flash のディスプレイリストの構成を模倣していますが、内部実装の仕組みは全く異なっています。
最も良いパフォーマンスを得るためには、どのような仕組みで動いているのか、そのコンセプトのキーを理解する必要があります。
下記に記す内容は、ゲームをできるだけ早く動かすために必要なベストプラクティスです。

=== 一般的な AS3 のチップス
//↑見出しなので =  の数が異なる

==== いつでもリリースビルドを使う

最初に考えなくてはならない最も大事なルールは、パフォーマンステストを行う際は、必ずリリースビルドを使うという事です。
通常の Flash プロジェクトと異なり、Stage3D を使ったフレームワークを扱う場合、リリースビルドとデバッグビルドには大きな違いがあります。
スピードの差は膨大です。開発対象のプラットフォームによっては、デバッグビルドのフレームレートと何倍もの差が出る事があるでしょう。

* Flash Builder では、_menu:Project[Export Release Build]_ をクリックする事でリリースビルドを作成できます。
* Flash Develop では、"Release" 設定を選択して、プロジェクトをビルドしましょう。
その後、"ipa-ad-hoc" もしくは "ipa-app-store" オプションを選択して、"PackageApp.bat" スクリプトを実行します。
* IntelliJ IDEA では、_menu:Build[Package AIR Application]_ を選択し、アンドロイドでは "release"、 iOS では "ad hoc distribution" を選択します。
//原文： In IntelliJ IDEA, select _menu:Build[Package AIR Application]_; choose "release" for Android and "ad hoc distribution" for iOS.
AIR プロジェクトでない場合は、モジュールのコンパイラオプション設定にて、"Generate debuggable SWF" の選択を外します。
* Starling プロジェクトをコマンドラインでビルドしている場合は、必ず、`-optimize` を true にして `-debug` が false になるようにします。

.Flash Builder のダイアログに惑わされないようにしましょう。
image::not-release-build.png[Flash Builder Dialog]

==== ハードウェアをチェックする

Starling が本当に GPU レンダリングで動いているのかを確かめましょう。
やり方は簡単です。もしも、`Starling.current.context.driverInfo` の値が `Software` という文字列を含んでいたら、それは Stage3D がフォールバックモードになっている事を示します。
そうでなければ GPU を使ったレンダリングが行われています。

また、いくつかのモバイルデバイスでは、 _バッテリーセーブモード_ で動いている事があります。
パフォーマンステストを行う場合は、それが間違いなく off となっている事を確認しましょう。

==== フレームレートの設定

どのように頑張っても、何故かフレームレートが 24FPS で頭打ちになった場合、おそらくまだ目的とするフレームレートを設定しておらず、Flash Player のデフォルト設定になっているのかと思われます。

変更するには、起動クラスの適切な _metadata_ を使うか、stage の framerate 設定を行います。

[source, as3]
----
[SWF(frameRate="60", backgroundColor="#000000")]
public class Startup extends Sprite
{ /* ... */ }

// もしくはソース中のどこかで
Starling.current.nativeStage.frameRate = 60;
----

==== Adobe Scout を用いる

_Adobe Scout_ は <<memory_management_scout, メモリー利用状況の分析>> だけに役に立つのではありません。パフォーマンスのプロファイリングという事であれば、とてもパワフルに役に立ちます。

Scout を使うと、Starling 内外の _ActionScript_ 各々のコードが、どのくらい実行に時間がかかっているのか確認する事ができます。
これはとても有用です。なぜなら、最適化処理を施すべき箇所を示してくれるからです。

そのような場所の特定をしない場合、実際には全くフレームレートの改善に役に立たないコードを最適化してしまうかもしれません！

TIP: 早い段階でのパフォーマンスチューニングは、諸悪の根源！ である事を知っておいて下さい。

古典的なプロファイラと比べて良いと言える部分は、Scout はリリースビルドの（デバッグモードではなく、全ての最適化がなされた）swfやAIRを対象にしても動くという所です。
//原文：What's nice compared to classic profilers is that it also works in release mode, with all optimizations in place.
Scout で計測される内容がとても正確な事が保証されます。
//原文：That ensures that its output is extremely accurate.

==== ロードされたイメージを非同期でデコードする

デフォルトでは、_Loader_ クラスを PNG や JPEG をロードするために使った場合、イメージデータはすぐさまデコードされません。実際に最初に使うタイミングでデコードされるのです。これはメインスレッド上で処理され、テクスチャの作成時に青アプリケーションが突っかかるような状態になる事があります。そのような事態を避けるには、デコードのポリシー設定を `ON_LOAD` にしましょう。そうすれば、デコード処理はローダーのバックグラウンドスレッドで直接行われるようになります。

[source, as3]
----
loaderContext.imageDecodingPolicy = ImageDecodingPolicy.ON_LOAD;
loader.load(url, loaderContext);
----

ところで、イメージのロードには Starling の _AssetManager_ を使っているでしょうか？
そうであれば、上記のテクニックはすでに使われているので、気にしなくても大丈夫です。

==== "for each" の利用を控える

頻繁に繰り返されるループや深くネストされたループを扱う場合、`for each` を避けた方が良いです。
原始的な `for i` という記述をする方が、 http://jacksondunstan.com/articles/358[より良い] パフォーマンスをもたらします。
さらに、ループ終了条件がループごとに１度しか評価されないように気をつけましょう。別の変数にそれを保持するのがさらに速いという事です。

[source, as3]
----
// やや遅い:
for each (var item:Object in array) { ... }

// 取り良い:
for (var i:int=0; i<array.length; ++i) { ... }

// 最も速い:
var length:int = array.length;
for (var i:int=0; i<length; ++i) { ... }
----

==== アロケーションを避ける

たくさんの一時的なオブジェクトを作成して利用するのは避けましょう。利用したメモリを後にガベージコレクターによって回収される必要が生じます。その間小さなしゃっくり（プチフリーズ）を伴うかもしれません。

[source, as3]
----
// 悪い例:
for (var i:int=0; i<10; ++i)
{
    var point:Point = new Point(i, 2*i);
    doSomethingWith(point);
}

// 良い例:
var point:Point = new Point();
for (var i:int=0; i<10; ++i)
{
    point.setTo(i, 2*i);
    doSomethingWith(point);
}
----

実際には、Starling は上記の最適化を手助けするクラスが存在します。_Pool_ というクラスです。
このクラスは頻繁に利用されるオブジェクトを再利用のために保持する"プール"を提供してくれます。
保持されるクラスは_Point_、 _Rectangle_、 _Matrix_ などです。
プールからこれらのオブジェクトを "借りて"、使い終わった後はそこへ返しましょう。

[source, as3]
----
// 最も良い例:
var point:Point = Pool.getPoint();
for (var i:int=0; i<10; ++i)
{
    point.setTo(i, 2*i);
    doSomethingWith(point);
}
Pool.putPoint(point); // この処理を忘れない事！
----

=== Starling 固有のチップス
//↑見出しなので =  の数が異なる


==== ステージの変化を最小にする

知っての通り、Starling は Stage3D をディスプレイリストの描画に利用します。これは全ての描画処理が GPU で行われる事を意味します。

ここで、Starling はQuad (矩形) の１つ１つを個別に GPU に送って描画させる事もできます。実際、これは Starling の最初の頃のリリースで行なっていた方法です。しかし、最高のパフォーマンスを出すために、GPU にはいっぺんにたくさんのでデーターを渡して１回で描画してもらうのが良いのです。

これが、その後の Starling のバージョンでは、できるだけたくさんの Quad をバッチして GPU に送っている理由です。しかし、バッチ処理でまとめられるのは似たようなプロパティを持っている Quad だけなのです。Quad の状態が切り替わるたび、"ステートの変更" が生じて、そこまでのバッチが一度描画されます。

[NOTE]
====
このセクションでは _Quad_ と _Image_ を同義的に扱っています。_Image_ は _Quad_ のサブクラスで、いくつかのメソッドが追加されただけなのです。さらに、_Quad_ は _Mesh_ を継承しており、以下に書く事は Mesh に対しても同様に当てはまります。
====

以下は、ステートを決定する重要なプロパティです。

* _テクスチャー_ の設定。 (しかし、同じアトラスのサブテクスチャーはステートを変えません。)
* ディスプレイオブジェクトの _ブレンドモード_ 設定。
* メッシュ/Quad/イメージ の _textureSmoothing_ 設定。
* メッシュ/Quad/イメージ の _textureRepeat_ 設定。

できる限りステート変化を抑えるようにシーンの設定をする事で、レンダリングのパーフォーマンスは著しく向上するでしょう。

再度言います、Starling の statics 表示は有益な情報を与えてくれます。１フレームでどれだけのドローコールが発生したかの回数を表示します。ステートの変化が多いほど、ドローコール回数も多くなります。

.statistics 表示には 現在のドローコール数も表示されています。
image::stats-display.png[Statistics Display]

[NOTE]
====
statistics 表示自体もドローコールを消費します。
しかし、Starling はその増加分を差し引いたドローコール数を表示してくれます。
====

取り組むべき事は、できる限りステートの変化を抑える事、です。具体的な方法については下に続けます。

===== ペインターアルゴリズム

どのようにしてステートの変化を抑えるかを知るためには、まず Starling がどのようにディスプレイオブジェクトを処理するのかを知らなくてはいけません。

Flash のように、Starling もディスプレイリストを処理するために _ペインターアルゴリズム_ を利用します。これは、実際の画家のようにシーンを描画するアルゴリズムです。最背面のオブジェクト（例えば背景画像など）から処理を初めて、だんだんと前面に進んでいきます。前に描画したオブジェクトの上に次のものを重ねて描画していきます。

.ペインターアルゴリズムで描画されたシーン。
image::painters-algorithm.png[Painter's algorithm]

Starling でシーンを生成した際、３つのスプライトを配置したとします。一つは山の領域、１つは地面、一つは植物を描画という具合です。山は一番下層にあり (index 0)、植物は最前面 (index 2) にあります。各々のスプライトはそれぞれを構成する画像をいくつか含むとします。

.上記の設定によるシーン構造。
image::landscape.png[Landscape Scene Graph]

レンダリングのタイミングでは、Starling は図の左の "Mountain 1" から右に向かい、一番右の "Tree 2" に到達するまで処理を進めます。もしも、それら全てのオブジェクトが異なったステートである場合、6回のドローコールが必要となってしまいます。この事は、それぞれのテクスチャーを異なるビットマップ画像から読み込んでいる場合に実際に起こりえる事です。

// <note tip>
// Another tool at your disposal is the [[http://doc.starling-framework.org/core/starling/display/DisplayObjectContainer.html#sortChildren()|DisplayObjectContainer::sortChildren()]] method which can be used to sort layers, within a ''Sprite'' object for example, based on properties such as ''x'', ''y'', ''alpha'' etc. The method accepts a compare function which means you can sort objects based on any criteria you wish! :-D
// </note>

===== テクスチャーアトラス

これが、テクスチャーアトラスがとても重要である理由の１つなのです。１つのアトラスから全てのテクスチャーを読み取る場合、Starling は一度に全てのオブジェクトを描画する事ができます。（上の一覧にあるプロパティが変化しない場合に置いては。）

.１つのアトラスを利用した、先ほどと同じシーンの構造。
image::landscape-2.png[Landscape Scene Graph 2]

ここから導かれる結果は、_いつでも_ テクスチャは１枚のアトラスにまとめられるべきだという事です。ここでは、各々の画像が同じアトラスを利用しています。（描画された全てのノードは同じカラーの設定です。）

時には１枚のアトラスに全てのテクスチャーが収まらない場合もあります。テクスチャーのサイズには限度があり、遅かれ早かれ空きスペースは足りなくなってしまうでしょう。しかし、大丈夫です。うまい方法でテクスチャーを調整する事ができます。

.オブジェクトの順番が違いを生む。
image::landscape-3.png[Landscape Scene Graph 3]

この例の両者では２つのアトラスを利用しています。（カラー設定はそれぞれに対して１つだけです。）左のディスプレイリストでは各々のオブジェクトごとにステートの変更がなされてしまうのに対して、右のディスプレイリストでは全てのオブジェクトを描画するのに2回だけのバッチ処理で抑えられています。

==== MeshBatch クラスを用いる

たくさんの Quad やメッシュをまとめて描画する最も速い方法は、_MeshBatch_ クラスを利用する事です。これは Starling の全てのレンダリングの内部処理で使われているのと同じクラスで、とてもよく最適化がなされています。footnote:[もし 使っている Starling のバージョンが 1.x であるなら、代わりに ''QuadBatch'' を使ってください。]
下記のように使います。

[source, as3]
----
var meshBatch:MeshBatch = new MeshBatch();
var image:Image = new Image(texture);

for (var i:int=0; i<100; ++i)
{
    meshBatch.addMesh(image);
    image.x += 10;
}

addChild(meshBatch);
----

気づいたでしょうか？ここでは１つのイメージを何度でも好きなだけバッチ処理対象に追加しています。さらに、この追加に伴う処理はとても速いのです。例えば、なんのイベントも発火しません。（スプライトなどのコンテナにオブジェクトを追加した場合はイベントが発火します。）

しかし、下記のようなマイナスな面もあります。

* バッチ対象に追加する全てのオブジェクトは、同じステートでなくてはいけません。（例えば、テクスチャーが同じアトラスから構成されている、など。）一番最初に MeshBatch に追加するイメージがそのステートを決定する事になります。完全にリセットすること以外に、後からステートを変更することはできません。
* バッチ対象として追加できるのは、メッシュクラスかそのサブクラスのインスタンスだけです。（_Quad_、_イメージ_、別の _MeshBatch_ などのクラスもそれに含まれます。）
* 追加したオブジェクトを後から削除するのはとても特殊な対応を取る事になります。全体の大きなメッシュから頂点やインデックスを直接削除する事しかできないのです。しかし、ある場所のメッシュを上書きするようなこともできます。

これらの理由から、特別な状況のみにこの方法は適している事になります。（例えば、_BitmapFont_ クラスは内部でメッシュのバッチ処理を行なっています。）しかし、そのような状況であるならば、MeshBatch が間違いなく最も速い描画方法となります。Starling において、たくさんのオブジェクトをこのクラスより効率的に描画する方法は見つけられないでしょう。

==== テキストフィールドをバッチする

デフォルトでは、１つのテキストフィールドは１回のドローコールを必要とします。フォントのテクスチャが他のメインのテクスチャと同じだったとしてもです。何故ならば、長いテキストはバッチするために、たくさんの CPU 時間を必要とするからです。

_MeshBatch_ にメッシュをコピーせず、そのままシンプルにドローした方が速いのです。

しかし、テキストフィールドのテキスト数が少ない場合（経験的には16文字より少ない場合)、TextField の `batchable` プロパティを有効にする事ができます。これが有効の場合、テキストフィールドは他のディスプレイオブジェクトと同様にバッチ処置されます。

==== BlendMode 設定を NONE にする

もしも矩形テクスチャが完全に不透明であるのなら、ブレンド処理を無効にする事で、GPU の負荷を減らしてあげましょう。
大きな背景画像などで役に立つと思います。

[source, as3]
----
backgroundImage.blendMode = BlendMode.NONE;
----

通常は、このテクニックによって描画ステートの変化ももたらす（ドローコールが増える）ため、多用してはいけません。小さな画像に対しては、おそらく適用する価値がありません。（なんにしろ、何か別の理由で描画ステートが変化するのなら避けましょう。）

==== ステージカラー設定を活用する

ゲーム中にはしばしば、ステージに設定されたカラーのエリアが見えない状態である事があります。なぜならステージ上にあるイメージやメッシュによって隠されてしまっているからです。その場合、ステージ色の設定は完全な黒（`0x0`）か完全な白（`0xffffff`）に設定するようにしましょう。いくつかのモバイルプラットフォームでは、`context.clear` が '1' または '0' で呼ばれた場合に、ハードウェアの最適化処理が走る事があります。何人かの開発者が１フレームごとにミリ秒単位でのレンダリング時間をレポートしてくれましたが、そのような簡単な変更で大きな速度改善があったとの事です！

[source, as3]
----
[SWF(backgroundColor="#0")]
public class Startup extends Sprite
{
    // ...
}
----

一方で、バックグラウンドカラーがフラットな色である場合、それをステージをうまく使う事ができます。イメージや着色された Quad を配置するのでなく、ステージ色を設定しましょう。どちらにしろ Starling は１フレームに１回画面をクリアし直すのです。したがってステージカラーを変更したとしても描画コストは何も変わりません。

[source, as3]
----
[SWF(backgroundColor="#ff2255")]
public class Startup extends Sprite
{
    // ...
}
----

==== width 及び height の参照を控える

`width` と `height` プロパティへの参照処理は予想するよりもずっと高コストな物となっています。特にスプライトにおいてそれが顕著です。行列演算が必要であり、各々の子孫ディスプレイオブジェクトの各々の頂点を計算に入れて処理させる必要があります。

そのような理由で、例えばループの中など、繰り返しそれらのプロパティにアクセスする事は避けるようにしましょう。いくつのかのクラスでは、代わりに定数値で判断した方が効率的です。

[source, as3]
----
// 悪い例:
for (var i:int=0; i<numChildren; ++i)
{
    var child:DisplayObject = getChildAt(i);
    if (child.x > wall.width)
        child.removeFromParent();
}

// 良い例:
var wallWidth:Number = wall.width;
for (var i:int=0; i<numChildren; ++i)
{
    var child:DisplayObject = getChildAt(i);
    if (child.x > wallWidth)
        child.removeFromParent();
}
----

==== コンテナのタッチ判定を無効にする

指やマウスを画面上でスライドして動かす際、Starling はどのオブジェクトがその下に存在するのか探索しなければいけません。これは高負荷な処理です。最悪の場合、全てのディスプレイオブジェクトとの当たり判定を行わなくてはいけないのです。

よってタッチ判定される必要のないオブジェクトに関しては、タッチ無効の設定にしてしまうと状況が改善します。コンテナであるディスプレイオブジェクトのタッチを完全に無効としてしまうのが最善です。そうすれば Starling が子孫ディスプレイオブジェクト全ての当たり判定を行う必要がなくなります。

[source, as3]
----
// 良い例:
for (var i:int=0; i<container.numChildren; ++i)
    container.getChildAt(i).touchable = false;

// さらに良い例:
container.touchable = false;
----

==== ステージ領域から外れたオブジェクトを隠す

Starling はディスプレイリスト上のどのオブジェクトも GPU へと送信します。これは、オブジェクトがステージの領域外にあった場合でも同様です。

こう思うかもしれません。Starling は目に見えないそれらのオブジェクトを無効にしてくれないのだろうと。その理由は、表示されているかどうかを普遍的にチェックする事は、とても計算が高くつくからです。実際にそれはとても割高な処理で、全てのオブジェクトを GPU に送信して、そちらでクリッピングして表示した方が早いのです。GPU はそのような処理に置いて
とても効率的に働き、オブジェクトが画面外である場合、レンダリング処理の早い段階で、描画対象から取り除かれます。

しかし、やはりデータのアップロードには時間がかかります。そしてそれを避ける事は可能です。ハイレベルなゲームロジックでは、オブジェクトが実際に表示されているかのチェックはしばしば簡単なものとなります。（例えば、ただ定数に対して、x及びy座標をチェックするだけで済む事があります。）もしもたくさんのオブジェクトがその表示領域から外れている場合、チェックする努力を払う価値はあります。それらをステージから取りさるか、`visible` 値を false にしましょう。

==== Event オブジェクトをプールする

Starling は Flash のシステムにはない、イベントの発火に関する新しいメソッドを追加しました。

[source, as3]
----
// 今までのやり方
object.dispatchEvent(new Event("type", bubbles));

// 新しいやり方
object.dispatchEventWith("type", bubbles);
----

新しいアプローチは、今までのものとあまり変わりがないように見えます。しかしシーンの裏側では、イベントオブジェクトの使い回しを行なっています。これによって、無駄なガベージコレクションの発動を抑えることができます。

言い換えると、コード記述量が減って、動作も速くなる、という事です。したがってこれが推奨されるイベントの発火方法となります。(もしも `Event` クラスのカスタムサブクラスを用いる必要がある場合、新しいやり方は取れません。)
