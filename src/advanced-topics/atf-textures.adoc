== ATF テクスチャ

従来の Flash 開発では、ほとんどの開発者が画像として _PNG_ フォーマットを用いるか、透明度が必要ない場合は _JPG_ フォーマットを用います。
それらは Starling でも同様にとても一般的なやり方です。
しかし、_Stage3D_ はまた別の、いくつかの優れた特徴を持つ画像フォーマットに対応しています。_Adobe Texture Format_ という圧縮したテクスチャ情報を保持できるフォーマットです。

//原文：* Compressed textures require just a fraction of their conventional counterparts.
* 圧縮されたテクスチャは従来のテクスチャと比べてわずかなサイズとなります。
* 解凍作業は GPU によって直接行われます。
* グラフィックメモリーへのアップロードがより高速です。
* アップロードは非同期に行うことができます。ゲーム体験を損なわずにテクスチャをロードすることができます。.footnote:[AIR 24 と Starling 2.2 より、同じことを通常のテクスチャでも行う事ができます。]

=== グラフィックメモリー

ATF テクスチャの話を続ける前に、どのくらいのメモリーがテクスチャによって必要となるか知っておくのも良いでしょう。

１枚の PNG 画像は、１ドットごとに4つのチャンネル情報を保持します。_赤_、_緑_、_青_、_透明度_ で、それぞれが８ビットの（つまり256段階の）情報を持ちます。
512 x 512 ピクセルのテクスチャーがどれだけの領域を必要とするのか計算するのは難しくありません。

====
512 × 512 サイズの RGBA テクスチャのメモリ容量: +
512 × 512 ピクセル × 4 bytes = 1,048,576 bytes ≈ 1 MB
====

_JPG_ イメージを使っている場合はもっと小さくなります。アルファチャンネルが必要なくなるためです。

====
512 × 512 サイズの RGB テクスチャのメモリ容量: +
512 × 512 ピクセル × 3 bytes = 786,432 bytes ≈ 768 kB
====

こんなに小さなテクスチャのためにとても大きな容量を必要としていますね？
//原文：Beware that the built-in file compression of _PNG_ and _JPG_ does not help: the image has to be decompressed before _Stage3D_ can handle it.
_PNG_ や _JPG_ フォーマットで圧縮された画像は _Stage3D_ が扱うために一度解凍されざるを得ないわけです。

言い換えれば、ファイルサイズは問題ではないのです。メモリ使用量は上記の計算式によっていつでも決定されます。
//原文：Nevertheless: if your textures easily fit into graphics memory that way -- go ahead and use them!
とはいえ、それでもうまくメモリに収まるのであれば、そのまま使って良いでしょう。
//原文：Those formats are very easy to work with and will be fine in many situations, especially if your application is targeting desktop hardware.
特にデスクトップPCをターゲットとしたアプリケーションを作成しているのなら、それでたいていの場合とてもうまくワークします。

しかし、開発が進むとデバイスで利用可能な容量以上にメモリ消費がなされてしまう瞬間もやってくる事でしょう。
その時が、ATF フォーマットを試してみるべき時です。

=== 圧縮テクスチャ

上記で、通常のテクスチャのファイルサイズがグラフィックメモリーが使われる量になんら影響しないことを知りました。
強く圧縮された _JPG_ ファイルは、メモリ上に _BMP_ フォーマットと全く同じだけのスペースを使ってしまうのです。

これは本当の意味での圧縮テクスチャとは言えません。本当の圧縮テクスチャは GPU で直接処理されるのです。
圧縮の設定によって10倍の数ものテクスチャーをアップロードする事もできてしまいます。とても感動的てはないですか。

残念ながら、どの GPU ベンダーも他社よりも自分たちの方がうまくできると考えていたのか、圧縮テクスチャにはいくつか異なった種類が存在します。
つまり、どこでゲームが動いているかによって、要求されるテクスチャの種類も変わって来るのです。
どのように前もってゲームに含めるファイルを知ることができるのでしょう？

ここが ATF テクスチャの出番です。
ATF は _Stage3D_ のために Adobe が作成したフォーマットです。実際には、１つのテクスチャを4つの異なったフォーマットで同梱できるコンテナファイルです。

* *PVRTC* (PowerVR Texture Compression) フォーマットは、PowerVR GPU 向けに使われます。
どの世代の iPhone、iPod Touch、iPadもこのフォーマットをサポートします。
* *DXT1/5* (S3 Texture Compression) フォーマットは、S3 Graphics によって開発されたものです。
現在では Nvidia と AMD の両方の GPU でサポートされているため、大抵のデスクトップと一部の Android で利用が可能です。
* *ETC* (Ericsson Texture Compression) フォーマットは、たいていのモバイルフォン（特に Android）で利用されています。
* *ETC2* フォーマットは、RGB 及び RGBA フォーマットの画像を高品質に圧縮します。
OpenGL ES 3 をサポートしている Android や iOS 端末であればどの端末でも扱う事ができます。

ATF は コンテナーのフォーマットだと先に言いました。
それは、上記のフォーマットをどんな組み合わせても含める事ができるという事です。

.ATF ファイルは、実際には他のフォーマットのコンテナファイルです。
image::atf-container.png[ATF container]

もしも全てのフォーマットを含めるのなら（それがデフォルトの設定です。）、
そのテクスチャは Stage3D をサポートするどのデバイスでも読み込む事ができます。
デスクトップで動いていようが、iOSで動いていようが、Android で動いていようが、です。内部の挙動を気にする必要はありません。

しかし、もしもゲームが、例えば、iOS上だけでしか動かさないと言う場合、PVRTC 形式以外のフォーマッットはは省く事ができます。
もしくは、ハイエンドなモバイルデバイスしかターゲットとしていないのであれば（少なくとも _OpenGL ES 3_ 以上の）
ETC2 形式だけを含めてば良いのです。これは iOS でも Android でもうまく動作します。
このようにして、ゲームのダウンロードサイズを最適化する事もできます。

[NOTE]
====
DXT1 と DXT5 の違いは、ただアルファチャンネルを後者のみがサポートすると言う点だけです。
この点について心配する必要はありません。後述の ATF ツールは自動的に適切なフォーマットを選択してくれます。

ETC1は実際アルファチャンネルをサポートしませんが、Stage3Dは内部的に２枚のテクスチャを使うことにとってこの点をうまくカバーします。
再度言いますが、この処理は内部的に自動で行われます。
====

=== ATF テクスチャの作成

Adobe provides a set of command line tools to convert to and from ATF and to preview the generated files.
They are part of the AIR SDK (look for the `atftools` folder).

Probably the most important tool is `png2atf`.
Here is a basic usage example; it will compress the texture with the standard settings in all available formats.

----
png2atf -c -i texture.png -o texture.atf
----

If you tried that out right away, you probably received the following error message, though:

----
Dimensions not a power of 2!
----

That's a limitation I have not mentioned yet: ATF textures are required to always have side-lengths that are powers of two.
While this is a little annoying, it's actually rarely a problem, since you will almost always use them for atlas textures.

TIP: Most atlas generators can be configured so that they create power-of-two textures.

When the call succeeds, you can review the output in the _ATFViewer_.

.The _ATFViewer_ tool.
image::atf-viewer.png[ATFViewer]

In the list on the left, you can choose which internal format you want to view.
Furthermore, you see that, per default, all mipmap variants have been created.

NOTE: We will discuss mipmaps in the <<Memory Management>> chapter.

You will probably also notice that the image quality has suffered a bit from the compression.
This is because all those compression formats are _lossy_: the smaller memory footprint comes at the prize of a reduced quality.
How much the quality suffers is depending on the type of image: while organic, photo-like textures work well, comic-like images with hard edges can suffer quite heavily.

The tool provides a lot of different options, of course.
E.g. you can let it package only the PVRTC format, perfect for iOS:

----
png2atf -c p -i texture.png -o texture.atf
----

Or you can tell it to omit mipmaps in order to save memory:

----
png2atf -c -n 0,0 -i texture.png -o texture.atf
----

Another useful utility is called `atfinfo`.
It displays details about the data that's stored in a specific ATF file, like the included texture formats, the number of mipmaps, etc.

----
> atfinfo -i texture.atf

File Name          : texture.atf
ATF Version        : 2
ATF File Type      : RAW Compressed With Alpha (DXT5+ETC1/ETC1+PVRTV4bpp)
Size               : 256x256
Cube Map           : no
Empty Mipmaps      : no
Actual Mipmaps     : 1
Embedded Levels    : X........ (256x256)
AS3 Texture Class  : Texture (flash.display3D.Texture)
AS3 Texture Format : Context3DTextureFormat.COMPRESSED_ALPHA
----

=== ATF テクスチャを使う

Using a compressed texture in Starling is just as simple as any other texture.
Pass the byte array with the file contents to the factory method `Texture.fromAtfData()`.

[source, as3]
----
var atfData:ByteArray = getATFBytes(); // <1>
var texture:Texture = Texture.fromATFData(atfData); // <2>
var image:Image = new Image(texture); // <3>
----
<1> Get the raw data e.g. from a file.
<2> Create the ATF texture.
<3> Use it like any other texture.

That's it! This texture can be used like any other texture in Starling.
It's also a perfectly suitable candidate for your atlas texture.

However, the code above will upload the texture synchronously, i.e. AS3 execution will pause until that's done.
To load the texture asynchronously instead, pass a callback to the method:

[source, as3]
----
Texture.fromATFData(atfData, 1, true,
    function(texture:Texture):void
    {
        var image:Image = new Image(texture);
    });
----

Parameters two and three control the scale factor and if mipmaps should be used, respectively.
The fourth one, if passed a callback, will trigger asynchronous loading: Starling will be able to continue rendering undisturbed while that happens.
As soon as the callback has been executed (but not any sooner!), the texture will be usable.

Of course, you can also embed the ATF file directly in the AS3 source.

[source, as3]
----
[Embed(source="texture.atf", mimeType="application/octet-stream")]
public static const CompressedData:Class;

var texture:Texture = Texture.fromEmbeddedAsset(CompressedData);
----

Note, however, that asynchronous upload is not available in this case.

=== その他の情報

この話題について、さらなる情報は下記で得る事ができます。

* http://www.adobe.com/devnet/flashruntimes/articles/introducing-compressed-textures.html[Introducing Compressed Textures]
* http://www.adobe.com/devnet/flashruntimes/articles/atf-users-guide.html[ATF Tools User's Guide]

