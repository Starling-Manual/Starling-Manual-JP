== カスタムスタイル

さあ、_Stage3D_ の生のパワーの領域へと足を踏み入れました。このまま突き進んでいきましょう。
このセクションでは、シンプルなメッシュスタイルのコードを記述します。
Starling 2 では、全てのレンダリングはスタイルを通じて行われます。
スタイルを自分自身で作る事で、パフォーマンスを犠牲にせずに特別な描画エフェクトを作ることができるのです。

NOTE: この先に進む前に、必ず <<カスタムフィルター>> のセクションも目を通しておいてください。
フィルターとスタイルでは多くのコンセプトが共通しています。ですのでより単純なフィルターから始めた方が理にかなっています。
ここから先は、そのセクションの内容は理解していると過程して話を進めます。

=== ゴール

今回のゴールは _ColorOffsetFilter_ として作ったものと同じです。
描画ピクセルに対してカラーのオフセット指定ができるようにします。
これを今回はスタイルとして制作するわけです。これを _ColorOffsetStyle_ と呼びましょう。

.スタイルでカラーオフセットを指定する。
image::customfilter-offset.png[Offset with a Style]

まずは、フィルターとスタイルの違いについて理解するのが重要です。

==== フィルター vs スタイル

先に述べた通り、フィルターは各ピクセル１ドット１ドットに対して働きます。オブジェクトは一度テクスチャーに描画され、フィルターはそのテクスチャをどうかして処理します。
それに対してスタイルは、オブジェクトの元々の形状に対してアクセスします。もっと正確に言えば、オブジェクトの頂点に対してアクセスします。

そのようにスタイルにはある意味で制限があるのですが（例えばブラーフィルターを作ることはできません）、スタイルはずっと効率的に処理を行います。
ます、最初のステップの一度テクスチャにオブジェクトを描画する必要がありません。
さらに重要な事に、スタイルはバッチ処理される事ができます。

ご存知の通り、ドローコール数を低く抑えることは、高いフレームレートをキープするためにとても大事なことです。
そのようにするためには、Starling にできる限りたくさんのオブジェクトをバッチ処置させる事が重要です。
ここで疑問となるのは、どのようにしてオベジェクトをバッチ処理にまとめるかを決定しているかという事です。
ここがスタイルが一役買っている所です。同じスタイル設定であるオブジェクトだけがバッチ対象となる事ができます。

もしもステージ上に３つのイメージを配置して、それぞれに _ColorOffsetFilter_ を適用した場合、少なくとも３回のドローコールが確認できます。
代わりに _ColorOffsetStyle_ を適用した場合は、それがたったの１回となります。
このあたりがスタイルのコードを記述することを若干難しくしてしまってはいますが、同時にやり遂げる価値があるものとなっているのです！

=== MeshStyle を継承する

全てのスタイルのベースクラスとなるのは、`starling.styles.MeshStyle` です。
このクラスがスタイルの作成に必要な基盤を全て提供してくれます。まずは構造を確認してみましょう。

[source, as3]
----
public class ColorOffsetStyle extends MeshStyle
{
    public static const VERTEX_FORMAT:VertexDataFormat =
            MeshStyle.VERTEX_FORMAT.extend("offset:float4");

    private var _offsets:Vector.<Number>;

    public function ColorOffsetStyle(
        redOffset:Number=0, greenOffset:Number=0,
        blueOffset:Number=0, alphaOffset:Number=0):void
    {
        _offsets = new Vector.<Number>(4, true);
        setTo(redOffset, greenOffset, blueOffset, alphaOffset);
    }

    public function setTo(
        redOffset:Number=0, greenOffset:Number=0,
        blueOffset:Number=0, alphaOffset:Number=0):void
    {
        _offsets[0] = redOffset;
        _offsets[1] = greenOffset;
        _offsets[2] = blueOffset;
        _offsets[3] = alphaOffset;

        updateVertices();
    }

    override public function copyFrom(meshStyle:MeshStyle):void
    {
        // TODO
    }

    override public function createEffect():MeshEffect
    {
        return new ColorOffsetEffect();
    }

    override protected function onTargetAssigned(target:Mesh):void
    {
        updateVertices();
    }

    override public function get vertexFormat():VertexDataFormat
    {
        return VERTEX_FORMAT;
    }

    private function updateVertices():void
    {
        // TODO
    }

    public function get redOffset():Number { return _offsets[0]; }
    public function set redOffset(value:Number):void
    {
        _offsets[0] = value;
        updateVertices();
    }

    // 他のカラーオフセット用のプロパティも同じように実装される必要があります。

    public function get/set greenOffset():Number;
    public function get/set blueOffset():Number;
    public function get/set alphaOffset():Number;
}
----

これが、最初のステップとなるコードです。
フィルターの制作サンプルの最初の状態よりも若干先に進んでいるので、
//原文：You'll see that there's already going on a little more than in our initial filter class from the last example.
個々のコードも確認してみましょう。

==== 頂点フォーマット

頂点フォーマット定数がクラスの上の方に記述されている事に注目してください。
スタイルは頂点レベルで働くと先に述べました。オブジェクトの全ての形状にアクセスが可能です。
//原文：I mentioned already that styles work on a vertex level, giving you access to all the geometry of an object.
_VertexData_ クラスはその形状を保持しています。しかし、まだ各頂点が自身にどんなデーターが保持されているかをどうやって知るのかについては述べていませんでした。
それが、_VertexDataFormat_ によって定義されているのです。

_MeshStyle_によって扱われるデフォルトのフォーマットは以下のようになっています。

  position:float2, texCoords:float2, color:bytes4

この文字列の書式には馴染みがあるように見えます。これは属性情報とデータタイプのリストです。

* `position` 属性は２つの float 型を保持します。 (頂点のX座標、Y座標です。）
* `texCoords` 属性も２つの float 型を保持します。 (テクスチャ座標を表します。).
* `color` 属性は４バイトの色情報を保持します。 (１バイトごとに１チャンネルの情報です。)

このフォーマットの _VertexData_ インスタンスは、メッシュの各頂点にそれら属性値を保持します。属性値の格納順はフォーマット文字列と同じ順序です。
つまり、各頂点は合計20バイト（8バイト + 8バイト + 4バイト）を保持する事になります。

もしもメッシュを作成してなんのスタイルも当てはめなかった場合、標準の _MeshStyle_ を用いて描画が行われます。
各頂点にはまさに上記のフォーマットが適用されます。
これが、各頂点にテクスチャと色味を付与したメッシュを描画するために必要な情報となります。

しかし、_ColorOffsetStyle_ にはこれで十分ではありません。カラーオフセット値も同じように保持する必要があります。
よって、４つのfloat値からなる `offset` 属性を追加した新しいフォーマットを定義する必要があるのです。

[source, as3]
----
MeshStyle.VERTEX_FORMAT.extend("offset:float4");
// => position:float2, texCoords:float2, color:bytes4, offset:float4
----

Now, you may ask: _Why do we need this?_ The filter worked just fine without a custom vertex format, after all.

That's a very good question, I'm glad you ask!
The answer lies in Starling's batching code.
When we assign our style to some subsequent meshes, they will be batched together -- that's the whole reason we make this effort, right?

But what does batching mean?
It just means that we're copying the vertices of all individual meshes to one bigger mesh and render that.
Somewhere inside Starling's rendering internals, you'll find code that will look similar to this:

[source, as3]
----
var batch:Mesh = new Mesh();

batch.add(meshA);
batch.add(meshB);
batch.add(meshC);

batch.style = meshA.style; // ← !!!
batch.render();
----

Do you see the problem? The big mesh (`batch`) receives a copy of the style of the mesh that was first added.
Those three styles will probably use different settings, though.
If those settings are just stored in the _style_, all but one will be lost on rendering.
Instead, the style must store its data in the _VertexData_ of its target mesh!
Only then will the big _batch_ mesh receive all the offsets individually.

IMPORTANT: Since it's so important, I'll rephrase that:
*A style's settings must always be stored in the target mesh's vertex data.*

Per convention, the vertex format is always accessible as a static constant in the style's class, and also returned by the `vertexFormat` property.
When the style is assigned to a mesh, its vertices will automatically be adapted to that new format.

When you have understood that concept, you're already halfway through all of this.
The rest is just updating the code so that the offset is read from the vertex data instead of fragment constants.

But I'm getting ahead of myself.

==== メンバ変数

全てのデーターは頂点に保持されると言いましたが、同時にメンバ変数にもデーターが保持されています。
//原文：You'll note that even though I just insisted that all data is to be stored in the vertices, there's still a set of offsets stored in a member variable:

[source, as3]
----
private var _offsets:Vector.<Number>;
----

何故ならば、実際にメッシュにスタイルが適用される前に、開発者がスタイルを調整できるようにしたいからです。
ターゲットとなるオフジェクトがない場合、頂点にデーターを保持させる事ができませんね？
それなので、このベクター型の変数を利用します。
ターゲットとなるオブジェクトが紐づけられると、データーはターゲットの頂点にコピーされます。（`onTargetAssigned` メソッドを確認してみて下さい。）

==== copyFrom

バッチ処理の間、スタイルは時々（内部の値を）コピーされて使われる事があります。主な理由はスタイルを再利用してイライラするガーベジコレクションを避けるためです。
そのため、`copyFrom` メソッドをオーバーライドする事が必要となります。
実際のコードでは、下記のようになります。

[source, as3]
----
override public function copyFrom(meshStyle:MeshStyle):void
{
    var colorOffsetStyle:ColorOffsetStyle = meshStyle as ColorOffsetStyle;
    if (colorOffsetStyle)
    {
        for (var i:int=0; i<4; ++i)
            _offsets[i] = colorOffsetStyle._offsets[i];
    }

    super.copyFrom(meshStyle);
}
----

単純なコードです。
もしもスタイルが正しい型である場合、現在のインスタンスのオフセット値をコピーしています。
残りの処理はスーパークラスが受け持ってくれます。

==== createEffect

このメソッドには見覚えがありますね？

[source, as3]
----
override public function createEffect():MeshEffect
{
    return new ColorOffsetEffect();
}
----

これはフィルターのそれと同じように働きます。後ほど作成する `ColorOffsetEffect` を戻り値とします。
この ColorOffsetEffect はフィルタークラスで使ったものと同じではありません。（オフセット値は頂点から読み取られています。）
しかし、フィルターとスタイルの両方で動くエフェクトを作る事は可能です。

==== onTargetAssigned

上で述べたように、ターゲットとなるメッシュの頂点にオフセット値を保持する必要があります。
つまり、全ての頂点にオフセット値を保持させます。無駄な処理ではあるかもしれません。
これが、スタイルがバッチ処理をサポートする事を保証する唯一の方法なのです。

スタイルがターゲッチにアサインされるとこのコールバックが呼び出されます。これが頂点データを更新するきっかけとなります。
//原文：フィルターと書いてあるが、間違いだろう。When the filter is assigned a target, this callback will be executed -- that is our cue to update the vertices.
また後のタイミングでこの処理を行うことになるので、実際の処理は `updateVertices` メソッドに移動しました。

[source, as3]
----
override protected function onTargetAssigned(target:Mesh):void
{
    updateVertices();
}

private function updateVertices():void
{
    if (target)
    {
        var numVertices:int = vertexData.numVertices;
        for (var i:int=0; i<numVertices; ++i)
            vertexData.setPoint4D(i, "offset",
                _offsets[0], _offsets[1], _offsets[2], _offsets[3]);

        setRequiresRedraw();
    }
}
----

ここで、`vertexData` がどこからやってきたのだろうと疑問に思うかもしれません。
ターゲットがアサインされるとすぐに `vertexData` はターゲットの頂点を参照するようになります。（スタイル自身は頂点を保持していません。）
よって、このコードはターゲットの全ての頂点をループで回し、正しいオフセット値を設定し、レンダリングのための準備を行います。

=== Extending MeshEffect

We're done with the style class now -- time to move on to the effect, which is where the actual rendering takes place.
This time, we're going to extend the _MeshEffect_ class.
Remember, effects simplify writing of low-level rendering code.
I'm actually talking about a group of classes with the following inheritance:

[plantuml, effect-classes]
....
include::../defaults.plantuml[]

Effect <|-- FilterEffect
FilterEffect <|-- MeshEffect
....

The base class (_Effect_) does only the absolute minimum: it draws white triangles.
The _FilterEffect_ adds support for textures, and the _MeshEffect_ for color and alpha.

NOTE: Those two classes could also have been named _TexturedEffect_ and _ColoredTexturedEffect_, but I chose to baptize them with their usage in mind.
If you create a filter, you need to extend _FilterEffect_; if you create a mesh style, _MeshEffect_.

So let's look at the setup of our _ColorOffsetEffect_, with a few stubs we're filling in later.

[source, as3]
----
class ColorOffsetEffect extends MeshEffect
{
    public  static const VERTEX_FORMAT:VertexDataFormat =
        ColorOffsetStyle.VERTEX_FORMAT;

    public function ColorOffsetEffect()
    { }

    override protected function createProgram():Program
    {
        // TODO
    }

    override public function get vertexFormat():VertexDataFormat
    {
        return VERTEX_FORMAT;
    }

    override protected function beforeDraw(context:Context3D):void
    {
        super.beforeDraw(context);
        vertexFormat.setVertexBufferAt(3, vertexBuffer, "offset");
    }

    override protected function afterDraw(context:Context3D):void
    {
        context.setVertexBufferAt(3, null);
        super.afterDraw(context);
    }
}
----

If you compare that with the analog filter effect from the previous tutorial, you'll see that all the `offset`-properties were removed; instead, we're now overriding `vertexFormat`, which ensures that we are using the same format as the corresponding style, ready to have our offset values stored with each vertex.

==== beforeDraw と afterDraw

`beforeDraw` と `afterDraw` メソッドは、シェーダーが `va3` レジスタ (_vertex attribute 3_) から値を読み込めるようにコンテキストを設定します。
では、`beforeDraw` をみてみましょう。

[source, as3]
----
vertexFormat.setVertexBufferAt(3, vertexBuffer, "offset");
----

上記のコードは下記と同等です。

[source, as3]
----
context.setVertexBufferAt(3, vertexBuffer, 5, "float4");
----

三番目の引数 (`5 → bufferOffset`) は、頂点データのうち何番目がカラーオフセット値を示しているのかを表しています。
最後の引数 (`float4 → format`) は、属性値のフォーマットを示します、
寄ってこれらの値について、覚えておいたり再計算したりする必要はありません。`vertexFormat` に対してそれらの属性を設定するように頼めばいいのです。
この方法では、
That way, the code will continue to work if the format changes and we add, say, another attribute before the offset.

頂点の属性値は描画が終了した後に必ずクリアーされていなければいけません。なぜなら後続のドローコールが別のフォーマットで利用する可能性があるからです。
それが `afterDraw` メソッドで行う処理となります。

==== createProgram

It's finally time to tackle the core of the style; the AGAL code that does the actual rendering.
This time, we have to implement the vertex-shader as well; it won't do to use a standard implementation, because we need to add some custom logic.
The fragment shader, however, is almost identical to the one we wrote for the filter.
Let's take a look!

[source, as3]
----
override protected function createProgram():Program
{
    var vertexShader:String = [
        "m44 op, va0, vc0", // 4x4 matrix transform to output clip-space
        "mov v0, va1     ", // pass texture coordinates to fragment program
        "mul v1, va2, vc4", // multiply alpha (vc4) with color (va2), pass to fp
        "mov v2, va3     "  // pass offset to fp
    ].join("\n");

    var fragmentShader:String = [
        tex("ft0", "v0", 0, texture) +  // get color from texture
        "mul ft0, ft0, v1",             // multiply color with texel color
        "mov ft1, v2",                  // copy complete offset to ft1
        "mul ft1.xyz, v2.xyz, ft0.www", // multiply offset.rgb with alpha (pma!)
        "add oc, ft0, ft1"              // add offset, copy to output
    ].join("\n");

    return Program.fromSource(vertexShader, fragmentShader);
}
----

To understand what the vertex-shader is doing, you first have to understand the input it's working with.

* The `va`-registers ("vertex attribute") contain the attributes from the current vertex, taken from the vertex buffer.
  They are ordered just like the attributes in the vertex format we set up a little earlier: `va0` is the vertex position, `va1` the texture coordinates, `va2` the color, `va3` the offset.
* Two constants are the same for all our vertices: `vc0-3` contain the modelview-projection matrix, `vc4` the current alpha value.

The main task of any vertex shader is to move the vertex position into the so-called "clip-space".
That's done by multiplying the vertex position with the `mvpMatrix` (modelview-projection matrix).
The first line takes care of that, and you'll find it in any vertex shader in Starling.
Suffice it to say that it is responsible for figuring out where the vertex is ending up on the screen.

Otherwise, we're more or less just forwarding data to the fragment shader via the "varying registers" `v0` - `v2`.

The fragment shader is an almost exact replica of its filter-class equivalent.
Can you find the difference?
It's the register we're reading the offset from; before, that was stored in a constant, now in `v2`.

=== 動作テスト

オリジナルのスタイルの作成の完了まであと一歩です！
//原文：There you have it: we're almost finished with our style!
動作テストを行ってみましょう。
いきなりですが、２つのオブジェクトにスタイルを適用してみます。バッチ処理が正しく動いている事が確認できるはずです。
//原文：In a truly bold move, I'll use it on two objects right away, so that we'll see if batching works correctly.

[source, as3]
----
var image:Image = new Image(texture);
var style:ColorOffsetStyle = new ColorOffsetStyle();
style.redOffset = 0.5;
image.style = style;
addChild(image);

var image2:Image = new Image(texture);
image2.x = image.width;
var style2:ColorOffsetStyle = new ColorOffsetStyle();
style2.blueOffset = 0.5;
image2.style = style2;
addChild(image2);
----

.２つのスタイルのイメージがドローコール１回で描画されています。
image::custom-style-sample.png[Custom Style Sample]

やりました、正しく動いています！
左上のドローコール表示が１のままである事を確認してください。

しかし、まだ少しやらなけらばならない事があります。今回のシェーダーコードはテクスチャからデータを読み出す前提になっています。
しかし、このスタイルはテクスチャを使わないメッシュに適用される事もあり得るので、そのようなケースのために特別なコードを書かなくてはいけないでしょう。
（とてもシンプルなものですし、今ここで解説はしませんが。）

その点を修正した完全なコードは ここ: https://gist.github.com/PrimaryFeather/eaaa4a1b50cf546613d2[ColorOffsetStyle.as] で確認が可能です。

=== この先にたどり着く場所
//原文：Where to go from here

スタイルについては以上です！
私と同じようにあなたもスタイルの作成を楽しんでくれたなら良いのですが。
上記のやり方は、あなたの頭の中にある Starling 拡張を実現するキーとなるものです。
//翻訳苦しい 原文：What you see above is the key to extending Starling in ways that are limited only by your imagination.
_MeshStyle_ クラスにはまだいくつか実装のポイントがあります。クラスドキュメントも通して確認するようにしてください。
//原文：The _MeshStyle_ class even has a few more tricks up its sleeve, so be sure to read through the complete class documentation.

みんなが作ったスタイルを見る事を楽しみにしています！
